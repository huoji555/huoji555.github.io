<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Ragty"><meta name="copyright" content="Ragty"><title>When the world sleep, I dream. | Ragty の Blog</title><link rel="shortcut icon" href="/blog/melody-favicon.ico"><link rel="stylesheet" href="/blog/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://secure.gravatar.com/avatar/dcc38a5a0d37cb7348d4f72d8f6a2de0"></div><div class="author-info__name text-center">Ragty</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/huoji555" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">75</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">38</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/huoji555" target="_blank" rel="noopener">MY-CSDN</a></div></div></div><nav id="nav" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">Ragty の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/blog">Home</a><a class="site-page" href="/blog/archives">Archives</a><a class="site-page" href="/blog/categories">Categories</a><a class="site-page" href="/blog/tags">Tags</a><a class="site-page" href="/blog/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">Ragty の Blog</div><div id="site-sub-title">When the world sleep, I dream.</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://blog.csdn.net/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9C%89%E7%95%8C%E5%A0%86%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/">排序算法（三）堆排序及有界堆排序Java实现及分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%A0%86%E6%8E%92%E5%BA%8F-%E6%9C%89%E7%95%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">堆排序 有界堆排序 排序算法</a></span><div class="content"><a id="more"></a>

<br>

<h6 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h6><p>基数排序适用于大小有界的东西，除了他之外，还有一种你可能遇到的其它专用排序算法：有界堆排序。如果你在处理非常大的数据集，你想要得到前 10 个或者前<code>k</code>个元素，其中<code>k</code>远小于<code>n</code>，它是很有用的。</p>
<p>例如，假设你正在监视一 个Web 服务，它每天处理十亿次事务。在每一天结束时，你要汇报最大的<code>k</code>个事务（或最慢的，或者其它最 xx 的）。一个选项是存储所有事务，在一天结束时对它们进行排序，然后选择最大的<code>k</code>个。需要的时间与<code>nlogn</code>成正比，这非常慢，因为我们可能无法将十亿次交易记录在单个程序的内存中。我们必须使用“外部”排序算法。</p>
<p>我们首先了解一下堆，这是一个类似于二叉搜索树（BST）的数据结构。有一些区别：</p>
<ul>
<li>在 BST 中，每个节点<code>x</code>都有“BST 特性”：<code>x</code>左子树中的所有节点都小于<code>x</code>，右子树中的所有节点都大于<code>x</code>。</li>
<li>在堆中，每个节点<code>x</code>都有“堆特性”：两个子树中的所有节点都大于<code>x</code>。</li>
<li>堆就像平衡的 BST；当你添加或删除元素时，他们会做一些额外的工作来重新使树平衡。因此，可以使用元素的数组来有效地实现它们。</li>
</ul>
<blockquote>
<p>现在讨论的是小根堆。如果子树中的节点都小于根节点，则为大根堆。</p>
</blockquote>
<p>堆中最小的元素总是在根节点，所以我们可以在常数时间内找到它。在堆中添加和删除元素需要的时间与树的高度<code>h</code>成正比。而且由于堆总是平衡的，所以<code>h</code>与<code>log n</code>成正比。</p>
<p>Java<code>PriorityQueue</code>使用堆实现。<code>PriorityQueue</code>提供<code>Queue</code>接口中指定的方法，包括<code>offer</code>和<code>poll</code>：</p>
<ul>
<li><code>offer</code>：将一个元素添加到队列中，更新堆，使每个节点都具有“堆特性”。需要<code>logn</code>的时间。</li>
<li><code>poll</code>：从根节点中删除队列中的最小元素，并更新堆。需要<code>logn</code>的时间。</li>
</ul>
<p>给定一个<code>PriorityQueue</code>，你可以像这样轻松地排序的<code>n</code>个元素的集合 ：</p>
<ul>
<li>使用<code>offer</code>，将集合的所有元素添加到<code>PriorityQueue</code>。</li>
<li>使用<code>poll</code>从队列中删除元素并将其添加到<code>List</code>。</li>
</ul>
<p>因为<code>poll</code>返回队列中剩余的最小元素，所以元素按升序添加到<code>List</code>。这种排序方式称为堆排序 。</p>
<p>向队列中添加<code>n</code>个元素需要<code>nlogn</code>的时间。删除<code>n</code>个元素也是如此。所以堆排序的运行时间是<code>O(n logn)</code>。</p>
<p><br><br></p>
<h6 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2.代码实现："></a>2.代码实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 堆排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 19:15 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       PriorityQueue&lt;T&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;T&gt;(list.size(),comparator);</span><br><span class="line">       heap.addAll(list);</span><br><span class="line">       list.clear();</span><br><span class="line">       <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">           list.add(heap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">sorter.heapSort(list, comparator);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h6 id="3-有界堆排序"><a href="#3-有界堆排序" class="headerlink" title="3.有界堆排序"></a>3.有界堆排序</h6><p>有界堆是一个限制为最多包含<code>k</code>个元素的堆。如果你有<code>n</code>个元素，你可以跟踪这个最大的<code>k</code>个元素：</p>
<p>最初堆是空的。对于每个元素<code>x</code>：</p>
<ul>
<li>分支 1：如果堆不满，请添加<code>x</code>到堆中。</li>
<li>分支 2：如果堆满了，请与堆中<code>x</code>的最小元素进行比较。如果<code>x</code>较小，它不能是最大的<code>k</code>个元素之一，所以你可以丢弃它。</li>
<li>分支 3：如果堆满了，并且<code>x</code>大于堆中的最小元素，请从堆中删除最小的元素并添加<code>x</code>。</li>
</ul>
<p>使用顶部为最小元素的堆，我们可以跟踪最大的<code>k</code>个元素。我们来分析这个算法的性能。对于每个元素，我们执行以下操作之一：</p>
<ul>
<li>分支 1：将元素添加到堆是<code>O(log k)</code>。</li>
<li>分支 2：找到堆中最小的元素是<code>O(1)</code>。</li>
<li>分支 3：删除最小元素是<code>O(log k)</code>。添加<code>x</code>也是<code>O(log k)</code>。</li>
</ul>
<p>在最坏的情况下，如果元素按升序出现，我们总是执行分支 3。在这种情况下，处理<code>n</code>个元素的总时间是<code>O(n log k)</code>，对于<code>n</code>是线性的。</p>
<p><br><b></p>
<h6 id="4-代码实现："><a href="#4-代码实现：" class="headerlink" title="4.代码实现："></a>4.代码实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 有界堆排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 19:49 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">topK</span><span class="params">(<span class="keyword">int</span> k,List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       PriorityQueue&lt;T&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;T&gt;(list.size(),comparator);</span><br><span class="line">       <span class="keyword">for</span> (T element : list) &#123;</span><br><span class="line">           <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">               heap.offer(element);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> cmp = comparator.compare(element,heap.peek());</span><br><span class="line">           <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>) &#123;</span><br><span class="line">               heap.poll();</span><br><span class="line">               heap.offer(element);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;T&gt; res = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">           res.add(heap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">List&lt;Integer&gt; queue = sorter.topK(<span class="number">4</span>, list, comparator);</span><br><span class="line">System.out.println(queue);</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h6 id="5-空间复杂性"><a href="#5-空间复杂性" class="headerlink" title="5.空间复杂性"></a>5.空间复杂性</h6><p>到目前为止，我们已经谈到了很多运行时间的分析，但是对于许多算法，我们也关心空间。例如，归并排序的一个缺点是它会复制数据。在我们的实现中，它分配的空间总量是<code>O(n log n)</code>。通过优化，可以将空间降至<code>O(n)</code>。</p>
<p>相比之下，插入排序不会复制数据，因为它会原地排序元素。它使用临时变量来一次性比较两个元素，并使用一些其它局部变量。但它的空间使用不取决于<code>n</code>。</p>
<p>我们的堆排序实现创建了新<code>PriorityQueue</code>，来存储元素，所以空间是<code>O(n)</code>; 但是如果你能够原地对列表排序，则可以使用<code>O(1)</code>的空间执行堆排序 。</p>
<p>刚刚实现的有界堆栈算法的一个好处是，它只需要与<code>k</code>成正比的空间（我们要保留的元素的数量），而<code>k</code>通常比<code>n</code>小得多 。</p>
<p>软件开发人员往往比空间更加注重运行时间，对于许多应用程序来说，这是适当的。但是对于大型数据集，空间可能同等或更加重要。例如：</p>
<ul>
<li>如果一个数据集不能放入一个程序的内存，那么运行时间通常会大大增加，或者根本不能运行。如果你选择一个需要较少空间的算法，并且这样可以将计算放入内存中，则可能会运行得更快。同样，使用较少空间的程序，可能会更好地利用 CPU 缓存并运行速度更快。</li>
<li>在同时运行多个程序的服务器上，如果可以减少每个程序所需的空间，则可以在同一台服务器上运行更多程序，从而降低硬件和能源成本。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/">排序算法（二）归并排序Java实现及分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">归并排序Java实现 排序算法</a></span><div class="content"><a id="more"></a>


<br>

<h6 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h6><blockquote>
<p>归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</p>
<p>如　设有数列{6，202，100，301，38，8，1}</p>
<p>初始状态：6,202,100,301,38,8,1</p>
<p>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；</p>
<p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p>
<p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p>
<p>总的比较次数为：3+4+4=11；逆序数为14；</p>
</blockquote>
<p><img src="https://images2015.cnblogs.com/blog/1023577/201610/1023577-20161011232321687-190186195.png" alt=""></p>
<p><br><br></p>
<h6 id="2-归并排序分析"><a href="#2-归并排序分析" class="headerlink" title="2.归并排序分析"></a>2.归并排序分析</h6><p>为了对归并排序的运行时间进行划分，对递归层级和每个层级上完成多少工作方面进行思考，是很有帮助的。假设我们从包含<code>n</code>个元素的列表开始。以下是算法的步骤：</p>
<ul>
<li>生成两个新数组，并将一半元素复制到每个数组中。</li>
<li>排序两个数组。</li>
<li>合并两个数组。</li>
</ul>
<p>流程图如下：</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/17-1.jpg" alt=""></p>
<p>第一步复制每个元素一次，因此它是线性的。第三步也复制每个元素一次，因此它也是线性的。现在我们需要弄清楚步骤<code>2</code>的复杂性。为了做到这一点，查看不同的计算图片会有帮助，它展示了递归的层数，如下图所示。</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/17-2.jpg" alt=""></p>
<blockquote>
<p>上图为<strong>归并排序的展示</strong>，它展示了递归的所有层级。</p>
</blockquote>
<p>在顶层，我们有<code>1</code>个列表，其中包含<code>n</code>个元素。为了简单起见，我们假设<code>n</code>是<code>2</code>的幂。在下一层，有<code>2</code>个列表包含<code>n/2</code>个元素。然后是<code>4</code>个列表与<code>n/4</code>元素，以此类推，直到我们得到<code>n</code>个列表与<code>1</code>元素。</p>
<p>在每一层，我们共有<code>n</code>个元素。在下降的过程中，我们必须将数组分成两半，这在每一层上都需要与<code>n</code>成正比的时间。在回来的路上，我们必须合并<code>n</code>个元素，这也是线性的。</p>
<p>如果层数为<code>h</code>，算法的总工作量为<code>O(nh)</code>。那么有多少层呢？有两种方法可以考虑：</p>
<ul>
<li>我们用多少步，可以将<code>n</code>减半直到<code>1</code>？</li>
<li>或者，我们用多少步，可以将<code>1</code>加倍直到<code>n</code>？</li>
</ul>
<p>第二个问题的另一种形式是“<code>2</code>的多少次方是<code>n</code>”？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^h &#x3D; n</span><br></pre></td></tr></table></figure>

<p>对两边取以<code>2</code>为底的对数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &#x3D; log2(n)</span><br></pre></td></tr></table></figure>

<p>所以总时间是<code>O(nlogn)</code>。我没有纠结于对数的底，因为底不同的对数差别在于一个常数，所以所有的对数都是相同的增长级别。</p>
<p><code>O(nlogn)</code>中的算法有时被称为“线性对数”的，但大多数人只是说<code>n log n</code>。</p>
<p>事实证明，<code>O(nlogn)</code>是通过元素比较的排序算法的理论下限。这意味着没有任何“比较排序”的增长级别比<code>n log n</code>好。</p>
<p><br><br></p>
<h6 id="3-归并排序实现"><a href="#3-归并排序实现" class="headerlink" title="3.归并排序实现"></a>3.归并排序实现</h6><p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 归并排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:02 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSortInplace</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; sorted = mergeSort(list,comparator);</span><br><span class="line">       list.clear();</span><br><span class="line">       list.addAll(sorted);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 分割list并排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:10 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">mergeSort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size = list.size();</span><br><span class="line">       <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>  list;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每次让list中的元素减半(递归)</span></span><br><span class="line">       List&lt;T&gt; first = mergeSort(<span class="keyword">new</span> LinkedList&lt;T&gt;(list.subList(<span class="number">0</span>,size/<span class="number">2</span>)),comparator);</span><br><span class="line">       List&lt;T&gt; second = mergeSort(<span class="keyword">new</span> LinkedList&lt;T&gt;(list.subList(size/<span class="number">2</span>,size)),comparator);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> merge(first,second,comparator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 将两个排序好的list,合并为一个排序好的List(常数时间)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:19 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">merge</span><span class="params">(List&lt;T&gt; first,List&lt;T&gt; second, Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; result = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">int</span> total = first.size()+second.size();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;total; i++) &#123;</span><br><span class="line">           List&lt;T&gt; winner = pickWinner(first,second,comparator);</span><br><span class="line">           result.add(winner.remove(<span class="number">0</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 返回第一个元素较小的list,任意列表为空，返回另一个list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:52 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">pickWinner</span><span class="params">(List&lt;T&gt; first,List&lt;T&gt; second,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (first.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> second;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (second.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> first;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> res = comparator.compare(first.get(<span class="number">0</span>),second.get(<span class="number">0</span>));</span><br><span class="line">       <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> first;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> second;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  first;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">sorter.mergeSortInplace(list, comparator);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/">排序算法（一） 插入排序及Java实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a></span><div class="content"><a id="more"></a>


<br>


<blockquote>
<p>插入排序是一种简单的排序算法，从头遍历数组，依此比较排序</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">           T elt_i = list.get(i);</span><br><span class="line">           <span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">               T elt_j = list.get(j-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span> (comparator.compare(elt_i,elt_j)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               list.set(j,elt_j);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           list.set(j,elt_i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer elt1, Integer elt2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> elt1.compareTo(elt2);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     ListSorter&lt;Integer&gt; sorter = <span class="keyword">new</span> ListSorter&lt;Integer&gt;();</span><br><span class="line">     sorter.insertionSort(list, comparator);</span><br><span class="line">     System.out.println(list);</span><br></pre></td></tr></table></figure>

<p><code>insertionSort</code>有两个嵌套循环，所以你可能会猜到，它的运行时间是二次的。在这种情况下，一般是正确的，但你做出这个结论之前，你必须检查，每个循环的运行次数与<code>n</code>，数组的大小成正比。</p>
<p>外部循环从<code>1</code>迭代到<code>list.size()</code>，因此对于列表的大小<code>n</code>是线性的。内循环从<code>i</code>迭代到<code>0</code>，所以在<code>n</code>中也是线性的。因此，两个循环运行的总次数是二次的。</p>
<p>如果你不确定，这里是证明：</p>
<p>第一次循环中，<code>i = 1</code>，内循环最多运行一次。 第二次，<code>i = 2</code>，内循环最多运行两次。 最后一次，<code>i = n - 1</code>，内循环最多运行<code>n</code>次。</p>
<p>因此，内循环运行的总次数是序列<code>1, 2, ..., n - 1</code>的和，即<code>n(n - 1)/2</code>。该表达式的主项（拥有最高指数）为<code>n^2</code>。</p>
<p>在最坏的情况下，插入排序是二次的。然而：</p>
<ul>
<li>如果这些元素已经有序，或者几乎这样，插入排序是线性的。具体来说，如果每个元素距离它的有序位置不超过<code>k</code>个元素，则内部循环不会运行超过<code>k</code>次，并且总运行时间是<code>O(kn)</code>。</li>
<li>由于实现简单，开销较低；也就是，尽管运行时间是<code>an^2</code>，主项的系数<code>a</code>，也可能是小的。</li>
</ul>
<p>所以如果我们知道数组几乎是有序的，或者不是很大，插入排序可能是一个不错的选择。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/11/Can't%20find%20vcruntime140.dll%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/">Can't find vcruntime140.dll 问题解决</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/VC/">VC++</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/VC-%E5%AE%89%E8%A3%85/">VC++安装</a></span><div class="content"><a id="more"></a>

<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>最近在新系统运行C++软件时，出现了一些问题，运行软件时，出现了以下提示:</p>
<blockquote>
<p>Can’t find vcruntime140.dll </p>
</blockquote>
<p>VC++安装日志同时报错，如下:</p>
<blockquote>
<p>[0D4C:0624][2019-06-11T17:38:38]e000: Error 0x80004005: Failed to extract all files from container.<br>[0D4C:06CC][2019-06-11T17:38:38]e000: Error 0x80004005: Faild to begin and wait for operation.<br>[0D4C:06CC][2019-06-11T17:38:38]e000: Error 0x80004005: Failed to extract payload: a7 from container: WixAttachedContainer</p>
</blockquote>
<br>

<h3 id="2-问题所在及解决"><a href="#2-问题所在及解决" class="headerlink" title="2.问题所在及解决"></a>2.问题所在及解决</h3><p>之所以安装失败因为缺少编译C++运行的动态库.<br>需要按次序安装：<br>1.<code>vcredist_x64.exe</code><br>2.<code>vcredist_msvc2015_x86.exe</code></p>
<p>以下为下载链接:<br>链接：<a href="https://pan.baidu.com/s/1SHg17qHb4md6_GWsBAUtTQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1SHg17qHb4md6_GWsBAUtTQ</a><br>提取码：7ma3 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/07/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%20%20%20%20TF_IDF%E4%B9%8BJava%E5%AE%9E%E7%8E%B0/">搜索引擎优化    TF_IDF之Java实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">搜索引擎</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/TF-iIDF-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/">TF-iIDF 搜索引擎优化</a></span><div class="content"><a id="more"></a>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>实现之前，我们要事先说明一些问题：</p>
<p>我们用Redis对数据进行持久化，存两种形式的MAP:</p>
<ul>
<li>key值为term，value值为含有该term的url</li>
<li>key值为url，value值为map，记录term及在文章中出现的次数</li>
</ul>
<p>总的计算公式如下：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/10109d0e60cc9d50a1ea2f189bac0ac29a030a00" alt=""></p>
<br>

<h4 id="1-计算词频TF"><a href="#1-计算词频TF" class="headerlink" title="1.计算词频TF"></a>1.计算词频<strong>TF</strong></h4><blockquote>
<p>这里通过给出url地址，获取搜索词<strong>term</strong>在此url中的数量，计算出TF</p>
</blockquote>
<br>

<p><strong>获取url中的词汇总数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取url中的词汇总数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 11:18 2019/6/4</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getWordCount</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">       String redisKey = urlSetKey(url);</span><br><span class="line">       Map&lt;String,String&gt; map = jedis.hgetAll(redisKey);</span><br><span class="line">       Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123;</span><br><span class="line">           count += Integer.valueOf(entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>返回搜索项在url中出现的次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span> 返回搜索项在url中出现的次数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span> 22:12 2019/5/14</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getTermCount</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">      String redisKey = urlSetKey(url);</span><br><span class="line">      String count = jedis.hget(redisKey,term);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>获取搜索词的词频</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取搜索词的词频(Term Frequency)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 11:25 2019/6/4</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getTermFrequency</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isIndexed(url)) &#123;</span><br><span class="line">           System.out.println(<span class="string">"Doesn't indexed."</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Integer documentCount = getWordCount(url);</span><br><span class="line">       Integer termCount = getTermCount(url,term);</span><br><span class="line">       <span class="keyword">return</span> documentCount==<span class="number">0</span> ? <span class="keyword">new</span> BigDecimal(<span class="number">0</span>) :  <span class="keyword">new</span> BigDecimal(termCount).divide(<span class="keyword">new</span> BigDecimal(documentCount),<span class="number">6</span>,BigDecimal.ROUND_HALF_UP);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h4 id="2-计算逆文档频率"><a href="#2-计算逆文档频率" class="headerlink" title="2.计算逆文档频率"></a>2.计算逆文档频率</h4><blockquote>
<p>计算逆文档频率，需要计算文档总数，以及包含该搜索词的文章数</p>
</blockquote>
<br>

<p><strong>获取redis索引文章的总数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取redis索引文章的总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 19:46 2019/6/5</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getUrlCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer count = <span class="number">0</span>;</span><br><span class="line">    count = urlSetKeys().size();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>获取含有搜索词的文章数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取含有搜索词的文章数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 22:42 2019/6/5</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getUrlTermCount</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">       Integer count = <span class="number">0</span>;</span><br><span class="line">       count = getUrls(term).size();</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>计算逆文档频率IDF(InverseDocumnetFrequency)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 计算逆文档频率IDF(InverseDocumnetFrequency)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:32 2019/6/5</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getInverseDocumentFrequency</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">       Integer totalUrl = getUrlCount();</span><br><span class="line">       Integer urlTermCount = getUrlTermCount(term);</span><br><span class="line">       Double xx = <span class="keyword">new</span> BigDecimal(totalUrl).divide(<span class="keyword">new</span> BigDecimal(urlTermCount),<span class="number">6</span>,BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">       BigDecimal idf = <span class="keyword">new</span> BigDecimal(Math.log10(xx));</span><br><span class="line">       <span class="keyword">return</span> idf;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h4 id="3-获取TF-IDF"><a href="#3-获取TF-IDF" class="headerlink" title="3.获取TF-IDF"></a>3.获取TF-IDF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span> 获取tf-idf值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span> 23:34 2019/6/5</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getTFIDF</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">      BigDecimal tf = getTermFrequency(url, term);</span><br><span class="line">      BigDecimal idf = getInverseDocumentFrequency(term);</span><br><span class="line">      BigDecimal tfidf  =tf.multiply(idf);</span><br><span class="line">      <span class="keyword">return</span> tfidf;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h4 id="4-数据测试"><a href="#4-数据测试" class="headerlink" title="4.数据测试"></a>4.数据测试</h4><blockquote>
<p>这里我采用我自己爬取的部分数据，进行一下简单的测试(可能因为数据集的原因导致部分结果不准确)</p>
</blockquote>
<p><strong>测试类方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取tfidf下的相关性</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 8:47 2019/6/6</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title">getRelevance</span><span class="params">(String url,String term,JedisIndex index)</span> </span>&#123;</span><br><span class="line">       BigDecimal tfidf = index.getTFIDF(url,term);</span><br><span class="line">       <span class="keyword">return</span> tfidf;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 执行搜索</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:49 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WikiSearch <span class="title">search</span><span class="params">(String term,JedisIndex index)</span> </span>&#123;</span><br><span class="line">       Map&lt;String,BigDecimal&gt; map = <span class="keyword">new</span> HashMap&lt;String, BigDecimal&gt;();</span><br><span class="line">       Set&lt;String&gt; urls = index.getUrls(term);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">           BigDecimal tfidf = getRelevance(url,term,index).setScale(<span class="number">6</span>,BigDecimal.ROUND_HALF_UP);</span><br><span class="line">           map.put(url,tfidf);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(map);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 按搜索项频率顺序打印内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 13:46 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Entry&lt;String,BigDecimal&gt;&gt; entries = sort();</span><br><span class="line">       <span class="keyword">for</span>(Entry&lt;String,BigDecimal&gt; entry: entries) &#123;</span><br><span class="line">           System.out.println(entry.getKey()+<span class="string">"         "</span>+entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 根据相关性对数据排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 13:54 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Entry&lt;String,BigDecimal&gt;&gt; sort()&#123;</span><br><span class="line">       List&lt;Entry&lt;String,BigDecimal&gt;&gt;  entries = <span class="keyword">new</span> LinkedList&lt;Entry&lt;String, BigDecimal&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">       Comparator&lt;Entry&lt;String,BigDecimal&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Entry&lt;String, BigDecimal&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, BigDecimal&gt; o1, Entry&lt;String, BigDecimal&gt; o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Collections.sort(entries,comparator);</span><br><span class="line">       <span class="keyword">return</span> entries;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Jedis jedis = JedisMaker.make();</span><br><span class="line">       JedisIndex index = <span class="keyword">new</span> JedisIndex(jedis);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// search for the first term</span></span><br><span class="line">       String term1 = <span class="string">"java"</span>;</span><br><span class="line">       System.out.println(<span class="string">"Query: "</span> + term1);</span><br><span class="line">       WikiSearch search1 = search(term1, index);</span><br><span class="line">       search1.print();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// search for the second term</span></span><br><span class="line">       String term2 = <span class="string">"programming"</span>;</span><br><span class="line">       System.out.println(<span class="string">"Query: "</span> + term2);</span><br><span class="line">       WikiSearch search2 = search(term2, index);</span><br><span class="line">       search2.print();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>测试结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Query: java</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/LiveScript         0.029956</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Java/85979         0.019986</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Brendan%20Eich         0.017188</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87/471435         0.013163</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Sun/69463         0.005504</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Rhino         0.004401</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E         0.003452</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/javascript         0.002212</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/js/10687961         0.002212</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%BA%90%E7%A0%81         0.002205</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%BA%90%E7%A0%81/344212         0.002205</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         0.001989</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/SQL         0.001779</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/PHP/9337         0.001503</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/iOS/45705         0.001499</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Netscape         0.000863</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F         0.000835</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Mac%20OS%20X         0.000521</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         0.000318</span></span><br><span class="line"></span><br><span class="line">Query: programming</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         0.004854</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         0.002529</span></span><br></pre></td></tr></table></figure>



<p>以上只提供部分代码及思路，完整的搜索引擎代码及tf_idf实现，请参照Github</p>
<p>代码地址：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure/SearchEngine" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure/SearchEngine</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/06/01/TF-IDF%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/">TF-IDF算法概述及模型构建</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">搜索引擎</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/TF-IDF-TF-IDF-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/">TF-IDF TF IDF 搜索引擎 模型构建</a></span><div class="content"><a id="more"></a>


<h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h4><p>我在构建搜索引擎的时候，需要构建一个排名算法。我最初版本的做法为，根据一篇文章中词汇出现的频率，对各个网页进行排序。这样会有一个很明显的缺点，当我们页面中出现很多<strong>中止词（例如，the,1,2）</strong>时，这样不能客观反映搜索词对文档的重要程度。</p>
<p><strong>我们需要调整某些单词在一般情况下更频繁出现的事实（过滤中止词）</strong>。TF-IDF值（搜索词的重要性），随着单词在文件中出现的次数成正比增加，但同时会随着它在包含该单词的所有文档中出现的频率成反比下降(从这里可以推出TF-IDF的公式)，<strong>从而获取该文章关于搜索词重要性的权值。</strong></p>
<blockquote>
<p>TF-IDF是当今最受欢迎的术语加权方案之一，旨在反映搜索词对集合中文档的重要程度。</p>
<p>它的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p>
</blockquote>
<p>应用方面：</p>
<ul>
<li><strong>搜索引擎</strong>经常使用tf-idf加权方案，作为在给定用户查询的情况下对文档的相关性进行评分和排序的核心工具。tf-idf可以成功地用于各种主题领域的停止词过滤，包括文本摘要的分类。</li>
<li>通过对每个查询项的tf-idf求和来计算最简单的<strong>排名函数之一</strong> ; 许多更复杂的排名函数是这个简单模型的变体。</li>
</ul>
<br>

<h4 id="2-TF-IDF解释"><a href="#2-TF-IDF解释" class="headerlink" title="2.TF-IDF解释"></a>2.TF-IDF解释</h4><p><strong>TF(Term Frequency)</strong>：表示词汇频率。</p>
<p>假设我们有一套英文文本文档，并希望对与查询最相关的文档进行排名，搜索词为<code>The Brown cow</code>.我们最简单的方法是，删除不包含<code>the</code>，<code>brown</code>，<code>cow</code>所有这些词的文档，但如此操作后，仍剩余许多文档。为了进一步区分它们，需要计算这些搜索词在文档中出现的次数，<strong>我们将搜索词在文档中出现的频率称作词频(TF)</strong>，这个数字是对<strong>词数（Term Count）</strong>的归一化，以防止它偏向长的文件(<strong>同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否</strong>)。</p>
<p>如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。这种搜索词加权可归纳为：</p>
<blockquote>
<p>文档中出现的搜索词的权重与搜索词频率成正比</p>
</blockquote>
<p>TF的不足之处：</p>
<blockquote>
<p>它不能有效的过滤<code>中止词</code>，例如上述提到的<code>the</code></p>
</blockquote>
<p><strong>IDF(Inverse document frequency)</strong>：表示逆向文档频率。</p>
<blockquote>
<p>IDF是一个词语普遍重要性的度量(过滤中止词)</p>
</blockquote>
<p>接着上面的例子讲，因为搜索词<code>the</code>很常见，<strong>TF(Term Frequency)</strong>倾向于错误地强调更频繁地使用“the”一词的文档（这里可以将<code>the</code>看作为中止词），<strong>而没有给予更有意义的术语“brown”和“cow”足够的权重</strong>。与不常见的单词“brown”和“cow”不同，术语“the”不是区分相关和非相关文档和术语的好关键词。因此，结合了<strong>逆文档频率因子</strong>，其减少了在文档集中频繁出现的术语的权重（<strong>降低中止词权重</strong>），并且增加了很少出现的词语的权重。这种加权可以归纳为：</p>
<blockquote>
<p>词语的特异性可以量化为其<strong>出现的文档数量的反函数</strong></p>
</blockquote>
<br>

<h4 id="3-模型解释"><a href="#3-模型解释" class="headerlink" title="3.模型解释"></a>3.模型解释</h4><blockquote>
<p><code>TF-IDF</code>是两个统计量的乘积。有多种方法可以确定统计量的具体值。</p>
</blockquote>
<p><strong>词频(TF)</strong></p>
<p>在<strong>术语频率</strong> tf（<em>t</em>，<em>d</em>）的情况下，最简单的选择是使用文档中单词的原始计数，f(t,d)即单词<strong>t</strong>在文档<strong>d</strong>中出现的次数，即(t/d)。最简单的tf方案是tf（<em>t</em>，<em>d</em>）= <em>f</em> (t,d)。其他可能性包括：</p>
<ul>
<li>布尔“频率”：TF（t,d）= 1，如果d中出现t为1，否则为0;</li>
<li>根据文件长度调整的词频： f(t,d)/ (d中的总词数);</li>
<li>对数缩放频率：TF（t,d）= log（1 +  f(t,d) ） ; </li>
<li>增加频率，以防止偏向更长的文档，例如原始频率除以文档中最常出现的单词的原始频率：</li>
</ul>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/da4be29a89f4c67ff5a8ad0c7355df1aff67a65b" alt=""></p>
<p><code>词频（tf）权重的变体</code></p>
<table>
<thead>
<tr>
<th align="left">加权计划</th>
<th align="left">权重</th>
</tr>
</thead>
<tbody><tr>
<td align="left">二进制</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a019735e07635e5a74673d6e1a34919027e645f5" alt="{0,1}"></td>
</tr>
<tr>
<td align="left">原始计数</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/69faba5875c1ba7d6a3820c813ba22fba35185f5" alt=""></td>
</tr>
<tr>
<td align="left">期限频率(使用最频繁)</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/91699003abf4fe8bdf861bbce08e73e71acf5fd4" alt=""></td>
</tr>
<tr>
<td align="left">日志规范化</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c173382612c58c00325c4e9f593739ab3afc324" alt=""></td>
</tr>
<tr>
<td align="left">双标准化K.</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/65b776d7a3f8e42f15c880fb7582282b987684fe" alt=""></td>
</tr>
<tr>
<td align="left">双归一化0.5</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45badc1c70ec2caa00ed8c21ed75bd9f8d3e650c" alt=""></td>
</tr>
</tbody></table>
<p><strong>IDF（逆向文档频率）</strong></p>
<blockquote>
<p><strong>对文档中的罕见词进行加权</strong>(通过将文档总数除以包含该项的文档数，然后取该商的对数得到).</p>
</blockquote>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ac67bc0f76b5b8e31e842d6b7d28f8949dab7937" alt=""></p>
<p>N表示语料库中的文档总数</p>
<p>tf(t,d)表示包含搜索词的文档数，搜索词不在语料库中时为0。则这将导致除零。因此，通常将分母调整为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/104921c6994a66054acc909a6bb811a47f983a53" alt=""></p>
<p>利用  <strong>lg1=0</strong>  解决0的问题</p>
<p><code>IDF（逆向文档频率）权重的变体</code></p>
<table>
<thead>
<tr>
<th align="left">加权计划</th>
<th align="center">（IDF权重）    <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e5d6fca54b5ec3fa4680ead41736fc1c16a58ca1" alt=""></th>
</tr>
</thead>
<tbody><tr>
<td align="left">一元</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left">逆文档频率</td>
<td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/864fcfdc0c16344c11509f724f1aa7081cf9f657" alt="{\ displaystyle \ log {\ frac {N} {n_ {t}}} =  -  \ log {\ frac {n_ {t}} {N}}}"></td>
</tr>
<tr>
<td align="left">逆文档频率平滑</td>
<td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/23e5ae785c1ddc6bd95d404ea3fac2477fff5eff" alt=""></td>
</tr>
<tr>
<td align="left">逆文档频率最大值</td>
<td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f15c125a1d7f1327afeecc4e2b89272a9a094338" alt=""></td>
</tr>
<tr>
<td align="left">概率逆文档频率</td>
<td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1868194cba8431aa2d556dd1aac90d78833eaaf3" alt=""></td>
</tr>
</tbody></table>
<p><strong>TF-IDF</strong></p>
<p>下面给出<code>TF-IDF</code>的计算公式</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/10109d0e60cc9d50a1ea2f189bac0ac29a030a00" alt=""></p>
<p><code>TF-DIF模型原理解释</code></p>
<blockquote>
<p>通过高频词汇(在给定文件中）达到tf-idf的高权重，并且在整个文档集合中该搜索词的文档频率低; 因此，权重倾向于过滤掉常用术语。<strong>由于idf的log函数内的比率始终大于或等于1(比率为1时，idf值为0)</strong>，因此idf（和tf-idf）的值大于或等于0.当一个术语出现在更多文档中时，对数内的比率接近1 ，使idf和tf-idf更接近0。</p>
</blockquote>
<p><strong>nt越大(中止词越多)，比率越接近于1，idf的值越接近于0.</strong></p>
<p><code>推荐的加权组合方案</code></p>
<table>
<thead>
<tr>
<th align="center">加权计划</th>
<th align="left">文档搜索词权重</th>
<th align="left">查询搜索词权重</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74db3d91105b74e8450a78fadbf7ea7f241bc737" alt=""></td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fe1629098093a97eb293bd5085009c51c3cdd77b" alt=""></td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dc85c57525999f9f224ac5623e606bea2160d171" alt=""></td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29f34f3a19a3fec371d5ab2756896a4c3cfc0d96" alt=""></td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c271425fa07254a10379f1379e02d0fd034f4f21" alt=""></td>
<td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cb8cdf7f351b63973cee045cc98c9efcde04203a" alt=""></td>
</tr>
</tbody></table>
<br>

<h4 id="4-实例展示"><a href="#4-实例展示" class="headerlink" title="4.实例展示"></a>4.实例展示</h4><blockquote>
<p>在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用” 相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它们在一篇特定网页中的词频分别是: TF1, TF2, …, TFN.（TF: term frequency)。 那么，这个查询和该网页的相关性就是:TF1 + TF2 + … + TFN。<br>在上面的例子中，词“的”占了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“中止词”（Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删除词后，上述网页的相似度就变成了0.007，其中“原子能”贡献了 0.002，“应用”贡献了 0.005。细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词，而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>
</blockquote>
<ul>
<li>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次，对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</li>
<li>应删除词的权重应该是零。</li>
</ul>
<blockquote>
<p>我们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们看到它仍然不是很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键词 w 在 Dw 个网页中出现过，那么 Dw 越大，w的权重越小，反之亦然。在信息检索中，使用最多的权重是“逆文本频率指数” （Inverse document frequency 缩写为IDF），它的公式为log（D/Dw）其中D是全部网页数。比如，我们假定中文网页数是D=10亿，应删除词“的”在所有的网页中都出现，即Dw=10亿，那么它的IDF=log(10亿/10亿）= log (1) = 0。假如专用词“原子能”在两百万个网页中出现，即Dw=200万，则它的权重IDF=log(500) =2.7。又假定通用词“应用”，出现在五亿个网页中，它的权重IDF = log(2)则只有 0.3。也就是说，在网页中找到一个“原子能”的匹配相当于找到九个“应用”的匹配。利用 IDF，上述相关性计算的公式就由词频的简单求和变成了加权求和，即 TF1<em>IDF1 +　TF2</em>IDF2 +… + TFN*IDFN。在上面的例子中，该网页和“原子能的应用”的相关性为 0.0069，其中“原子能”贡献了 0.0054，而“应用”只贡献了0.0015。这个比例和我们的直觉比较一致了。</p>
</blockquote>
<br>

<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>本质上IDF是一种试图抑制噪音的加权 ，并且<strong>单纯地认为文本频数小的单词就越重要</strong>，<strong>文本频数大的单词就越无用</strong>，显然这并不是完全正确的。IDF的简单结构并<strong>不能有效地反映单词的重要程度和特征词的分布情况</strong>，使其无法很好地完成对权值调整的功能，所以TFIDF法的精度并不是很高。</p>
<p>我们在构建搜索引擎时，特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。<strong>因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果</strong>。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%20%E5%B8%83%E5%B0%94%E6%90%9C%E7%B4%A2/">数据结构思维笔记（十七） 布尔搜索</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%B8%83%E5%B0%94%E6%90%9C%E7%B4%A2-TF-%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/">布尔搜索 TF 搜索优化</a></span><div class="content"><a id="more"></a>

<p>接着上一节的内容，我们已经构建了一个爬取百度百科并持久化的爬虫。现在客户使用，我们需要构建一个搜索工具。</p>
<h6 id="1-信息检索"><a href="#1-信息检索" class="headerlink" title="1.信息检索"></a>1.信息检索</h6><p>这个项目的下一个阶段是实现一个搜索工具。我们需要的部分包括：</p>
<ul>
<li>一个界面，其中用户可以提供检索词并查看结果。</li>
<li>一种查找机制，它接收每个检索词并返回包含它的页面。</li>
<li><strong>用于组合来自多个检索词的搜索结果的机制</strong>。</li>
<li>对搜索结果<strong>打分和排序的算法</strong>。</li>
</ul>
<br>

<h6 id="2-布尔搜索"><a href="#2-布尔搜索" class="headerlink" title="2.布尔搜索"></a>2.布尔搜索</h6><p>大多数搜索引擎可以执行“布尔搜索”，这意味着你<strong>可以使用布尔逻辑来组合来自多个检索词的结果</strong>。例如：</p>
<ul>
<li>搜索“java + 编程”（加号可省略）可能只返回包含两个检索词：“java”和“编程”的页面。</li>
<li>“java OR 编程”可能会返回包含任一检索词但不一定同时出现的页面。</li>
<li>“java -印度尼西亚”可能返回包含“java”，不包含“印度尼西亚”的页面。</li>
</ul>
<p><strong>包含检索词和运算符的表达式称为“查询”。</strong></p>
<p>当应用给搜索结果时，布尔操作符<code>+</code>，<code>OR</code>和<code>-</code>对应于集合操作 交，并和差。例如，假设</p>
<ul>
<li><code>s1</code>是包含“java”的页面集，</li>
<li><code>s2</code>是包含“编程”的页面集，以及</li>
<li><code>s3</code>是包含“印度尼西亚”的页面集。</li>
</ul>
<p>在这种情况下：</p>
<ul>
<li><code>s1</code>和<code>s2</code>的交集是含有“java”和“编程”的页面集。</li>
<li><code>s1</code>和<code>s2</code>的并集是含有“java”或“编程”的页面集。</li>
<li><code>s1</code>与<code>s2</code>的差集是含有“java”而不含有“印度尼西亚”的页面集。</li>
</ul>
<p>布尔搜索实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算两个搜索结果的并集(更广了)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:13 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">or</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; union = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">     <span class="keyword">for</span>(String term: that.map.keySet()) &#123;</span><br><span class="line">         union.put(term,totalRelevence(<span class="keyword">this</span>.getRelevance(term),that.getRelevance(term)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(union);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算搜索项的交集</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:22 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">and</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; intersection = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">     <span class="keyword">for</span>(String term: that.map.keySet()) &#123;</span><br><span class="line">         <span class="keyword">if</span>(map.containsKey(term)) &#123;</span><br><span class="line">             intersection.put(term,totalRelevence(<span class="keyword">this</span>.getRelevance(term),that.getRelevance(term)));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(intersection);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算搜索项的差集</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:35 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">minus</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; difference = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">     <span class="keyword">for</span> (String term: that.map.keySet()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (difference.containsKey(term)) &#123;</span><br><span class="line">             difference.remove(term);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> WikiSearch(difference);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="3-打分排序"><a href="#3-打分排序" class="headerlink" title="3.打分排序"></a>3.打分排序</h6><p>现在需要根据检索词获取用户最需要的数据，<code>WikiSearch</code>对象包含 URL 到它们的相关性分数的映射。在信息检索的上下文中，<strong>“相关性分数”用于表示页面多么满足从查询推断出的用户需求</strong>。相关性分数的构建有很多种方法，但大部分都基于“检索词频率”，它是搜索词在页面上的显示次数。一种常见的相关性分数称为 TF-IDF，代表“<strong>检索词频率 - 逆向文档频率”</strong>。</p>
<p>下面是<code>WikiSearch</code>的初始构造:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map from URLs that contain the term(s) to relevance score</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiSearch</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRelevance</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        Integer relevance = map.get(url);</span><br><span class="line">        <span class="keyword">return</span> relevance==<span class="keyword">null</span> ? <span class="number">0</span>: relevance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WikiSearch</code>对象包含 URL 到它们的相关性分数的映射。在信息检索的上下文中，<strong>“相关性分数”用于表示页面多么满足从查询推断出的用户需求</strong>。相关性分数的构建有很多种方法，但大部分都基于“检索词频率”，它是搜索词在页面上的显示次数。一种常见的相关性分数称为 TF-IDF，代表“检索词频率 - 逆向文档频率”。</p>
<p>我们将从一些更简单的 TF 开始：</p>
<ul>
<li>如果查询包含单个检索词，页面的相关性就是其词频；也就是说该词在页面上出现的次数。</li>
<li>对于具有多个检索词的查询，页面的相关性是检索词频率的总和；也就是说，任何检索词出现的总次数。</li>
</ul>
<p>搜索结果排序实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Entry&lt;String,Integer&gt;&gt; sort()&#123;</span><br><span class="line">     List&lt;Entry&lt;String,Integer&gt;&gt;  entries = <span class="keyword">new</span> LinkedList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Entry&lt;String,Integer&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     Collections.sort(entries,comparator);</span><br><span class="line">     <span class="keyword">return</span> entries;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有两个<code>sort</code>版本：</p>
<ul>
<li>单参数版本接受列表并使用它的<code>compareTo</code>方法对元素进行排序，因此元素必须是<code>Comparable</code>。</li>
<li>双参数版本接受任何对象类型的列表和一个<code>Comparator</code>，它是一个提供<code>compare</code>方法的对象，用于比较元素。</li>
</ul>
<br>

<h6 id="4-检索测试"><a href="#4-检索测试" class="headerlink" title="4.检索测试?"></a>4.检索测试?</h6><p>下面提供检索代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Jedis jedis = JedisMaker.make();</span><br><span class="line">        JedisIndex index = <span class="keyword">new</span> JedisIndex(jedis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search for the first term</span></span><br><span class="line">        String term1 = <span class="string">"java"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term1);</span><br><span class="line">        WikiSearch search1 = search(term1, index);</span><br><span class="line">        search1.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search for the second term</span></span><br><span class="line">        String term2 = <span class="string">"programming"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term2);</span><br><span class="line">        WikiSearch search2 = search(term2, index);</span><br><span class="line">        search2.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the intersection of the searches</span></span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term1 + <span class="string">" AND "</span> + term2);</span><br><span class="line">        WikiSearch intersection = search1.and(search2);</span><br><span class="line">        intersection.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>检索结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Query: java?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Java/85979         38</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%AC%A7%E6%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8         12</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87/471435         10</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/PHP/9337         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Brendan%20Eich         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Rhino         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/LiveScript         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Sun/69463         4</span></span><br><span class="line"></span><br><span class="line">Query: programming?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         1</span></span><br><span class="line"></span><br><span class="line">Query: java AND programming?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         7</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         3</span></span><br></pre></td></tr></table></figure>

<br>

<h6 id="5-搜索优化"><a href="#5-搜索优化" class="headerlink" title="5.搜索优化"></a>5.搜索优化</h6><p>现存的问题：</p>
<blockquote>
<p>若同一主题的文章，A1万字，它的关键词出现的次数肯定会高，B100字，出现的次数肯定会少。对于具有多个检索词的查询，每个页面的总体相关性目前是每个检索词的相关性的总和。但实际上采用我们上述所用的方法不能客观的去选出内容最符合的文章。</p>
</blockquote>
<p>我们需要的解决方案：</p>
<blockquote>
<p>去掉网络<strong>中止词</strong>后，显示一个词在文本中所出现的频率，频率越高，则说明该搜索词与文章的相关性越大。</p>
<p>后期可用<code>TF-IDF</code>算法优化</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/">数据结构思维笔记（十六）爬取百度百科</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4-%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91-%E7%88%AC%E8%99%AB/">数据结构思维 爬取百度百科 爬虫</a></span><div class="content"><a id="more"></a>


<h6 id="1-基于Redis的索引器"><a href="#1-基于Redis的索引器" class="headerlink" title="1.基于Redis的索引器"></a>1.基于Redis的索引器</h6><p>在我的解决方案中，我们在 Redis 中存储两种结构：</p>
<ul>
<li>对于每个检索词，我们有一个<code>URLSet</code>，它是一个 Redis 集合，包含检索词的 URL。</li>
<li>对于每个网址，我们有一个<code>TermCounter</code>，这是一个 Redis 哈希表，将每个检索词映射到它出现的次数。</li>
</ul>
<p>在<code>JedisIndex</code>中，我提供了一个方法，它可以接受一个检索词并返回 Redis 中它的<code>URLSet</code>的键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">urlSetKey</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"URLSet:"</span>+url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及一个方法，接受 URL 并返回 Redis 中它的<code>TermCounter</code>的键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">termCounterKey</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TermCounter:"</span>+term;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是<code>indexPage</code>的实现（索引化一个界面）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexPage</span><span class="params">(String url, Elements elements)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Indexing..."</span> + url);</span><br><span class="line"></span><br><span class="line">       TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">       tc.processElements(elements);</span><br><span class="line"></span><br><span class="line">       pushTermCounterToRedis(tc);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>为了索引页面，我们：</p>
<ul>
<li>为页面内容创建一个 Java 的<code>TermCounter</code>，使用上一个练习中的代码。</li>
<li>将<code>TermCounter</code>的内容推送到 Redis。</li>
</ul>
<p>以下是将<code>TermCounter</code>的内容推送到 Redis 的新代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">pushTermCounterToRedis</span><span class="params">(TermCounter tc)</span> </span>&#123;</span><br><span class="line">    Transaction t = jedis.multi();</span><br><span class="line"></span><br><span class="line">    String url = tc.getLabel();</span><br><span class="line">    String redisKey = urlSetKey(url);</span><br><span class="line">    t.del(redisKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String term: tc.keySet()) &#123;</span><br><span class="line">        Integer count = tc.get(term);</span><br><span class="line">        t.hset(redisKey, term, count.toString());</span><br><span class="line">        t.sadd(termCounterKey(term),url);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Object&gt; res = t.exec();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法使用<code>Transaction</code>来收集操作，<strong>并将它们一次性发送到服务器，这比发送一系列较小操作要快得多</strong>。</p>
<p>它遍历<code>TermCounter</code>中的检索词。对于每一个，它：</p>
<ul>
<li>在 Redis 上寻找或者创建<code>TermCounter</code>，然后为新的检索词添加字段。</li>
<li>在 Redis 上寻找或创建<code>URLSet</code>，然后添加当前的 URL。</li>
</ul>
<p>如果页面已被索引，则<code>TermCounter</code>在推送新内容之前删除旧页面 。</p>
<p>这里还需要<code>getCounts</code>，它需要一个检索词，并从该词出现的每个网址返回一个映射。这是我的解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getCounts</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    Set&lt;String&gt; urls = getURLs(term);</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        Integer count = getCount(url, term);</span><br><span class="line">        map.put(url, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法使用两种辅助方法：</p>
<ul>
<li><code>getURLs</code>接受检索词并返回该字词出现的网址集合。</li>
<li><code>getCount</code>接受 URL 和检索词，并返回该检索词在给定 URL 处显示的次数。</li>
</ul>
<p>以下是实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getURLs</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = jedis.smembers(termCounterKey(term));</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">(String url, String term)</span> </span>&#123;</span><br><span class="line">    String redisKey = urlSetKey(url);</span><br><span class="line">    String count = jedis.hget(redisKey, term);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="2-查找的分析"><a href="#2-查找的分析" class="headerlink" title="2.查找的分析"></a>2.查找的分析</h6><p>假设我们索引了<code>N</code>个页面，并发现了<code>M</code>个唯一的检索词。检索词的查询需要多长时间？在继续之前，先考虑一下你的答案。</p>
<p>要查找一个检索词，我们调用<code>getCounts</code>，其中：</p>
<ul>
<li>创建映射。</li>
<li>调用<code>getURLs</code>来获取 URL 的集合。</li>
<li>对于集合中的每个 URL，调用<code>getCount</code>并将条目添加到<code>HashMap</code>。</li>
</ul>
<p><code>getURLs</code><strong>所需时间与包含检索词的网址数成正比</strong>。对于罕见的检索词，这可能是一个很小的数字，但是对于常见检索词，它可能和<code>N</code>一样大。</p>
<p>在循环中，我们调用了<code>getCount</code>，它在 Redis 上寻找<code>TermCounter</code>，查找一个检索词，并向<code>HashMap</code>添加一个条目。那些都是常数时间的操作，所以在最坏的情况下，<code>getCounts</code>的整体复杂度是<code>O(N)</code>。然而实际上，运行时间正比于包含检索词的页面数量，通常比<code>N</code>小得多。</p>
<p>这个算法根据复杂性是有效的，但是它非常慢，因为它向 <strong>Redis 发送了许多较小的操作</strong>。</p>
<p>解决办法：利用事务，解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Integer&gt; <span class="title">getCountsFaster</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将set集合转换为list,以便每次都有相同的遍历顺序</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    urls.addAll(getUrls(term));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个事务执行所有查询</span></span><br><span class="line">    Transaction t = jedis.multi();</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        String redisKey = urlSetKey(url);</span><br><span class="line">        t.hget(redisKey,term);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Object&gt; res = t.exec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历结果，制造出map</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        Integer count = <span class="keyword">new</span> Integer((String)res.get(i++));</span><br><span class="line">        map.put(url,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="3-索引的分析"><a href="#3-索引的分析" class="headerlink" title="3.索引的分析"></a>3.索引的分析</h6><p>使用我们设计的数据结构，页面的索引需要多长时间？再次考虑你的答案，然后再继续。</p>
<p>为了索引页面，我们遍历其 DOM 树，找到所有<code>TextNode</code>对象，并将字符串拆分成检索词。这一切都与页面上的单词数成<strong>正比</strong>。</p>
<p>对于每个检索词，我们在<code>HashMap</code>中增加一个计数器，这是一个常数时间的操作。所以创建<code>TermCounter</code>的所需时间与页面上的单词数成正比。</p>
<p>将<code>TermCounter</code>推送到 Redis ，需要删除<code>TermCounter</code>，对于唯一检索词的数量是线性的。那么对于每个检索词，我们必须：</p>
<ul>
<li>向<code>URLSet</code>添加元素，并且</li>
<li>向 Redis<code>TermCounter</code>添加元素。</li>
</ul>
<p>这两个都是常数时间的操作，所以推送<code>TermCounter</code>的总时间对于唯一检索词的数量是线性的。</p>
<p>总之，<code>TermCounter</code>的创建与页面上的单词数成正比。向 Redis 推送<code>TermCounter</code>与唯一检索词的数量成正比。</p>
<p>由于页面上的单词数量通常超过唯一检索词的数量，因此整体复杂度与页面上的单词数成正比。理论上，一个页面可能包含索引中的所有检索词，因此最坏的情况是<code>O(M)</code>，但实际上我们并不期待看到更糟糕的情况。</p>
<p>这个分析提出了一种提高效率的方法：<strong>我们应该避免索引很常见的词语（停止词）</strong>。首先，他们占用了大量的时间和空间，因为它们出现在几乎每一个<code>URLSet</code>和<code>TermCounter</code>中。此外，它们不是很有用，因为它们不能帮助识别相关页面。</p>
<br>

<h6 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4.图的遍历"></a>4.图的遍历</h6><p>如果你在第七章中完成了“到达哲学”练习，你已经有了一个程序，它读取页面，找到第一个链接，使用链接加载下一页，然后重复。这个程序是一种专用的爬虫，但是当人们说“网络爬虫”时，他们通常意味着一个程序：</p>
<p><strong>加载起始页面并对内容进行索引， 查找页面上的所有链接</strong>，并将链接的 URL 添加到集合中 通过收集，加载和索引页面，以及添加新的 URL，来按照它的方式工作。 如果它找到已经被索引的 URL，会跳过它。</p>
<p>你可以将 Web 视为图，其中每个页面都是一个节点，每个链接都是从一个节点到另一个节点的有向边。</p>
<p><strong>从源节点开始，爬虫程序遍历该图，访问每个可达节点一次。</strong></p>
<p>我们用于存储 URL 的集合决定了爬虫程序执行哪种遍历：</p>
<ul>
<li>如果它是先进先出（FIFO）的队列，则爬虫程序将执行广度优先遍历。</li>
<li>如果它是后进先出（LIFO）的栈，则爬虫程序将执行深度优先遍历。</li>
<li>更通常来说，集合中的条目可能具有优先级。例如，我们可能希望对尚未编入索引的页面给予较高的优先级。</li>
</ul>
<br>

<h6 id="5-构建WikiCrawler"><a href="#5-构建WikiCrawler" class="headerlink" title="5.构建WikiCrawler"></a>5.构建WikiCrawler</h6><blockquote>
<p>构建这个类的主要目的为爬取百度百科，并将爬取过的数据持久化，方便日后查询</p>
</blockquote>
<p>需要使用到的类：</p>
<ul>
<li><code>JedisMaker.java</code></li>
<li><code>WikiFetcher.java</code></li>
<li><code>TermCounter.java</code></li>
<li><code>WikiNodeIterable.java</code></li>
</ul>
<p>这里提供<code>WikiCrawler</code>的起始代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiCrawler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String source;</span><br><span class="line">    <span class="keyword">private</span> JedisIndex index;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> WikiFetcher wf = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiCrawler</span><span class="params">(String source, JedisIndex index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        queue.offer(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里边的变量代表为：</p>
<ul>
<li><code>source</code>是我们开始抓取的网址。</li>
<li><code>index</code>是<code>JedisIndex</code>，连接Redis做数据持久化，结果应该放进这里。</li>
<li><code>queue</code>是<code>LinkedList</code>，这里面我们跟踪已发现但尚未编入索引的网址。</li>
<li><code>wf</code>是<code>WikiFetcher</code>，我们用来读取和解析网页。</li>
</ul>
<p>下面是<code>crawl()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crawl</span><span class="params">(<span class="keyword">boolean</span> testing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String url = queue.poll();</span><br><span class="line">     System.out.println(<span class="string">"Crawling..."</span>+ url);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (testing==<span class="keyword">false</span> &amp;&amp; index.isIndexed(url)) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Already indexed."</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Elements para;</span><br><span class="line">     <span class="keyword">if</span> (testing) &#123;</span><br><span class="line">         para = wf.readWikiPedia(url);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         para = wf.fetchWikiPedia(url);</span><br><span class="line">     &#125;</span><br><span class="line">     index.indexPage(url,para);</span><br><span class="line">     queueInternalLinks(para);</span><br><span class="line">     <span class="keyword">return</span> url;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法主要用来获取队列中的Url地址并索引化</p>
</blockquote>
<p>当传递参数 testing为true时:</p>
<ul>
<li>以 FIFO 的顺序从队列中选择并移除一个 URL。</li>
<li>使用<code>WikiFetcher.readWikipedia</code>读取页面的内容</li>
<li>它应该索引页面，而不管它们是否已经被编入索引。</li>
<li>它应该找到页面上的所有内部链接，并按他们出现的顺序将它们添加到队列中。</li>
<li>它应该返回其索引的页面的 URL</li>
</ul>
<p>当传递参数为<code>false</code>时</p>
<ul>
<li>以 FIFO 的顺序从队列中选择并移除一个 URL。</li>
<li>如果 URL 已经被编入索引，它不应该再次索引，并应该返回<code>null</code>。</li>
<li>否则它应该使用<code>WikiFetcher.fetchWikipedia</code>读取页面内容，从 Web 中读取当前内容。</li>
<li>然后，它应该对页面进行索引，将链接添加到队列，并返回其索引的页面的 URL。</li>
</ul>
<p>下面提供一下其中用到的<code>queueInternalLinks()</code></p>
<blockquote>
<p>该方法的主要作用为<strong>解析para,并将内部链接添加到队列</strong></p>
</blockquote>
<p>下面是该方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 解析para,并将内部链接添加到队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 11:38 2019/5/22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueInternalLinks</span><span class="params">(Elements paras)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element para: paras) &#123;</span><br><span class="line">        queueInternalLinks(para);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单个段落解析并添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 11:39 2019/5/22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueInternalLinks</span><span class="params">(Element para)</span> </span>&#123;</span><br><span class="line">    Elements elts = para.select(<span class="string">"a[href]"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Element element: elts) &#123;</span><br><span class="line">        String relURL = element.attr(<span class="string">"href"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to fix</span></span><br><span class="line">        <span class="keyword">if</span> (relURL.startsWith(<span class="string">"/item/"</span>)) &#123;</span><br><span class="line">            String absURL = <span class="string">"https://baike.baidu.com"</span> + relURL;</span><br><span class="line">            queue.offer(absURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要确定链接是否为“内部”链接，我们检查 URL 是否以<code>/item/</code>开头。这可能包括我们不想索引的一些页面，如有关百度百科的元页面。它可能会排除我们想要的一些页面，例如非英语语言页面的链接。但是，这个简单的测试足以起步了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96/">数据结构思维笔记（十五）持久化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E6%8C%81%E4%B9%85%E5%8C%96-redis/">持久化 redis</a></span><div class="content"><a id="more"></a>

<h3 id="第十五章-持久化"><a href="#第十五章-持久化" class="headerlink" title="第十五章 持久化"></a>第十五章 持久化</h3><p>现在我们回顾一下搜索引擎的构建:</p>
<ul>
<li>抓取：我们需要一个程序，可以下载一个网页，解析它，并提取文本和任何其他页面的链接。</li>
<li>索引：我们需要一个索引，可以查找检索项并找到包含它的页面。</li>
<li>检索：我们需要一种方法，从索引中收集结果，并识别与检索项最相关的页面。</li>
</ul>
<p>抓取和索引我们之前都处理过，但是还不够好，我们现在先处理索引，存在Redis里持久化并排序，最后再处理检索功能。</p>
<br>

<h6 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h6><p>索引器的之前版本，将索引存储在两个数据结构中：<code>TermCounter</code>将检索词映射为网页上显示的次数，以及<code>Index</code>将检索词映射为出现的页面集合。</p>
<p>这些数据结构存储在正在运行的 Java 程序的内存中，这意味着当程序停止运行时，索引会丢失。仅在运行程序的内存中存储的数据称为“易失的”，因为程序结束时会消失。</p>
<p>但这个解决方案有几个问题：</p>
<ul>
<li>读取和写入大型数据结构（如 Web 索引）会很慢。</li>
<li>整个数据结构可能不适合单个运行程序的内存。</li>
<li>如果程序意外结束（例如，由于断电），则自程序上次启动以来所做的任何更改都将丢失。</li>
</ul>
<p>现在我们用Redis解决这个问题。</p>
<br>

<h6 id="2-制作基于Redis的索引"><a href="#2-制作基于Redis的索引" class="headerlink" title="2.制作基于Redis的索引"></a>2.制作基于Redis的索引</h6><p>此时，梳理一下思路：</p>
<ul>
<li><code>JedisMaker.java</code>包含连接到 Redis 服务器并运行几个 Jedis 方法的示例代码。</li>
<li><code>JedisIndex.java</code>包含此练习的起始代码。</li>
<li><code>JedisIndexTest.java</code>包含<code>JedisIndex</code>的测试代码。</li>
<li><code>WikiFetcher.java</code>包含我们在以前的练习中看到的代码，用于阅读网页并使用<code>jsoup</code>进行解析。</li>
</ul>
<p>你还将需要这些文件，你在以前的练习中碰到过：</p>
<p><code>Index.java</code>使用 Java 数据结构实现索引。 <code>TermCounter.java</code>表示从检索项到其频率的映射。<code>WikiNodeIterable.java</code>迭代<code>jsoup</code>生成的 DOM 树中的节点。</p>
<p>现在，我们需要做的事是连接Redis服务器:</p>
<p>这里用的方法是，本地安装redis,java客户端推荐用Jedis</p>
<p>下面是具体创建连接及测试的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 创建Redis连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:52 2019/5/10</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = make();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        jedis.set(<span class="string">"mykey"</span>, <span class="string">"myvalue"</span>);</span><br><span class="line">        String value = jedis.get(<span class="string">"mykey"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Got value: "</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set</span></span><br><span class="line">        jedis.sadd(<span class="string">"myset"</span>, <span class="string">"element1"</span>, <span class="string">"element2"</span>, <span class="string">"element3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"element2 is member: "</span> + jedis.sismember(<span class="string">"myset"</span>, <span class="string">"element2"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List</span></span><br><span class="line">        jedis.rpush(<span class="string">"mylist"</span>, <span class="string">"element1"</span>, <span class="string">"element2"</span>, <span class="string">"element3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"element at index 1: "</span> + jedis.lindex(<span class="string">"mylist"</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash</span></span><br><span class="line">        jedis.hset(<span class="string">"myhash"</span>, <span class="string">"word1"</span>, Integer.toString(<span class="number">2</span>));</span><br><span class="line">        jedis.hincrBy(<span class="string">"myhash"</span>, <span class="string">"word2"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"frequency of word1: "</span> + jedis.hget(<span class="string">"myhash"</span>, <span class="string">"word1"</span>));</span><br><span class="line">        System.out.println(<span class="string">"frequency of word2: "</span> + jedis.hget(<span class="string">"myhash"</span>, <span class="string">"word2"</span>));</span><br><span class="line"></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/08/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89SpringBoot%E9%9B%86%E6%88%90FastDFS/">FastDFS分布式文件系统搭建（三）SpringBoot集成FastDFS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/FastDFS/">FastDFS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/SpringBoot%E9%9B%86%E6%88%90FastDFS-Java%E5%AE%9E%E7%8E%B0FastDFS%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-FastDFS/">SpringBoot集成FastDFS Java实现FastDFS文件操作 FastDFS</a></span><div class="content"><a id="more"></a>


<h5 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1 添加依赖"></a>3.3.1 添加依赖</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.27&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<br>

<h5 id="3-3-2-工具类编写"><a href="#3-3-2-工具类编写" class="headerlink" title="3.3.2 工具类编写"></a>3.3.2 工具类编写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juanji.download.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.csource.common.MyException;</span><br><span class="line"><span class="keyword">import</span> org.csource.common.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.csource.fastdfs.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastDFSClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  TrackerClient trackerClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  TrackerServer trackerServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  StorageClient1 storageClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  初始化FastDFS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:35 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastDFSClient</span><span class="params">(String conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conf.contains(<span class="string">"classpath:"</span>)) &#123;</span><br><span class="line">            String path = URLDecoder.decode(getClass().getProtectionDomain().getCodeSource().getLocation().toString(),<span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(path);</span><br><span class="line">            path=path.substring(<span class="number">6</span>);</span><br><span class="line">            conf = conf.replace(<span class="string">"classpath:"</span>,URLDecoder.decode(path,<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ClientGlobal.init(conf);</span><br><span class="line">        trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">        trackerServer = trackerClient.getConnection();</span><br><span class="line">        storageServer = <span class="keyword">null</span>;</span><br><span class="line">        storageClient = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 上传文件方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:35 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extName 文件扩展名，不包含（.）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metas 文件扩展信息</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(String fileName, String extName, NameValuePair[] metas)</span> </span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.upload_file1(fileName, extName, metas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 上传文件,传fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:37 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">uploadFile</span><span class="params">(String fileName, String extName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileName, extName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent, String extName, NameValuePair[] metas)</span> </span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.upload_file1(fileContent, extName, metas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileContent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent, String extName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileContent, extName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 文件下载到磁盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:37 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output 输出流 中包含要输出到磁盘的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1失败,0成功</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">download_file</span><span class="params">(String path,BufferedOutputStream output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = storageClient.download_file1(path);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(b != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    output.write(b);</span><br><span class="line">                    result=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125; <span class="comment">//用户可能取消了下载</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (output != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        output.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 2019.05.08</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 文件的路径 如group1/M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] download_bytes(String path) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b = storageClient.download_file1(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:39 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group 组名 如：group1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> storagePath 不带组名的路径名称 如：M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1失败,0成功</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">delete_file</span><span class="params">(String group ,String storagePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.delete_file(group, storagePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:40 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">delete_file</span><span class="params">(String storagePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.delete_file1(storagePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取远程服务器文件资源信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:40 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName   文件组名 如：group1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteFileName M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileInfo <span class="title">getFile</span><span class="params">(String groupName,String remoteFileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storageClient.get_file_info(groupName, remoteFileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h5 id="3-3-3-单元测试"><a href="#3-3-3-单元测试" class="headerlink" title="3.3.3 单元测试"></a>3.3.3 单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juanji.app.liveserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.juanji.app.util.FastDFSClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FastDFSTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fdfsUpload</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String confUrl=<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"fdfs_client.properties"</span>).getPath();</span><br><span class="line">        FastDFSClient fastDFSClient = <span class="keyword">new</span> FastDFSClient(confUrl);</span><br><span class="line">        String filePath = fastDFSClient.uploadFile(<span class="string">"C:\\upload\\xx\\20190306\\183118.png"</span>);</span><br><span class="line">        System.out.println(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String confUrl=<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"fdfs_client.properties"</span>).getPath();</span><br><span class="line">        FastDFSClient fastDFSClient = <span class="keyword">new</span> FastDFSClient(confUrl);</span><br><span class="line">        <span class="keyword">int</span> i = fastDFSClient.delete_file(<span class="string">"group1/M00/00/00/CmVkLVzSTt-AVds1AAWuezrCZFM986.png"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="3-3-4-上传测试效果展示"><a href="#3-3-4-上传测试效果展示" class="headerlink" title="3.3.4 上传测试效果展示"></a>3.3.4 上传测试效果展示</h6><p><img src="https://img-blog.csdnimg.cn/20190508121002605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Ragty</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="http://beian.miit.gov.cn " target="_blank" rel="noopener" charset="utf-8"> ICP备案号:京ICP备<13502>号 </a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.7.0"></script><script src="/blog/js/fancybox.js?version=1.7.0"></script><script src="/blog/js/sidebar.js?version=1.7.0"></script><script src="/blog/js/copy.js?version=1.7.0"></script><script src="/blog/js/fireworks.js?version=1.7.0"></script><script src="/blog/js/transition.js?version=1.7.0"></script><script src="/blog/js/scroll.js?version=1.7.0"></script><script src="/blog/js/head.js?version=1.7.0"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>