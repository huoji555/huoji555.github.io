<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Ragty"><meta name="copyright" content="Ragty"><title>When the world sleep, I dream. | Ragty の Blog</title><link rel="shortcut icon" href="/blog/melody-favicon.ico"><link rel="stylesheet" href="/blog/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://secure.gravatar.com/avatar/dcc38a5a0d37cb7348d4f72d8f6a2de0"></div><div class="author-info__name text-center">Ragty</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/huoji555" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">75</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">38</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/huoji555" target="_blank" rel="noopener">MY-CSDN</a></div></div></div><nav id="nav" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">Ragty の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/blog">Home</a><a class="site-page" href="/blog/archives">Archives</a><a class="site-page" href="/blog/categories">Categories</a><a class="site-page" href="/blog/tags">Tags</a><a class="site-page" href="/blog/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">Ragty の Blog</div><div id="site-sub-title">When the world sleep, I dream.</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://blog.csdn.net/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/11/02/PBKDF2%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/">PBKDF2算法Java实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90/">密码加盐</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90-PBKDF2-%E5%AF%86%E7%A0%81%E6%94%BB%E5%87%BB/">密码加盐 PBKDF2 密码攻击</a></span><div class="content"><a id="more"></a>

<h2>1.加盐处理</h2>

<blockquote>
<p>       在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”（比如可以在密码中混入一段“随机”的字符串再进行哈希加密，这个被字符串被称作盐值）。</p>
</blockquote>

<h2> </h2>

<h2>2.为什么要加盐</h2>

<blockquote>
<p>      涉及身份验证的系统都需要存储用户的认证信息，常用的用户认证方式主要为用户名和密码的方式，为了安全起见，用户输入的密码需要保存为密文形式，可采用已公开的不可逆的hash加密算法，比如SHA256, SHA512, SHA3等，对于同一密码，同一加密算法会产生相同的hash值，这样，当用户进行身份验证时，也可对用户输入的明文密码应用相同的hash加密算法，得出一个hash值，然后使用该hash值和之前存储好的密文值进行对照，如果两个值相同，则密码认证成功，否则密码认证失败。</p>

<p>     由于密码是由用户设定的，在实际应用中，用户设置的密码复杂度可能不够高，同时不同的用户极有可能会使用相同的密码，那么这些用户对应的密文也会相同，这样，当存储用户密码的数据库泄露后，攻击者会很容易便能找到相同密码的用户，从而也降低了破解密码的难度，因此，在对用户密码进行加密时，需要考虑对密码进行掩饰，即使是相同的密码，也应该要保存为不同的密文，即使用户输入的是弱密码，也需要考虑进行增强，从而增加密码被攻破的难度，而使用带盐的加密hash值便能满足该需求。</p>
</blockquote>

<h2> </h2>

<h2>3.常用密码攻击方式</h2>

<blockquote>
<p> 常用的密码攻击方式有字典攻击、暴力破解、查表法、反向查表法、彩虹表等。</p>

<p>     对字典攻击和暴力破解，攻击者均采用逐密码尝试的方式，目前没有很好的手段来阻止字典攻击和暴力破解攻击，只能是想办法让这两种攻击方式变得相对低效一些，而相同的密码产生不同的hash值便能让攻击者针对每一个hash值都需要从头进行尝试，从而使攻击变得更加低效。</p>

<p>      对查表法、反向查表法和彩虹表攻击方式，攻击者需要提前准备好包含密码和密码hash值的密码表，然后根据该表和用户密码数据库进行批量匹配，从而达到攻破密码的目的；而如果我们在加密时，给每个密码附加了不同的随机值，这样每个密码对应的hash值也会不同，这样攻击者在准备密码表时，就必须要将最基本的密码和用户密码数据库中的盐值进行笛卡尔积后再计算hash值，盐值越多，用户需要准备的表量越大，这样对于攻击而言，就变得有些得不偿失了。</p>
</blockquote>

<h2> </h2>

<h2>4. 让密码更难破解（慢哈希函数）</h2>

<blockquote>
<p>       加盐使攻击者无法采用特定的查询表和彩虹表快速破解大量哈希值，但是却不能阻止他们使用字典攻击或暴力攻击。高端的显卡（GPU）和定制的硬件可以每秒进行数十亿次哈希计算，因此这类攻击依然可以很高效。为了降低攻击者的效率，我们可以使用一种叫做<strong>密钥扩展</strong>的技术。</p>

<p>      这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。</p>

<p>     密钥扩展的实现是依靠一种CPU密集型哈希函数。不要尝试自己发明简单的迭代哈希加密，如果迭代不够多，是可以被高效的硬件快速并行计算出来的，就和普通哈希一样。应该使用标准的算法，比如<a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener">PBKDF2</a>或者<a href="http://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a>。这里使用<a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener">PBKDF2</a>实现</p>

<p>      这类算法使用一个安全因子或迭代次数作为参数，这个值决定了哈希函数会有多慢。对于桌面软件或者手机软件，获取参数最好的办法就是执行一个简短的性能基准测试，找到使哈希函数大约耗费0.5秒的值。这样，你的程序就可以尽可能保证安全，而又不影响到用户体验。</p>
</blockquote>

<h2> </h2>

<h2>5.实现代码 </h2>

<pre class="has">
<code>package com.hwj.util;

import org.springframework.stereotype.Component;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

@Component
public class PBKDF2Util {

    public static final String PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA1";


    public static final int SALT_BYTE_SIZE = 32 / 2;         //盐的长度
    public static final int HASH_BIT_SIZE = 128 * 4;         //生成密文的长度
    public static final int PBKDF2_ITERATIONS = 1000;        //迭代次数



    /**
     * @auther: Ragty
     * @describe: 对输入的密码进行验证
     * @param: [attemptedPassword(待验证密码), encryptedPassword(密文), salt(盐值)]
     * @return: boolean
     * @date: 2018/11/2
     */
    public boolean authenticate(String attemptedPassword, String encryptedPassword, String salt)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        // 用相同的盐值对用户输入的密码进行加密
        String encryptedAttemptedPassword = getEncryptedPassword(attemptedPassword, salt);
        // 把加密后的密文和原密文进行比较，相同则验证成功，否则失败
        return encryptedAttemptedPassword.equals(encryptedPassword);
    }



    /**
     * @auther: Ragty
     * @describe: 生成密文
     * @param: [password(明文密码), salt(盐值)]
     * @return: java.lang.String
     * @date: 2018/11/2
     */
    public String getEncryptedPassword(String password, String salt) throws NoSuchAlgorithmException,
            InvalidKeySpecException {

        KeySpec spec = new PBEKeySpec(password.toCharArray(), fromHex(salt), PBKDF2_ITERATIONS, HASH_BIT_SIZE);
        SecretKeyFactory f = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
        return toHex(f.generateSecret(spec).getEncoded());
    }




    /**
     * @auther: Ragty
     * @describe: 通过加密的强随机数生成盐(最后转换为16进制)
     * @param: []
     * @return: java.lang.String
     * @date: 2018/11/2
     */
    public String generateSalt() throws NoSuchAlgorithmException {
        SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
        byte[] salt = new byte[SALT_BYTE_SIZE];
        random.nextBytes(salt);

        return toHex(salt);
    }




    /**
     * @auther: Ragty
     * @describe: 十六进制字符串转二进制字符串
     * @param: [hex]
     * @return: byte[]
     * @date: 2018/11/2
     */
    private static byte[] fromHex(String hex) {
        byte[] binary = new byte[hex.length() / 2];
        for (int i = 0; i &lt; binary.length; i++) {
            binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);
        }
        return binary;
    }





    /**
     * @auther: Ragty
     * @describe: 二进制字符串转十六进制字符串
     * @param: [array]
     * @return: java.lang.String
     * @date: 2018/11/2
     */
    private static String toHex(byte[] array) {
        BigInteger bi = new BigInteger(1, array);
        String hex = bi.toString(16);
        int paddingLength = (array.length * 2) - hex.length();
        if (paddingLength &gt; 0)
            return String.format("%0" + paddingLength + "d", 0) + hex;
        else
            return hex;
    }
}</code></pre>

<h2> </h2>

<h2>6.单元测试</h2>

<pre class="has">
<code>package com.hwj;

import com.hwj.util.MD5Util;
import com.hwj.util.PBKDF2Util;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import sun.security.util.Password;

@RunWith(SpringRunner.class)
@SpringBootTest
public class SaltTest {

    @Autowired
    private PBKDF2Util pbkdf2Util;
    @Autowired
    private MD5Util md5Util;


    @Test
    public void mailSendTest() throws Exception{

        String password = "123456";

        String salt = pbkdf2Util.generateSalt();
        String pbkdf2 = pbkdf2Util.getEncryptedPassword(password,salt);
        String md5 = md5Util.digest(password);

        System.out.println("原始密码:"+password);
        System.out.println("MD5加密后的密码:"+md5);
        System.out.println("盐值:"+salt);
        System.out.println("PBKDF2加盐后的密码:"+pbkdf2);
        System.out.println("Test success");

    }


}
</code></pre>

<p> </p>

<p>7.测试结果</p>

<blockquote>
<p>原始密码:123456<br />
MD5加密后的密码:e10adc3949ba59abbe56e057f20f883e<br />
盐值:fb8681ed06d293f602596206089cc961<br />
PBKDF2加盐后的密码:ac9bb962cc0e9b8a8c9887e0df41982b98001456afa191123fcd67ece84d3f715ecc5be82a704ec001e8bec1b53fe01f8adacffbfa3bc425f10b962c3690a904<br />
Test success </p>
</blockquote>

<p> </p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/08/22/%E7%99%BE%E5%BA%A6OCR%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC%E6%96%87%E5%AD%97%EF%BC%8C%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0(%E5%87%86%E7%A1%AE%E7%8E%87%E5%BE%88%E9%AB%98)/">百度OCR识别表格文字，并自动下载到本地(准确率很高)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/jpg-%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB-OCR/">jpg 图片文字识别 OCR</a></span><div class="content"><a id="more"></a>

<h2>一、输入文件及申请的Token</h2>

<hr /><pre class="has">
<code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

<p>import org.json.JSONObject;</p>
<p>import com.alibaba.fastjson.JSON;<br>import com.baidu.ai.aip.utils.Base64Util;<br>import com.baidu.ai.aip.utils.FileUtil;<br>import com.baidu.ai.aip.utils.HttpUtil;</p>
<p>public class BaiduExcel {</p>
<pre><code>public static void main(String[] args) throws IOException {

    String accessToken = getAuth(&quot;aI62Wj4bu6ZOF46R7taLstZ8&quot;, &quot;OUBy6goyji2IU4yWjlvlbFxXF6dKGgcP&quot;);
    String request_id = requestPic(&quot;D:/007.jpg&quot;,accessToken);

    //定时器
    Timer timer=new Timer();   
    timer.schedule(new TimerTask(){   
    public void run(){   
        String url = getUrl(request_id,accessToken);
        download download = new download();
        try {
            download.downLoadFromUrl(url, &quot;识别文件.xls&quot;, &quot;D://&quot;, accessToken);
            System.out.println(&quot;识别成功&quot;);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    this.cancel();}},50000);            //延迟10s进行，否则显示进行中（可根据文件大小调整时间）

}



/**
 * @author Ragty
 * @param  获取请求id
 * @serialData 2018.8.22
 * @param filePath
 * @return
 */
public static String requestPic(String filePath,String accessToken) {
    String otherHost = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/request&quot;;

    try {
        byte[] imgData = FileUtil.readFileByBytes(filePath);
        String imgStr = Base64Util.encode(imgData);
        String params = URLEncoder.encode(&quot;image&quot;, &quot;UTF-8&quot;) + &quot;=&quot; + URLEncoder.encode(imgStr, &quot;UTF-8&quot;);
        /**
         * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。
         */
        String result = HttpUtil.post(otherHost, accessToken, params);
        JsonAnalyze jsonAnalyze = new JsonAnalyze();

        Map&amp;lt;String, Object&amp;gt; map = jsonAnalyze.json2Map(result);
        Object a = map.get(&quot;result&quot;);
        String zz = jsonAnalyze.object2Json(a);
        String zz1 = zz.substring(1, zz.length()-1);
        jsonAnalyze.json2Map(zz1);
        String result1 = jsonAnalyze.json2Map(zz1).get(&quot;request_id&quot;).toString();
        return result1;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}



/**
 * @author Ragty
 * @param  获取异步请求到的excel地址
 * @param  2018.8.22
 * @param request_id
 * @return
 */
public static String getUrl(String request_id,String accessToken) {
        String otherHost = &quot;https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/get_request_result&quot;;

        try {
           String params = URLEncoder.encode(&quot;request_id&quot;, &quot;UTF-8&quot;) + &quot;=&quot; + URLEncoder.encode(request_id, &quot;UTF-8&quot;);
            /**
             * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。
             */
            String result = HttpUtil.post(otherHost, accessToken, params);

            JsonAnalyze jsonAnalyze = new JsonAnalyze();
            Map&amp;lt;String, Object&amp;gt; map = jsonAnalyze.json2Map(result);
            Object a = map.get(&quot;result&quot;);
            String zz = jsonAnalyze.object2Json(a);
            Map&amp;lt;String, Object&amp;gt; map1 = jsonAnalyze.json2Map(zz);

            String url = map1.get(&quot;result_data&quot;).toString();
            return url;
        } catch (Exception e) {
            e.printStackTrace();
        }

    return null;
}



/**
 * @author Ragty
 * @param  获取当前的token
 * @serialData 2018.8.22
 * @param ak
 * @param sk
 * @return
 */
public static String getAuth(String ak, String sk) {
    // 获取token地址
    String authHost = &quot;https://aip.baidubce.com/oauth/2.0/token?&quot;;
    String getAccessTokenUrl = authHost
            // 1. grant_type为固定参数
            + &quot;grant_type=client_credentials&quot;
            // 2. 官网获取的 API Key
            + &quot;&amp;amp;client_id=&quot; + ak
            // 3. 官网获取的 Secret Key
            + &quot;&amp;amp;client_secret=&quot; + sk;
    try {
        URL realUrl = new URL(getAccessTokenUrl);
        // 打开和URL之间的连接
        HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();
        connection.setRequestMethod(&quot;GET&quot;);
        connection.connect();
        // 获取所有响应头字段
        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = connection.getHeaderFields();
        // 遍历所有的响应头字段
        for (String key : map.keySet()) {
            System.err.println(key + &quot;---&amp;gt;&quot; + map.get(key));
        }
        // 定义 BufferedReader输入流来读取URL的响应
        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String result = &quot;&quot;;
        String line;
        while ((line = in.readLine()) != null) {
            result += line;
        }
        /**
         * 返回结果示例
         */
        System.err.println(&quot;result:&quot; + result);
        JSONObject jsonObject = new JSONObject(result);
        String access_token = jsonObject.getString(&quot;access_token&quot;);
        return access_token;
    } catch (Exception e) {
        System.err.printf(&quot;获取token失败！&quot;);
        e.printStackTrace(System.err);
    }
    return null;
}</code></pre><p>}<br></code></pre></p>
<p> </p>

<h2>二、识别效果</h2>

<h3>识别前：</h3>

<hr /><p><img alt="" class="has" height="506" src="https://img-blog.csdn.net/20180822174836937?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="380" /></p>

<h3>识别后：</h3>

<hr /><p><img alt="" class="has" height="514" src="https://img-blog.csdn.net/20180822175054270?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="832" /></p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/08/15/java%E4%B8%AD%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84excel%E6%96%87%E4%BB%B6%EF%BC%88xls,xlsx%EF%BC%89/">java中解析上传的excel文件（xls,xlsx）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/excel%E8%A7%A3%E6%9E%90/">excel解析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/excel%E8%A7%A3%E6%9E%90-excel%E8%A7%A3%E6%9E%90-xls-xlsx-%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/">excel解析 excel解析(xls\xlsx) 解析工具</a></span><div class="content"><a id="more"></a>

<h2><strong>一、在maven库中导入相关依赖</strong></h2>

<hr /><p>其中poi是解析xls格式的，poi-ooxml是解析xlsx格式的</p>

<pre class="has">
<code class="language-java">&lt;!-- POI,excel解析相关 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
    &lt;artifactId&gt;poi&lt;/artifactId&gt;
    &lt;version&gt;3.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
    &lt;version&gt;3.17&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;
    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;classifier&gt;jdk15&lt;/classifier&gt;
&lt;/dependency&gt;</code></pre>

<h2> </h2>

<h2><strong>二、解析代码</strong></h2>

<hr /><pre class="has">
<code class="language-java">import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;


<p>import org.apache.poi.hssf.usermodel.HSSFDateUtil;<br>import org.apache.poi.hssf.usermodel.HSSFWorkbook;<br>import org.apache.poi.openxml4j.exceptions.InvalidFormatException;<br>import org.apache.poi.poifs.filesystem.POIFSFileSystem;<br>import org.apache.poi.ss.usermodel.Cell;<br>import org.apache.poi.ss.usermodel.Row;<br>import org.apache.poi.ss.usermodel.Sheet;<br>import org.apache.poi.ss.usermodel.Workbook;<br>import org.apache.poi.xssf.usermodel.XSSFWorkbook;</p>
<p>import net.sf.json.JSONArray;<br>import net.sf.json.JSONObject;<br>import org.springframework.stereotype.Component;<br>import sun.applet.Main;</p>
<p>@Component<br>public class ExcelResolve {</p>
<pre><code>public final String XLSX = &quot;.xlsx&quot;;
public final String XLS=&quot;.xls&quot;;

/**
 * 获取Excel文件（.xls和.xlsx都支持）
 * @param file
 * @return  解析excle后的Json数据
 * @throws IOException
 * @throws FileNotFoundException
 * @throws InvalidFormatException
 */
public JSONArray readExcel(File file) throws Exception{
    int res = checkFile(file);

    if (res == 0) {
        System.out.println(&quot;File not found&quot;);
    }else if (res == 1) {
        return readXLSX(file);
    }else if (res == 2) {
        return readXLS(file);
    }
    JSONArray array = new JSONArray();
    return array;
}

/**
 * 判断File文件的类型
 * @param file 传入的文件
 * @return 0-文件为空，1-XLSX文件，2-XLS文件，3-其他文件
 */
public int checkFile(File file){
    if (file==null) {
        return 0;
    }
    String flieName = file.getName();
    if (flieName.endsWith(XLSX)) {
        return 1;
    }
    if (flieName.endsWith(XLS)) {
        return 2;
    }
    return 3;
}

/**
 * 读取XLSX文件
 * @param file
 * @return
 * @throws IOException
 * @throws InvalidFormatException
 */
public JSONArray readXLSX(File file) throws InvalidFormatException, IOException{
    Workbook book = new XSSFWorkbook(file);
    Sheet sheet = book.getSheetAt(0);
    return read(sheet, book);
}

/**
 * 读取XLS文件
 * @param file
 * @return
 * @throws IOException
 * @throws FileNotFoundException
 */
public JSONArray readXLS(File file) throws FileNotFoundException, IOException{
    POIFSFileSystem poifsFileSystem = new POIFSFileSystem(new FileInputStream(file));
    Workbook book = new HSSFWorkbook(poifsFileSystem);
    Sheet sheet = book.getSheetAt(0);
    return read(sheet, book);
}

/**
 * 解析数据
 * @param sheet 表格sheet对象
 * @param book 用于流关闭
 * @return
 * @throws IOException
 */
public JSONArray read(Sheet sheet,Workbook book) throws IOException{
    int rowStart = sheet.getFirstRowNum();    // 首行下标
    int rowEnd = sheet.getLastRowNum();    // 尾行下标
    // 如果首行与尾行相同，表明只有一行，直接返回空数组
    if (rowStart == rowEnd) {
        book.close();
        return new JSONArray();
    }
    // 获取第一行JSON对象键
    Row firstRow = sheet.getRow(rowStart);
    int cellStart = firstRow.getFirstCellNum();
    int cellEnd = firstRow.getLastCellNum();
    Map&amp;lt;Integer, String&amp;gt; keyMap = new HashMap&amp;lt;Integer, String&amp;gt;();
    for (int j = cellStart; j &amp;lt; cellEnd; j++) {
        keyMap.put(j,getValue(firstRow.getCell(j), rowStart, j, book, true));
    }
    // 获取每行JSON对象的值
    JSONArray array = new JSONArray();
    for(int i = rowStart+1; i &amp;lt;= rowEnd ; i++) {
        Row eachRow = sheet.getRow(i);
        JSONObject obj = new JSONObject();
        StringBuffer sb = new StringBuffer();
        for (int k = cellStart; k &amp;lt; cellEnd; k++) {
            if (eachRow != null) {
                String val = getValue(eachRow.getCell(k), i, k, book, false);
                sb.append(val);        // 所有数据添加到里面，用于判断该行是否为空
                obj.put(keyMap.get(k),val);
            }
        }
        if (sb.toString().length() &amp;gt; 0) {
            array.add(obj);
        }
    }
    book.close();
    return array;
}

/**
 * 获取每个单元格的数据
 * @param cell 单元格对象
 * @param rowNum 第几行
 * @param index 该行第几个
 * @param book 主要用于关闭流
 * @param isKey 是否为键：true-是，false-不是。 如果解析Json键，值为空时报错；如果不是Json键，值为空不报错
 * @return
 * @throws IOException
 */
public String getValue(Cell cell,int rowNum,int index,Workbook book,boolean isKey) throws IOException{

    // 空白或空
    if (cell == null || cell.getCellType()==Cell.CELL_TYPE_BLANK ) {
        if (isKey) {
            book.close();
            throw new NullPointerException(String.format(&quot;the key on row %s index %s is null &quot;, ++rowNum,++index));
        }else{
            return &quot;&quot;;
        }
    }

    // 0. 数字 类型
    if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) {
        if (HSSFDateUtil.isCellDateFormatted(cell)) {
            Date date = cell.getDateCellValue();
            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            return df.format(date);
        }
        String val = cell.getNumericCellValue()+&quot;&quot;;
        val = val.toUpperCase();
        if (val.contains(&quot;E&quot;)) {
            val = val.split(&quot;E&quot;)[0].replace(&quot;.&quot;, &quot;&quot;);
        }
        return val;
    }

    // 1. String类型
    if (cell.getCellType() == Cell.CELL_TYPE_STRING) {
        String val = cell.getStringCellValue();
        if (val == null || val.trim().length()==0) {
            if (book != null) {
                book.close();
            }
            return &quot;&quot;;
        }
        return val.trim();
    }

    // 2. 公式 CELL_TYPE_FORMULA
    if (cell.getCellType() == Cell.CELL_TYPE_FORMULA) {
        return cell.getStringCellValue();
    }

    // 4. 布尔值 CELL_TYPE_BOOLEAN
    if (cell.getCellType() == Cell.CELL_TYPE_BOOLEAN) {
        return cell.getBooleanCellValue()+&quot;&quot;;
    }

    // 5.    错误 CELL_TYPE_ERROR
    return &quot;&quot;;
}</code></pre><p>}<br></code></pre></p>
<p> </p>

<h2><strong>三、单元测试</strong></h2>

<hr /><p>  这里点出调用封装好的组件时，要用try catch将异常抛出</p>

<pre class="has">
<code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class ExcelTest extends TestCase {

    @Autowired
    private ExcelResolve excelResolve;

    @Test
    public void readTest() throws Exception{
        File f1 = new File("D:/work/1.xlsx");

        try {
            System.out.println(excelResolve.readExcel(f1));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


}</code></pre>

<p> </p>

<h2><strong>四、测试结果</strong></h2>

<p><img alt="" class="has" src="https://img-blog.csdn.net/20180815092008819?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" /></p>

<p> </p></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/25/%E4%BD%BF%E7%94%A8Adaline%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E5%8D%B0%E5%88%B7%E4%BD%93%E6%95%B0%E5%AD%97/">使用Adaline神经网络识别印刷体数字</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/Nerouph/">Nerouph</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-Neuroph-Adaline/">人工智能 Neuroph Adaline</a></span><div class="content"><a id="more"></a>

<p><span style="font-size:24px;color:#666666;">1.创建Adaline神经网络</span></p><pre class="html">       /**
     * @author Ragty
     * @param  设置Adaline神经网络
     * @serialData 2018.4.24
     * @param inputNeuralCount
     * @param outputNeuralNetwork
     */
    public void creatNetwork(int inputNeuralCount, int outputNeuralCount){

<pre><code>    //设置神经网络类型为Adaline
    this.setNetworkType(NeuralNetworkType.ADALINE);

    //建立输入神经元，表刺激
    NeuronProperties inputNeural = new NeuronProperties();
    inputNeural.setProperty(&quot;transferFunction&quot;, TransferFunctionType.LINEAR);

    //建立神经网络的输入层
    Layer inputLayer = LayerFactory.createLayer(inputNeuralCount, inputNeural);
    inputLayer.addNeuron(new BiasNeuron());
    this.addLayer(inputLayer);

    //建立输出神经元
    NeuronProperties outputNeural = new NeuronProperties();
    outputNeural.setProperty(&quot;transferFunction&quot;, TransferFunctionType.LINEAR);

    //创建输出层
    Layer outputLayer = LayerFactory.createLayer(outputNeuralCount, outputNeural);
    this.addLayer(outputLayer);

    //输入输出层全连接
    ConnectionFactory.fullConnect(inputLayer, outputLayer);
    NeuralNetworkFactory.setDefaultIO(this);

    //设置LMS算法
    //学习步长系数为0.05（由最速下降法引入，表示学习的速度）一般是在0.1或0.01这样的数量级
            //步长太大，不精准，步长太小，学习速度慢，易陷入局部最优
    //设置最大可接受误差为0.5  (LMS中不同于感知机，误差是连续的)
    //(w_new = w_old + 2aep) (b_new = b_old + 2ae)  &amp;gt;&amp;gt;LMS公式（步长系数a，省略常数2）
    LMS lms = new LMS();
    lms.setLearningRate(0.05);
    lms.setMaxError(0.5);
    this.setLearningRule(lms);

}</code></pre><p>2.实现Adaline的核心算法LMS<br>public LMS(){</p>
<pre><code>}</code></pre><p>   /**<br>    *@author Ragty<br>    *@param  LMS核心算法<br>    *@serialData 2018.4.24<br>    *@核心公式  deltaWeight = learningRate * neuronError * input(learingRate是学习系数)<br>    */<br>    @Override<br>    protected void updateNetworkWeights(double[] outputError) {<br>        // TODO Auto-generated method stub<br>        int i = 0;</p>
<pre><code>    //遍历每个神经元，修改权值
    for(Neuron neuron : neuralNetwork.getOutputNeurons()){
        neuron.setError(outputError[i]);
        this.updateNetworkWeights(neuron);
        i++;
    }

}


/**
 * @author Ragty
 * @param  迭代更新每个输入神经元的权值
 * @serialData 2018.4.24
 * @param neuron
 */
protected void updateNetworkWeights(Neuron neuron) {
    // TODO Auto-generated method stub
    //取得神经元误差
    double neuronError = neuron.getError();

    //根据所有神经元输入迭代学习
    for(Connection connection : neuron.getInputConnections()){
        //神经元的一个输入
        double input = connection.getInput();
        double weightChange = this.learningRate * neuronError * input;

        //更新权值
        Weight weight = connection.getWeight();
        weight.weightChange = weightChange;
        weight.value += weightChange;
    }

}</code></pre><p>3.实现Adaline感知机识别印刷体数字<br>public class AdalineDemo implements LearningEventListener{</p>
<pre><code>//设置输入神经元的个数为5*7=35个
public final static int char_width = 5;
public final static int char_height = 7;

public static String[][] DIGITS = { 
      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  },

      { &quot;  O  &quot;,
        &quot; OO  &quot;,
        &quot;O O  &quot;,
        &quot;  O  &quot;,
        &quot;  O  &quot;,
        &quot;  O  &quot;,
        &quot;  O  &quot;  },

      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;    O&quot;,
        &quot;   O &quot;,
        &quot;  O  &quot;,
        &quot; O   &quot;,
        &quot;OOOOO&quot;  },

      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;    O&quot;,
        &quot; OOO &quot;,
        &quot;    O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  },

      { &quot;   O &quot;,
        &quot;  OO &quot;,
        &quot; O O &quot;,
        &quot;O  O &quot;,
        &quot;OOOOO&quot;,
        &quot;   O &quot;,
        &quot;   O &quot;  },

      { &quot;OOOOO&quot;,
        &quot;O    &quot;,
        &quot;O    &quot;,
        &quot;OOOO &quot;,
        &quot;    O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  },

      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;O    &quot;,
        &quot;OOOO &quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  },

      { &quot;OOOOO&quot;,
        &quot;    O&quot;,
        &quot;    O&quot;,
        &quot;   O &quot;,
        &quot;  O  &quot;,
        &quot; O   &quot;,
        &quot;O    &quot;  },

      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  },

      { &quot; OOO &quot;,
        &quot;O   O&quot;,
        &quot;O   O&quot;,
        &quot; OOOO&quot;,
        &quot;    O&quot;,
        &quot;O   O&quot;,
        &quot; OOO &quot;  } };


public static void main(String[] args) {

    //设置Adaline神经网络输入节点为35个，输出节点为10个
    Adaline ada = new Adaline(char_width * char_height, DIGITS.length);

    //设置训练集为35个输入节点，10个输出节点
    DataSet ds = new DataSet(char_width * char_height, DIGITS.length);

    //设置训练集(前面是输入值，后面是期望值)
    for(int i = 0; i &amp;lt; DIGITS.length; i++ ){
       ds.addRow(creatTrainRow(DIGITS[i], i));
    }
    //监督训练过程
    ada.getLearningRule().addListener(new AdalineDemo());
    //训练该神经网络
    ada.learn(ds);

    //测试训练好的数据
    for(int i = 0; i &amp;lt; DIGITS.length; i++){
        ada.setInput(image2data(DIGITS[i]));
        ada.calculate();
        print(DIGITS[i]);
        System.out.print(maxIndex(ada.getOutput()));
        System.out.println();
    }

}


/**
 * @author Ragty
 * @param  设置这几个数字的训练集
 * @serialData 2018.4.24
 * @param image
 * @param idealValue
 * @return
 */
public static DataSetRow creatTrainRow(String[] image, int idealValue){
    double[] output = new double[DIGITS.length];

    //将训练集初始化
    for(int i = 0; i &amp;lt;DIGITS.length; i++)
        output[i] = -1;

    //输入数据
    double[] input = image2data(image);

    //用这样的方式来表示一个具体的数字（10个数字分为十个维度，表示哪个数字把哪个数字的维度设置为1）
    output[idealValue] = 1;
    //设置训练集以及期望值
    DataSetRow dsr = new DataSetRow(input, output);
    return dsr;
}


/**
 * @author Ragty
 * @param  将输入的二维数组转化为网络能够识别的格式（有字的地方全部转化为1，无字的地方转化为-1）
 * @serialData 2018.4.24
 * @param image
 * @return
 */
public static double[] image2data(String[] image){
    double[] input = new double[char_width * char_height];

    for(int row = 0; row &amp;lt; char_height; row++){
        for(int col = 0; col &amp;lt; char_width; col++){
            int index = (row*char_width)+col;
            char ch = image[row].charAt(col);
            input[index] = ch == &apos;O&apos;? 1 :-1;
        }
    }

    return input;
}


/**
 * @author Ragty
 * @param  识别输出数据为数字（采用竞争规则，在所有维度里，将最大的那个维度视为1，其余均为0）
 * @param  即找到数组中最大值的索引下标(第一次从左边的条件进入)
 * @serialData 2018.4.24
 * @param data
 * @return
 */
public static int maxIndex(double[] data){
    int result = -1;
    for(int i = 0; i &amp;lt; data.length; i++){
        if(result == -1 || data[i] &amp;gt; data[result]){
            result = i;
        }
    }
    return result;
}


/**
 * @author Ragty
 * @param  打印输出的打印字体
 * @serialData 2018.4.24
 * @param dIGITS2
 */
public static void print(String[] dIGITS2){

    for(int i = 0; i &amp;lt;dIGITS2.length; i++){
        if(i == dIGITS2.length-1){
            System.out.print(dIGITS2[i]+&quot;===&amp;gt;&quot;);
        } else {
            System.out.println(dIGITS2[i]);
        }
    }

}

/**
 * @param 监督训练
 */
@Override
public void handleLearningEvent(LearningEvent event) {
    // TODO Auto-generated method stub
    IterativeLearning bp = (IterativeLearning)event.getSource();
    System.out.println(&quot;iterate:&quot;+bp.getCurrentIteration()); 
    System.out.println(Arrays.toString(bp.getNeuralNetwork().getWeights()));
}</code></pre><p>}</pre><br /><br /><span style="font-size:24px;">4.识别结果</span><p><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="https://img-blog.csdn.net/20180425103537962" alt="" /><br /></p></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/23/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8A%A0%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%B1%A1%E9%99%90/">感知机加算法自动识别象限</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/Nerouph-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">Nerouph 神经网络，机器学习</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-Neuroph-%E6%84%9F%E7%9F%A5%E6%9C%BA/">人工智能 Neuroph 感知机</a></span><div class="content"><a id="more"></a>

<p><span style="font-size:24px;">1.创建感知机</span></p><p><span style="font-size:24px;"><br /></span></p><p><span style="font-size:24px;">2.创建迭代学习算法</span></p><p><span style="font-size:24px;"><br /></span></p><p><span style="font-size:24px;">3.通过训练数据，不断学习，并检验学习的正确率</span></p><pre class="java">public class FeelPosLearning implements LearningEventListener{

<pre><code>public static void main(String[] args) {
    new FeelPosLearning().run();
}

/**
 * @author Ragty
 * @param  根据学习数据自动学习，识别象限
 */
public void run(){
    //新建一个两个输入两个输出的训练集
    DataSet dataSet = new DataSet(2,2);

    //一万个测试数据，让训练效果更显著
    for (int i = 0; i &amp;lt; 10000; i++){
        //第一象限期望
        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), 1 * nextDouble() },new double[] { 1, 1 }));
        //第二象限期望
        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), 1 * nextDouble() },new double[] { 0, 1 }));
        //第三象限期望
        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), -1 * nextDouble() },new double[] { 0, 0 }));
        //第四象限期望
        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), -1 * nextDouble() },new double[] { 1, 0 }));
    }

    //创建两个输入，两个输出的感知机
    simplePerceptron posPerceptron = new simplePerceptron(2,2);

    //设置最小误差为0.001(增加监听器)
    perceptronLearningRule learningRule = (perceptronLearningRule) posPerceptron.getLearningRule();
    learningRule.setMaxError(0.001);
    learningRule.addListener(this);

    //进行学习
    System.out.println(&quot;进行学习&quot;);
    posPerceptron.learn(dataSet);

    //检测学习
    System.out.println(&quot;检测学习&quot;);
    testData(posPerceptron);

}


/**
 * @author Ragty
 * @deprecated 得到一个0到1之间的随机数
 * @serialData 2018.4.23
 */
static Random r = new Random();

public static double nextDouble() {
    double re = 0;
    while ((re = r.nextDouble()) != 0) {
        return re;
    }
    return r.nextDouble();
}


/**
 * @author Ragty
 * @param  测试训练的效果，得出正确率
 * @param neuralNetwork
 */
public static void testData(NeuralNetwork neuralNetwork){

    DataSet dataSet = new DataSet(2,2);

    for (int i = 0; i &amp;lt; 1000; i++) {
        // 第一象限
        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), 1 * nextDouble() }, new double[] { 1, 1 }));
        // 第二象限
        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), 1 * nextDouble() }, new double[] { 0, 1 }));
        // 第三象限
        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), -1 * nextDouble() }, new double[] { 0, 0 }));
        // 第四象限
        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), -1 * nextDouble() }, new double[] { 1, 0 }));
    }

    //正确总数
    int correctCount = 0;
    int incorrectCount = 0;

    //遍历整个测试数组
    for(DataSetRow dataSetRow : dataSet.getRows()){
        //获得一个输入
        neuralNetwork.setInput(dataSetRow.getInput());
        neuralNetwork.calculate();
        double[] output = neuralNetwork.getOutput();

        //实际输出跟期望输出相比较
        if(Arrays.equals(output, dataSetRow.getDesiredOutput())){
            correctCount++;
        } else{
            incorrectCount++;
        }

    }
    System.out.println(&quot;正确率：&quot;+correctCount * 1.0 / (correctCount + incorrectCount));

}


/**
 * @author Ragty
 * @param  监督学习
 * @serialData 2018.4.23
 */
@Override
public void handleLearningEvent(LearningEvent event) {
    // TODO Auto-generated method stub
    IterativeLearning bp = (IterativeLearning) event.getSource();
    System.out.println(&quot;iterate:&quot; + bp.getCurrentIteration());
    System.out.print(&quot;TotalNetworkError:&quot;);
    System.out.println(((perceptronLearningRule) bp.getNeuralNetwork().getLearningRule()).getTotalNetworkError());

}&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;span style=&quot;font-size:24px;&quot;&gt;4.输出结果(正确率)&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;font-size:24px;&quot;&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180423165030350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/23/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/">Neuroph感知机自我学习实现记忆逻辑与</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/Nerouph-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%84%9F%E7%9F%A5%E6%9C%BA/">Nerouph 神经网络，机器学习，感知机</a></span><div class="content"><a id="more"></a>


<p><span style="font-size:24px; color:#333333">1.创建增加学习算法的感知机</span></p>
<p><pre name="code" class="java">    /**
     * @author Ragty
     * @param  增加学习算法的感知机(记忆逻辑与)
     * @serialData 2018.4.22
     * @param inputNeuralCount
     */
    public void creatPerceptron(int inputNeuralCount){

<pre><code>    //设置类型为感知机
    this.setNetworkType(NeuralNetworkType.PERCEPTRON);

    //建立输入神经元，表示输入刺激
    NeuronProperties inputNeuronProperties = new NeuronProperties();
    inputNeuronProperties.setProperty(&amp;quot;neuronType&amp;quot;,InputNeuron.class);

    //建立输入层
    Layer inputLayer = LayerFactory.createLayer(inputNeuralCount, inputNeuronProperties);
    this.addLayer(inputLayer);
    inputLayer.addNeuron(new BiasNeuron());

    //建立输出神经元（传输函数为step）
    NeuronProperties outputNeuronProperties = new NeuronProperties();
    outputNeuronProperties.setProperty(&amp;quot;transferFunction&amp;quot;, TransferFunctionType.STEP);

    //建立输出层
    Layer outputLayer = LayerFactory.createLayer(1, outputNeuronProperties);
    this.addLayer(outputLayer);

    //输入层输出层全连接
    ConnectionFactory.fullConnect(inputLayer, outputLayer);
    NeuralNetworkFactory.setDefaultIO(this);

    //设置感知机学习算法
    this.setLearningRule(new perceptronLearningRule());
}&lt;/pre&gt;&lt;br&gt;</code></pre><br>
</p>
<p><span style="font-size:24px">2.创建学习算法</span></p>
<p><pre name="code" class="java">public class perceptronLearningRule extends SupervisedLearning implements Serializable{

<pre><code>private static final long serialVersionUID = 1L;

public perceptronLearningRule() {

}

/**
 * @author Ragty
 * @param  迭代计算权值
 * @serialData 2018.4.22
 */
@Override
protected void updateNetworkWeights(double[] outputError) {
    int i = 0;
    for (Neuron neuron : neuralNetwork.getOutputNeurons()) {
        neuron.setError(outputError[i]); 
        double neuronError = neuron.getError();
        // 根据所有的神经元输入 迭代学习
        for (Connection connection : neuron.getInputConnections()) {
            // 神经元的一个输入
            double input = connection.getInput();
            // 计算权值的变更
            double weightChange =  neuronError * input;
            // 更新权值
            Weight weight = connection.getWeight();
            weight.weightChange = weightChange;                
            weight.value += weightChange;
        }

        i++;
    }
}</code></pre><p>}</pre></p></p>
<p><br>
</p>
<span style="font-size:24px">3.训练数据并测试</span>
<p><pre name="code" class="java">public class AndPerceptron implements LearningEventListener{

<pre><code>public static void main(String[] args) {
    new AndPerceptron().run();
}

public void run(){

   //给出学习的训练数据(用于训练神经网络)
   //数据集有两个输入，一个输出
   //dataSetRow的构造函数接受两个参数，第一个为输入向量，第二个为期望值
   DataSet trainningSet = new DataSet(2,1);    
   trainningSet.addRow(new DataSetRow(new double[]{0,0},new double[]{0}));
   trainningSet.addRow(new DataSetRow(new double[]{0,1},new double[]{0}));
   trainningSet.addRow(new DataSetRow(new double[]{1,0},new double[]{0}));
   trainningSet.addRow(new DataSetRow(new double[]{1,1},new double[]{1}));

   //创建一个只有两个输入节点的感知机
   simplePerceptron andPerceptron = new simplePerceptron(2);

   //给学习过程增加事件监听器（监督训练）
   perceptronLearningRule learningRule = (perceptronLearningRule) andPerceptron.getLearningRule();
   learningRule.addListener(this);    

   //使用训练数据训练感知机（进行学习）
   System.out.println(&amp;quot;训练开始&amp;quot;);
   andPerceptron.learn(trainningSet);

   //测试感知机是否能正确输出
   System.out.println(&amp;quot;测试输出&amp;quot;);
   testNeuralNetwork(andPerceptron, trainningSet);
}


/**
 * @author Ragty
 * @param  训练之后对网络测试(测试感知机)
 * @serialData 2018.4.22
 * @param neuralNetwork
 * @param data
 */
public static void testNeuralNetwork(NeuralNetwork neuralNetwork, DataSet testSet){

    for(DataSetRow testSetRow : testSet.getRows()){
        neuralNetwork.setInput(testSetRow.getInput());
        neuralNetwork.calculate();
        double[] networkOutput = neuralNetwork.getOutput();

        System.out.println(&amp;quot;Input:&amp;quot;+Arrays.toString(testSetRow.getInput()));
        System.out.println(&amp;quot;Output:&amp;quot;+Arrays.toString(networkOutput));
    }

}


//监督训练过程
@Override
public void handleLearningEvent(LearningEvent event) {
    // TODO Auto-generated method stub
    //所有迭代学习算法的基类, 它为它的所有子类提供迭代学习过程
    IterativeLearning bp = (IterativeLearning) event.getSource();
    System.out.println(&amp;quot;iterate:&amp;quot;+bp.getCurrentIteration());
    System.out.println(Arrays.toString(bp.getNeuralNetwork().getWeights()));
}</code></pre><p>}</pre></p></p>
<p><br>
</p>
<span style="font-size:24px">4.学习结果</span>
<p><img src="https://img-blog.csdn.net/20180423135418612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>
<br>
<br>
</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/22/Neuroph%E4%BD%BF%E7%94%A8%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%AF%86%E5%88%AB%E5%9D%90%E6%A0%87%E7%B3%BB/">Neuroph使用感知机识别坐标系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/Nerouph/">Nerouph</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/Neuroph-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E8%AF%86%E5%88%AB%E5%9D%90%E6%A0%87%E7%B3%BB/">Neuroph 感知机 识别坐标系</a></span><div class="content"><a id="more"></a>


<p><span style="font-size:24px">1.创建识别坐标系的感知机</span></p>
<p><pre name="code" class="java">         /**
     * @author Ragty
     * @param  创建识别坐标系的感知机
     * @serialData 2018.4.22
     * @param inputNerouCount
     * @param outputNeurophCount
     */
    public void creatNetwork(int inputNerouCount, int outputNeurophCount){

<pre><code>    //定义感知机类型
    this.setNetworkType(NeuralNetworkType.PERCEPTRON);

    //建立输入神经元，表示输入的刺激
    NeuronProperties inputNeuronProperties = new NeuronProperties();
    inputNeuronProperties.setProperty(&amp;quot;neuronType&amp;quot;, InputNeuron.class);

    //输入神经元构建的输入层
    Layer inputLayer = LayerFactory.createLayer(inputNerouCount, inputNeuronProperties);
    this.addLayer(inputLayer);

    //设置传递函数为step函数(即为是大于0为1，小于等于1为0)
    NeuronProperties outputNeuronProperties = new NeuronProperties();
    outputNeuronProperties.setProperty(&amp;quot;transferFunction&amp;quot;,TransferFunctionType.STEP);

    //指定输出层包含两个神经元
    Layer outputLayer = LayerFactory.createLayer(outputNeurophCount, outputNeuronProperties);
    this.addLayer(outputLayer);

    //输入输出层全连接
    ConnectionFactory.fullConnect(inputLayer, outputLayer);
    NeuralNetworkFactory.setDefaultIO(this);

    //设置连接权重(直接关系到神经网络能否正常工作)分 别为[1 0] [0 1]
    //因为要区分四个象限对应为[1,1] [0,1] [0,0] [1,0] stpe函数中负数表示为0
    //根据公式的话，以第一象限为例，要求第一想想上边得出的结果必须为1，下边得出的结果也必须为1
    //据此可推断出权重为 [1 0] [0 1]
    Neuron n = outputLayer.getNeuronAt(0);
    n.getInputConnections()[0].getWeight().setValue(1);   
    n.getInputConnections()[1].getWeight().setValue(0);

    n = outputLayer.getNeuronAt(1);
    n.getInputConnections()[0].getWeight().setValue(0);
    n.getInputConnections()[1].getWeight().setValue(1);

}&lt;/pre&gt;&lt;/p&gt;</code></pre><p><br>
</p>
<span style="font-size:24px">2.输入两个&#20540;，判断为第几象限</span>
<p><pre name="code" class="java">          public static void main(String[] args) {

<pre><code>    Scanner in = new Scanner(System.in);
    String line = null;          
    double[] input = new double[2];
    //两个输入，两个输出的感知机
    feelPos perceptron = new feelPos(2, 2);

    try {
        while ((line = in.nextLine())!= null){
            String[] numbers = line.split(&amp;quot;[\\s|,|;]&amp;quot;);
            input[0] = Double.parseDouble(numbers[0]);
            input[1] = Double.parseDouble(numbers[1]);

            perceptron.setInput(input);
            perceptron.calculate();
            double[] networkOutput = perceptron.getOutput();
            System.out.println(Arrays.toString(input)+ &amp;quot;=&amp;quot; +posToString(networkOutput));
        }
    } catch (Exception e) {
        // TODO: handle exception
    }


}

//判断为第几象限
public static String posToString(double[] networkOutput ){
    if((networkOutput[0]+networkOutput[1])==2){
        return &amp;quot;第一象限&amp;quot;;
    }else if((networkOutput[0]+networkOutput[1])==0){
        return &amp;quot;第三象限&amp;quot;;
    }else if((networkOutput[0]-networkOutput[1])==1){
        return &amp;quot;第四象限&amp;quot;;
    }
    return &amp;quot;第二象限&amp;quot;;
}&lt;/pre&gt;&lt;span style=&quot;font-size:24px&quot;&gt;&lt;/span&gt;&lt;/p&gt;</code></pre><p><span style="font-size:24px"><br>
</span></p>
3.识别结果
<p><span style="font-size:24px"><img src="https://img-blog.csdn.net/20180422163116373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</span><br>
</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/22/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/">Neuroph感知机实现记忆逻辑与</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-Nerouph/">人工智能 Nerouph</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/Neuroph-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/">Neuroph 感知机 记忆逻辑与</a></span><div class="content"><a id="more"></a>


<h1><span style="font-size:24px">&nbsp;<span style="font-weight:normal">1</span>.<span style="color:#666666">创建感知机</span></span></h1>
<div><span style="font-size:14px; color:#666666"></span><pre name="code" class="html">    private void creatNetwork(int inputNeuronsCount){

<pre><code>    //设置网络类别为感知机
    this.setNetworkType(NeuralNetworkType.PERCEPTRON);


    //建立输入神经元，表示输入的刺激
    NeuronProperties inputNeuron = new NeuronProperties();
    inputNeuron.setProperty(&amp;quot;neuronType&amp;quot;, InputNeuron.class);


    //由输入神经元构成的底层
    Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, inputNeuron);
    this.addLayer(inputLayer);
    //在输入层增加贝叶斯神经，表示神经元偏置
    inputLayer.addNeuron(new BiasNeuron());


    //设置传递函数为step()函数
    NeuronProperties outputProperties = new NeuronProperties();
    outputProperties.setProperty(&amp;quot;transferFunction&amp;quot;, TransferFunctionType.STEP);
    Layer outputLayer = LayerFactory.createLayer(1, outputProperties);
    this.addLayer(outputLayer);


    //将输入层和输出层进行全连接(输入节点和每个神经元都两两连接)
    ConnectionFactory.fullConnect(inputLayer, outputLayer);
    NeuralNetworkFactory.setDefaultIO(this);
    Neuron n = outputLayer.getNeuronAt(0);

    System.out.println(n);

    //设置每个连接的权重，1和1是输入节点到神经元的权值，-1.5是神经元的偏置
    n.getInputConnections()[0].getWeight().setValue(1);
    n.getInputConnections()[1].getWeight().setValue(1);
    n.getInputConnections()[2].getWeight().setValue(-1.5);

}&lt;/pre&gt;&lt;br&gt;</code></pre></div>
<div><span style="font-size:14px; color:#666666"><br>
</span></div>
<div><span style="color:#666666"></span>
<h1><span style="font-size:32px">&nbsp;</span><span style="font-size:24px">2.<span style="color:rgb(102,102,102)">使用感知机记忆逻辑与</span></span></h1>
<div style="font-size:14px"><span style="color:#666666"><span style="font-size:24px"></span></span><pre name="code" class="html" style="color: rgb(102, 102, 102);font-size:14px;"><pre name="code" class="java">public static void main(String[] args) {

<pre><code>    //创建学习数据集
    DataSet trainingSet = new DataSet(2,1);  //两个输入，一个输出
    trainingSet.addRow(new DataSetRow(new double[] {0,0},new double[] {Double.NaN}));
    trainingSet.addRow(new DataSetRow(new double[] {0,1},new double[] {Double.NaN}));
    trainingSet.addRow(new DataSetRow(new double[] {1,0},new double[] {Double.NaN}));
    trainingSet.addRow(new DataSetRow(new double[] {1,1},new double[] {Double.NaN}));

    simpleDemo perceptron = new simpleDemo(2);

    for(DataSetRow row : trainingSet.getRows()){
        perceptron.setInput(row.getInput());
        perceptron.calculate();
        double[] networkOutput = perceptron.getOutput();
        System.out.println(Arrays.toString(row.getInput())+&amp;quot;=&amp;quot;+Arrays.toString(networkOutput));
    }


}&lt;/pre&gt;&lt;br&gt;</code></pre><pre></pre>
<br>
</div>
<div>
<h1 style="color:rgb(102,102,102)"><span style="font-size:24px">3.识别结果</span></h1>
<div style="font-size:14px"><img src="https://img-blog.csdn.net/20180422142020774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</div>
<br>
</div>
</div>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/20/Neuroph%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Neuroph开发环境搭建</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">神经网络，机器学习</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/Neuroph-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">Neuroph 神经网络 机器学习</a></span><div class="content"><a id="more"></a>


<p><br>
</p>
<h1><span style="font-size:32px; color:#666666">Neuroph简介</span></h1>
<p><span style="font-size:18px"><a target="_blank" href="http://sourceforge.net/projects/neuroph/?source=typ_redirect" style="color:rgb(103,149,181); margin:0px; padding:0px; text-decoration:none; font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">Neuroph</a><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">是一个轻量级的Java神经网络的框架，可以用来模拟常见的神经网络架构。少数基本类别相对应的基本网络的概念，它非常容易学习。而且它也还有一个不错的GUI应用程序。Neurop最初是一位硕士研究生的毕业论文主题，随后成为一个开源项目，它采用LGPL3许可证发布源代码。</span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><br>
</span></span></p>
<h1><span style="color:rgb(79,79,79); line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-family:SimSun; font-size:32px">Neuroph开发环境搭建</span></span></span></h1>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-size:18px"><br>
</span></span></span></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-size:18px">一. &nbsp;JDK的配置及安装 &nbsp; &nbsp; &nbsp;&nbsp;</span></span></span><a target="_blank" href="https://www.cnblogs.com/cxysj/p/8204267.html" style="font-size:18px; font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">传送门</a></p>
<p><span style="font-size:24px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">二</span>.&nbsp;<span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">Maven安装
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a target="_blank" href="https://www.cnblogs.com/yyiou/archive/2017/08/22/7411409.html">传送门</a></span></span></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">三. &nbsp;新建项目</span></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">&nbsp;(1) 新建 maven 项目（结构如下）</span></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"></span></p>
<div></div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img-blog.csdn.net/20180420204454236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify"><br>
</span></span></p>
<p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">(2)
 引入需要的包 (右键builld path)</span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img-blog.csdn.net/20180420204820069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify"><br>
</span></span></span></p>
<p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">(3)
 &nbsp;pom.xml添加依赖</span></span></span></p>
<pre class="html">   &lt;dependency&gt;
            &lt;groupId&gt;org.neuroph&lt;/groupId&gt;
            &lt;artifactId&gt;neuroph-core&lt;/artifactId&gt;
            &lt;version&gt;2.8&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt; 
            &lt;systemPath&gt;${project.basedir}/lib/neuroph-core-2.8.jar&lt;/systemPath&gt; 
        &lt;/dependency&gt;

<pre><code>&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-nop&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.14&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/pre&gt;</code></pre><br>
这样我们就搭建好了Neuroph的基本环境
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2018/04/04/Gradle%E7%AE%80%E4%BB%8B/">Gradle简介</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%A1%86%E6%9E%B6%EF%BC%8Cgradle%EF%BC%8Cmaven/">框架，gradle，maven</a></span><div class="content"><a id="more"></a>

<p><span style="font-weight:600;color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">Gradle</span><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">是一个基于</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Apache_Ant" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Apache Ant</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">和</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Apache_Maven" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Apache Maven</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">概念的项目</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/%25E8%2587%25AA%25E5%258B%2595%25E5%258C%2596%25E5%25BB%25BA%25E6%25A7%258B" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">自动化建构</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">工具。它使用一种基于</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Groovy" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Groovy</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">的</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/w/index.php%3Ftitle%3D%25E7%2589%25B9%25E5%25AE%259A%25E9%25A2%2586%25E5%259F%259F%25E8%25AF%25AD%25E8%25A8%2580%26action%3Dedit%26redlink%3D1" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">特定领域语言</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">来声明项目设置，而不是传统的</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/XML" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">XML</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">。当前其支持的语言限于</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Java" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Java</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">、</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Groovy" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Groovy</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">和</span><a href="https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/Scala" class="wrap external" style="text-decoration:none;border-bottom-width:1px;border-bottom-style:solid;line-height:26.72px;white-space:pre-wrap;">Scala</a><span style="color:rgb(133,144,166);line-height:26.72px;white-space:pre-wrap;">，计划未来将支持更多的语言。</span></p><div><div><p>上面是维基上对Gradle的解释,相信一个没有接触过构建的人是不大能看明白的,当初我也是.下面是我对Gradle<strong>通俗</strong>的理解:</p><p>软件开发讲究代码复用,通过复用可以使工程更易维护,代码量更少..... 开发者可以通过继承,组合,函数模块等实现不同程度上的代码复用.但不知你有没有想过,软件开发也是一种工程作业,绝不仅仅是写代码,还涉及到工程的各种管理(依赖,打包,部署,发布,各种渠道的差异管理.....),你每天都在build,clean,签名,打包,发布,有没有想过这种过程,也可以像代码一样被描述出来, 也可以被复用.</p></div><div><br /><div><p><strong>差异管理</strong></p><p>但这两种解决方法都有自己的缺点,特别是前一种有极大的代码重复.后一种稍微好一点,但这种方式的差异是运行时的,不是静态的,对于moto手机上的处理逻辑对华为手机来说一点作用也没有,但这一段针对moto手机的处理逻辑也被装到了华为手机上了,通过gradle的productFlavor与buildtype可以实现静态级的差异控制可以参考<a href="https://link.zhihu.com/?target=http%3A//ghui.me/post/2015/03/create-several-variants/" class="wrap external">如何通过Gradle实现一套代码开发不同特性的APK · ByGhui</a></p><p>说到前面的多渠道问题,不同的渠道一般会对应不同的渠道号,你当然可以通过修改一次打一个包这种纯手工的方式来生成你的多渠道包,但据听说国内某团购网站的Android App有100多个渠道.这里出现了什么?重复,反复的去打包而且这些包之前的差异很小(只是渠道号不同),和写代码一样我们应该复用,通过Gradle可以实现一个命令打出所有的渠道包,一个命令打出指定的渠道包.再复杂一点,你可能需要不同的渠道对应不同的签名文件,不同的icon,不同的服务器地址...这些都可以通过Gradle来方便的实现.</p><p><strong><br /></strong></p><p><strong>依赖管理:</strong></p><p>做软件开发你可能需要依赖各种不同的jar,library.你当然可以通过将.jar/library工程下载到本地再copy到你的工程中,但不知你是否听说过国外有个叫<strong>中央仓库</strong>的东西,在这个仓库里你可以找到所有你能想到以及你从来没听说过的jar,aar...<a href="https://link.zhihu.com/?target=http%3A//search.maven.org/" class="wrap external">The Central Repository Search Engine</a> 这里可以找到所有你需要的依赖,而你需要的只是指定一个坐标,如下:</p><img src="https://pic3.zhimg.com/80/8883d4b758b288a74eb4c104db854c5f_hd.jpg" class="content_image lazy" width="330" alt="" /><p>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:</p><p>剩下的依赖的寻找,下载,添加到classpath等你都不需要去关心,通过这种方式来维护依赖的好处有以下几点:</p><ol><li>依赖不会进入到你的版本控制仓库中(默认会缓存到~/.gradle/下)</li><li>方便卸载装载依赖(只是一条坐标依赖,不需要删除即可)</li><li>方便的版本管理,如上图中的2.3.3既是picasso的版本号,若改为+就表示从中央仓库中下载最新的版本</li><li>不同工程的相同依赖不会存在重复副本(只在~/.gradle下存在一份)</li></ol><p><strong><br /></strong></p><p><strong>项目部署</strong></p><p>这方面我没怎么接触过,但据我所知通过一些插件,可以实现自动将你的输出(.jar,.apk,.war...)上传到指定仓库,自动部署...</p><p></p><p style="margin-top:0px;margin-bottom:.72em;color:rgb(26,26,26);line-height:26.72px;white-space:pre-wrap;"><span style="font-weight:600;">总结一下</span></p><p style="margin-top:0px;margin-bottom:.72em;color:rgb(26,26,26);line-height:26.72px;white-space:pre-wrap;"><span style="line-height:26.72px;">1<span style="font-weight:600;">.</span>Gradle</span><span style="line-height:26.72px;font-weight:600;"><em><span style="border-bottom-width:1px;border-bottom-style:solid;">是一种构建工具</span></em></span><span style="line-height:26.72px;">,它可以帮你管理项目中的差异,依赖,编译,打包,部署......,你可以定义满足自己需要的构建逻辑,写入到build.gradle中供日后复用.</span></p><p style="margin-top:0px;margin-bottom:.72em;color:rgb(26,26,26);line-height:26.72px;white-space:pre-wrap;"><span style="line-height:26.72px;">2.Gradle</span><span style="line-height:26.72px;font-weight:600;"><em><span style="border-bottom-width:1px;border-bottom-style:solid;">不是一种编程语言</span></em></span><span style="line-height:26.72px;">,它不能帮你实现软件中的任何实际功能</span></p><br /></div></div></div><p></p><br /></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Ragty</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="http://beian.miit.gov.cn " target="_blank" rel="noopener" charset="utf-8"> ICP备案号:京ICP备<13502>号 </a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.7.0"></script><script src="/blog/js/fancybox.js?version=1.7.0"></script><script src="/blog/js/sidebar.js?version=1.7.0"></script><script src="/blog/js/copy.js?version=1.7.0"></script><script src="/blog/js/fireworks.js?version=1.7.0"></script><script src="/blog/js/transition.js?version=1.7.0"></script><script src="/blog/js/scroll.js?version=1.7.0"></script><script src="/blog/js/head.js?version=1.7.0"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>