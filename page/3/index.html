<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Ragty"><meta name="copyright" content="Ragty"><title>When the world sleep, I dream. | Ragty の Blog</title><link rel="shortcut icon" href="/blog/melody-favicon.ico"><link rel="stylesheet" href="/blog/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://secure.gravatar.com/avatar/dcc38a5a0d37cb7348d4f72d8f6a2de0"></div><div class="author-info__name text-center">Ragty</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/huoji555" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">75</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">38</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/huoji555" target="_blank" rel="noopener">MY-CSDN</a></div></div></div><nav id="nav" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">Ragty の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/blog">Home</a><a class="site-page" href="/blog/archives">Archives</a><a class="site-page" href="/blog/categories">Categories</a><a class="site-page" href="/blog/tags">Tags</a><a class="site-page" href="/blog/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">Ragty の Blog</div><div id="site-sub-title">When the world sleep, I dream.</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://blog.csdn.net/huoji555" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89FastDFS+Nginx%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">FastDFS分布式文件系统搭建（二）FastDFS+Nginx实现分布式文件系统</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/FastDFS/">FastDFS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/FastDFS%E6%90%AD%E5%BB%BA-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/">FastDFS搭建 分布式文件系统搭建</a></span><div class="content"><a id="more"></a>

<h5 id="1-FastDFS安装环境"><a href="#1-FastDFS安装环境" class="headerlink" title="1 FastDFS安装环境"></a>1 <code>FastDFS</code>安装环境</h5><p><code>FastDFS</code>是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。</p>
<p>首先安装<code>gcc</code>编译环境</p>
<blockquote>
<p>yum install gcc-c++</p>
</blockquote>
<br>

<h5 id="2-安装libevent"><a href="#2-安装libevent" class="headerlink" title="2 安装libevent"></a>2 安装<code>libevent</code></h5><p>FastDFS依赖<code>libevent</code>库，需要安装：</p>
<blockquote>
<p>yum -y install libevent</p>
</blockquote>
<br>

<h5 id="3-安装libfastcommon"><a href="#3-安装libfastcommon" class="headerlink" title="3 安装libfastcommon"></a>3 安装<code>libfastcommon</code></h5><p>这里强调一下，此包 包含了FastDFS运行所需要的一些基础库，可从Github下载<a href="https://github.com/happyfish100/libfastcommon" target="_blank" rel="noopener">master</a>这个版本，和后边的<code>FastDFS</code>版本有关系.</p>
<p>将该文件拷贝到/usr/local/下</p>
<blockquote>
<p>cd /usr/local</p>
<p>unzip libfastcommon-master.zip</p>
<p>cd libfastcommon-master</p>
<p>./make.sh</p>
<p>./make.sh install</p>
</blockquote>
<p><code>libfastcommon</code>默认安装到了</p>
<ul>
<li>/usr/lib64/libfastcommon.so</li>
<li>/usr/lib64/libfdfsclient.so</li>
</ul>
<p>因为FastDFS主程序设置的lib目录是/usr/local/lib，所以需要<strong>创建软链接</strong>.</p>
<blockquote>
<p>ln -s /usr/lib64/libfastcommon.so  /usr/local/lib/libfastcommon.so</p>
<p>ln -s /usr/lib64/libfastcommon.so  /usr/lib/libfastcommon.so</p>
<p>ln -s /usr/lib64/libfdfsclient.so  /usr/local/lib/libfdfsclient.so</p>
<p>ln -s /usr/lib64/libfdfsclient.so  /usr/lib/libfdfsclient.so</p>
</blockquote>
<p>这里需要注意一下，创建软连接时<strong>不可直接复制文件</strong>到别的地方，会导致文件无可用权限而影响后边的安装.</p>
<br>

<h5 id="2-2-3-安装FastDFS"><a href="#2-2-3-安装FastDFS" class="headerlink" title="2.2.3 安装FastDFS"></a>2.2.3 安装<code>FastDFS</code></h5><p>首先下载文件，这里需要和之前的版本保持对应，<code>libfastcommon-master(200k)</code>对应这里的<a href="https://sourceforge.net/projects/fastdfs/" target="_blank" rel="noopener">5.08</a>版本.</p>
<blockquote>
<p>tar -zxvf FastDFS_v5.08.tar.gz</p>
<p>cd FastDFS</p>
<p>./make.sh</p>
<p>./make.sh install</p>
</blockquote>
<p>安装成功后进入到FastDFS文件，将<code>conf</code>中的的所有文件拷贝到/etc/fdfs/下.</p>
<p>进入/etc/fdfs/目录下，修改配置文件:</p>
<blockquote>
<p>cp tracker.conf      # 拷贝</p>
<p>vi tracker.conf       # 修改</p>
<p>将 base_path=/home/yuqing/FastDFS </p>
<p>改为</p>
<p>base_path=/home/FastDFS</p>
</blockquote>
<p>这时，可以尝试启动项目了：</p>
<blockquote>
<p>/usr/bin/fdfs_trackerd/etc/fdfs/tracker.conf restart</p>
</blockquote>
<p>设置开机自动启动</p>
<blockquote>
<p>vim /etc/rc.d/rc.local</p>
<p>/usr/bin/fdfs_trackerd/etc/fdfs/tracker.conf restart</p>
</blockquote>
<br>

<h5 id="2-2-4-Storage安装"><a href="#2-2-4-Storage安装" class="headerlink" title="2.2.4 Storage安装"></a>2.2.4 <code>Storage</code>安装</h5><p>如果时在不同的服务器安装，重复以上的步骤即可</p>
<p>之后是配置<code>Storage</code>服务</p>
<p>修改<code>/etc/fdfs/storage.conf</code>文件</p>
<p><img src="https://img-blog.csdn.net/20180626140318180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180626140300245?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180626140244516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>启动<code>Storage</code>服务</p>
<blockquote>
<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</code> </p>
<p>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart    # 重启命令</p>
</blockquote>
<br>

<h5 id="2-2-5-检测Storage服务是否正常"><a href="#2-2-5-检测Storage服务是否正常" class="headerlink" title="2.2.5 检测Storage服务是否正常"></a>2.2.5 检测<code>Storage</code>服务是否正常</h5><p>1.修改配置文件<code>/etc/fdfs/client.conf</code></p>
<p><img src="https://img-blog.csdn.net/20180626140230202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>2.测试</p>
<p><img src="https://img-blog.csdn.net/20180626140209646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<blockquote>
<p>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg</p>
</blockquote>
<p>3.测试结果</p>
<p><img src="https://img-blog.csdn.net/20180626140627785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>至此，FastDFS配置成功.</p>
<br>

<h5 id="2-2-5-Nginx安装"><a href="#2-2-5-Nginx安装" class="headerlink" title="2.2.5 Nginx安装"></a>2.2.5 Nginx安装</h5><p>现在安装好了FastDFS，可以实现上传图片功能，但是它并没有提供HTTP服务，所以无法通过HTTP来访问文件，这时就需要整合Nginx，让Nginx来实现这个功能。</p>
<p>这里我们先安装<code>fastdfs-nginx-module</code>，<a href="https://github.com/happyfish100/fastdfs-nginx-module" target="_blank" rel="noopener">下载地址</a></p>
<ul>
<li>解压</li>
</ul>
<blockquote>
<p>unzip  fastdfs-nginx-module.zip</p>
</blockquote>
<ul>
<li>修改压缩包下<code>/usr/local/fastdfs-nginx-module/src/config</code>文件，把其中的<code>local</code>去掉 </li>
</ul>
<p><img src="https://img-blog.csdn.net/20180626163055392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ul>
<li>对nginx重新配置(这里主要是将以上的<code>fastdfs-nginx-module</code>编译)</li>
</ul>
<blockquote>
<p>./configure –add-module=/usr/local/fastdfs-nginx-module/src</p>
<p>chmod +x *</p>
<p>make</p>
<p>make install</p>
</blockquote>
<p>如果你没有Nignx的话，先安一个:</p>
<blockquote>
<p>cd /usr/local/src<br>wget   <a href="http://nginx.org/download/nginx-1.10.3.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.10.3.tar.gz</a><br>tar -zxvf nginx-1.10.3.tar.gz<br>cd nginx-1.10.3<br>./configure –add-module=/usr/local/fastdfs-nginx-module/src<br>make<br>make install</p>
</blockquote>
<p>把<code>/usr/local/fastdfs-nginx-module/src/mod_fastdfs.conf</code>文件复制到<code>/etc/fdfs</code>目录下。编辑：</p>
<blockquote>
<p>vi mod_fastdfs.conf       # 修改</p>
<p>url_have_group_name = true     #否则浏览器无法查看图片</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180626163653336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180626163659848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180626163708533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<br>

<h5 id="2-2-6-配置Nginx"><a href="#2-2-6-配置Nginx" class="headerlink" title="2.2.6 配置Nginx"></a>2.2.6 配置Nginx</h5><h6 id="在-nginx的配置文件nginx-conf中添加一个Server"><a href="#在-nginx的配置文件nginx-conf中添加一个Server" class="headerlink" title="在 nginx的配置文件nginx.conf中添加一个Server"></a>在 nginx的配置文件<code>nginx.conf</code>中添加一个Server</h6><blockquote>
<p>vim /usr/local/nginx/conf/nginx.conf</p>
</blockquote>
<p>添加的server</p>
<blockquote>
<p>server {<br>       listen       8888;  # 监听的端口<br>       server_name  10.101.100.45;  #配置的Stroge服务器地址</p>
<p>​        location /group1/M00{<br>​                     root /usr/coallocal/test;   #配置的文件上传地址(同之前的配置保持一致)<br>​                     ngx_fastdfs_module;        #插件名称<br>                   }<br>​    }</p>
</blockquote>
<br>

<h5 id="2-2-7-启动Nignx"><a href="#2-2-7-启动Nignx" class="headerlink" title="2.2.7 启动Nignx"></a>2.2.7 启动Nignx</h5><blockquote>
<p>cd nginx</p>
<p>sbin/nginx</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180626164336870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>测试图片上传:</p>
<blockquote>
<p>cd /etc/fdfs<br>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180626165150607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>浏览器中访问网址</p>
<p><img src="https://img-blog.csdn.net/20180626165251260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">FastDFS分布式文件系统搭建（一）基础原理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/FastDFS/">FastDFS</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/FastDFS-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-FastDFS%E5%8E%9F%E7%90%86/">FastDFS 分布式文件系统 FastDFS原理</a></span><div class="content"><a id="more"></a>

<h3 id="1-1-什么是FastDFS"><a href="#1-1-什么是FastDFS" class="headerlink" title="1.1   什么是FastDFS"></a>1.1   什么是FastDFS</h3><p>​        FastDFS是用c语言编写的一款开源的<strong>分布式文件系统</strong>。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易<strong>搭建一套高性能的文件服务器集群提供文件上传、下载等服务</strong>。</p>
<br>



<h3 id="1-2-FastDFS架构"><a href="#1-2-FastDFS架构" class="headerlink" title="1.2  FastDFS架构"></a>1.2  FastDFS架构</h3><p>  <code>FastDFS</code>架构包括 <code>Tracker server</code>和<code>Storage server</code>。客户端请求<code>Tracker server</code>进行文件上传、下载，通过<code>Trackerserver</code>调度最终由Storage server完成文件上传和下载。</p>
<p>​        <code>Trackerserver</code>作用是<strong>负载均衡和调度</strong>，通过<code>Trackerserver</code>在文件上传时可以根据一些策略找到<code>Storageserver</code>提供文件上传服务。可以将tracker称为<strong>追踪服务器或调度服务器</strong>。</p>
<p>​        <code>Storageserver</code>作用是<strong>文件存储</strong>，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong>。</p>
<p><img src="https://img-blog.csdn.net/20180516113227670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<br>



<h5 id="1-2-1-Tracker-集群"><a href="#1-2-1-Tracker-集群" class="headerlink" title="1.2.1  Tracker 集群"></a>1.2.1  Tracker 集群</h5><p><code>FastDFS</code>集群中的<code>Tracker server</code>可以有多台，<code>Trackerserver</code>之间是<strong>相互平等关系同时提供服务</strong>，<code>Trackerserver</code>不存在单点故障。客户端请求<code>Trackerserver</code>采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。<br><br></p>
<h5 id="1-2-2-Storage集群"><a href="#1-2-2-Storage集群" class="headerlink" title="1.2.2  Storage集群"></a>1.2.2  Storage集群</h5><p>​        <code>Storage</code>集群采用了<strong>分组存储方式</strong>。<code>storage</code>集群<strong>由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和</strong>。一个组由一台或多台存储服务器组成，组内的<code>Storage server</code>之间是平等关系，不同组的<code>Storageserver</code>之间不会相互通信，同组内的<code>Storageserver</code>之间会相互连接进行文件同步，从而保证同组内每个<code>storage</code>上的文件完全一致的。一个组的存储容量为该组内存储服务器容量最小的那个，由此可见组内存储服务器的软硬件配置最好是一致的。</p>
<p>​        采用分组存储方式的好处是<strong>灵活、可控性较强</strong>。比如上传文件时，可以由客户端直接指定上传到的组也可以由tracker进行调度选择。一个分组的存储服务器访问压力较大时，可以在该组增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组来扩充存储容量（横向扩容）。<br><br></p>
<h5 id="1-2-3-Storage状态收集"><a href="#1-2-3-Storage状态收集" class="headerlink" title="1.2.3  Storage状态收集"></a>1.2.3  Storage状态收集</h5><p><code>Storage server</code>会连接集群中所有的<code>Tracker server</code>，<strong>定时向他们报告自己的状态</strong>，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。<br><br></p>
<h5 id="1-2-4-文件上传流程"><a href="#1-2-4-文件上传流程" class="headerlink" title="1.2.4  文件上传流程"></a>1.2.4  文件上传流程</h5><p><img src="https://img-blog.csdn.net/20180516113258902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p>
<p><img src="https://img-blog.csdn.net/20180516113315796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。</p>
<p>虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。</p>
<p>数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。</p>
<p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。<br><br></p>
<h5 id="1-2-5-文件下载流程"><a href="#1-2-5-文件下载流程" class="headerlink" title="1.2.5  文件下载流程"></a>1.2.5  文件下载流程</h5><p><img src="https://img-blog.csdn.net/20180516113332205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">数据结构思维笔记（十四）二叉搜索树</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">二叉搜索树 数据结构</a></span><div class="content"><a id="more"></a>

<p>本章继续承接上章的内容，具体实现<code>TreeMap</code>中的方<br><br></p>
<h6 id="1-简单的TreeMap"><a href="#1-简单的TreeMap" class="headerlink" title="1.简单的TreeMap"></a>1.简单的<code>TreeMap</code></h6><p>这里比较核心的一个方法是<code>findNode</code>，用来寻找与键值相当的节点，下面是它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findNode</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Comparable&lt;?<span class="keyword">super</span> K&gt; k = (Comparable&lt;?<span class="keyword">super</span> K&gt;)target;</span><br><span class="line"></span><br><span class="line">      Node node = root;</span><br><span class="line">      <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> cmp = k.compareTo(node.key);</span><br><span class="line">          <span class="keyword">if</span> (cmp &lt;<span class="number">0</span>)</span><br><span class="line">              node = node.left;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)</span><br><span class="line">              node = node.right;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个实现中，<code>null</code>不是键的合法值。</li>
<li>在我们可以在<code>target</code>上调用<code>compareTo</code>之前，我们必须把它强制转换为某种形式的<code>Comparable</code>。这里使用的“<strong>类型通配符</strong>”会尽可能允许；也就是说，它适用于任何实现<code>Comparable</code>类型，并且它的<code>compareTo</code>接受<code>K</code>或者任和<code>K</code>的超类（<strong>可以同任何类型做比较</strong>）。</li>
</ul>
<p>之后，实际搜索比较简单。我们初始化一个循环变量<code>node</code>来引用根节点。每次循环中，我们将目标与<code>node.key</code>比较。<strong>如果目标小于当前键，我们移动到左子树。如果它更大，我们移动到右子树。如果相等，我们返回当前节点(这里用的是迭代，不断赋值)。</strong></p>
<br>



<h6 id="2-搜索值"><a href="#2-搜索值" class="headerlink" title="2.搜索值"></a>2.搜索值</h6><p><strong><code>findNode</code>运行时间与树的高度成正比</strong>，而不是节点的数量，因为我们不必搜索整个树。<strong>但是对于<code>containsValue</code>，我们必须搜索值，而不是键</strong>；BST 的特性不适用于值，因此我们必须搜索整个树。</p>
<p>下面是<code>containsValue</code>方法，这里用<strong>递归</strong>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsValueHelper(root, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsValueHelper</span><span class="params">(Node node, Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (equals(target, node.value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containsValueHelper(node.left, target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containsValueHelper(node.right, target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>containsValueHelper</code>的工作原理：</p>
<ul>
<li>第一个<code>if</code>语句检查递归的边界情况。如果<code>node</code>是<code>null</code>，那意味着我们已经递归到树的底部，没有找到<code>target</code>，所以我们应该返回<code>false</code>。请注意，<strong>这只意味着目标没有出现在树的一条路径上；它仍然可能会在另一条路径上被发现。</strong></li>
<li>第二种情况检查我们是否找到了我们正在寻找的东西。如果是这样，我们返回<code>true</code>。否则，我们必须继续。</li>
<li>第三种情况是执行递归调用，在左子树中搜索<code>target</code>。如果我们找到它，我们可以立即返回<code>true</code>，而不搜索右子树。否则我们继续。</li>
<li>第四种情况是搜索右子树。同样，如果我们找到我们正在寻找的东西，我们返回<code>true</code>。否则，我们搜索完了整棵树，返回<code>false</code>。</li>
</ul>
<p>该方法“访问”了树中的每个节点，<strong>所以它的所需时间与节点数成正比</strong>。</p>
<br>



<h6 id="3-实现put"><a href="#3-实现put" class="headerlink" title="3.实现put"></a>3.实现<code>put</code></h6><p><code>put</code>方法比起<code>get</code>要复杂一些，因为要处理两种情况：</p>
<ol>
<li><strong>如果给定的键已经在树中，则替换并返回旧值</strong>；</li>
<li><strong>否则必须在树中添加一个新的节点，在正确的地方</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> putHelper(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putHelper</span><span class="params">(Node node, K key, V value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">int</span> cmp = k.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> putHelper(node.left, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> putHelper(node.right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = node.value;</span><br><span class="line">    node.value = value;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>node</code>最初是树的根，但是每次我们执行递归调用，它指向了不同的子树。就像<code>get</code>一样，我们用<code>compareTo</code>方法来弄清楚，跟随哪一条树的路径。如果<code>cmp &lt; 0</code>，我们添加的键小于<code>node.key</code>，那么我们要走左子树。有两种情况：</p>
<ul>
<li>如果左子树为空，那就是，如果<code>node.left</code>是<code>null</code>，我们已经到达树的底部而没有找到<code>key</code>。这个时候，我们知道<code>key</code>不在树上，我们知道它应该放在哪里。所以我们创建一个新节点，并将它添加为<code>node</code>的左子树。</li>
<li>否则我们进行递归调用来搜索左子树。</li>
</ul>
<p>如果<code>cmp &gt; 0</code>，我们添加的键大于<code>node.key</code>，那么我们要走右子树。我们处理的两个案例与上一个分支相同。最后，如果<code>cmp == 0</code>，我们在树中找到了键，那么我们更改它并返回旧的值。</p>
<br>



<h6 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4.中序遍历"></a>4.中序遍历</h6><p>这里我们还剩最后一个方法<code>KeySet</code>，它返回一个<code>Set</code>，按升序包含树中的键。在其他<code>Map</code>实现中，<code>keySet</code>返回的键没有特定的顺序，但是树形实现的一个功能是，<strong>对键进行简单而有效的排序</strong>。下面是如何实现它的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;K&gt;();</span><br><span class="line">    addInOrder(root, set);</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addInOrder</span><span class="params">(Node node, Set&lt;K&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    addInOrder(node.left, set);</span><br><span class="line">    set.add(node.key);</span><br><span class="line">    addInOrder(node.right, set);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>keySet</code>中，我们创建一个<code>LinkedHashSet</code>，这是一个<code>Set</code>实现，使元素保持有序,第一个参数<code>node</code>最初是树的根，但正如你的期望，我们用它来递归地遍历树。<code>addInOrder</code>对树执行经典的“中序遍历”。</p>
<ol>
<li>按顺序遍历左子树。</li>
<li>添加<code>node.key</code>。</li>
<li>按顺序遍历右子树。</li>
</ol>
<br>



<h6 id="5-二叉搜索树的问题"><a href="#5-二叉搜索树的问题" class="headerlink" title="5.二叉搜索树的问题"></a>5.二叉搜索树的问题</h6><p>我们获取最有查询效率时，<strong>一般是O(log(n))</strong>，这种情况会在所搜索的树为平衡二叉树时出现，若不是平衡二叉树，搜索效率则会很低。</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/13-1.jpg" alt=""></p>
<p>如果你思考<code>put</code>如何工作，你可以弄清楚发生了什么。每次添加一个新的键时，它都大于树中的所有键，所以我们总是选择右子树，并且总是将新节点添加为，最右边的节点的右子节点。结果是一个“不平衡”的树，只包含右子节点。</p>
<p><strong>这种树的高度正比于<code>n</code>，不是<code>logn</code>，所以<code>get</code>和<code>put</code>的性能是线性的，不是对数的</strong></p>
<br>



<h6 id="6-自平衡树"><a href="#6-自平衡树" class="headerlink" title="6.自平衡树"></a>6.自平衡树</h6><p>这个问题有两种可能的解决方案：</p>
<ul>
<li><strong>你可以避免向<code>Map</code>按顺序添加键</strong>。但这并不总是可能的。 你可以制作一棵树，如果碰巧按顺序处理键，那么它会更好地处理键。(<strong>按顺序添加会导致这是一个极不平衡的树</strong>)</li>
<li>第二个解决方案是更好的，有几种方法可以做到。最常见的是修改<code>put</code>，以便它检测树何时开始变得不平衡，如果是，则重新排列节点。具有这种能力的树被称为“自平衡树”。普通的自平衡树包括 AVL 树（“AVL”是发明者的缩写），以及红黑树，这是 Java<code>TreeMap</code>所使用的。</li>
</ul>
<p>总而言之，二叉搜索树可以以对数时间实现<code>get</code>和<code>put</code>，但是只能按照使得树足够平衡的顺序添加键。<strong>自平衡树通过每次添加新键时，进行一些额外的工作来避免这个问题</strong>。<br><br></p>
<h6 id="7-二叉搜索树的删除"><a href="#7-二叉搜索树的删除" class="headerlink" title="7.二叉搜索树的删除"></a>7.二叉搜索树的删除</h6><p><strong>实现思路：</strong></p>
<blockquote>
<ol>
<li>删除叶子节点</li>
<li>删除只有左孩子的节点</li>
<li>删除只有右孩子的节点</li>
<li>删除左右孩子都有的节点，这里我们需要找出待删除节点的右子树中的最小节点，并放到待删除位置上</li>
</ol>
</blockquote>
<p>下面是实现的具体方案:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一会儿我来填这个坑</span></span><br><span class="line">        Comparable&lt;?<span class="keyword">super</span> K&gt; key = (Comparable&lt;?<span class="keyword">super</span> K&gt;)k;</span><br><span class="line">        Node currentNode = <span class="keyword">this</span>.root; <span class="comment">//用来保存待删除节点</span></span><br><span class="line">        Node parentNode = <span class="keyword">this</span>.root;  <span class="comment">//保存待删除节点的父节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftNode = <span class="keyword">true</span>;   <span class="comment">//左右节点判断</span></span><br><span class="line">        V oldValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找需要的节点(同时记录它的位置)</span></span><br><span class="line">        <span class="keyword">while</span> ( (currentNode != <span class="keyword">null</span>) &amp;&amp; (currentNode.key != key) ) &#123;</span><br><span class="line">            parentNode = currentNode;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(currentNode.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                currentNode = currentNode.left;</span><br><span class="line">                isLeftNode = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentNode = currentNode.right;</span><br><span class="line">                isLeftNode = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空树</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除的节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (currentNode.left == <span class="keyword">null</span>) &amp;&amp; (currentNode.right == <span class="keyword">null</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = parentNode.left.value;</span><br><span class="line">                parentNode.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = parentNode.right.value;</span><br><span class="line">                parentNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (currentNode.right == <span class="keyword">null</span>) &amp;&amp; (currentNode.left != <span class="keyword">null</span>) ) &#123;   <span class="comment">//删除节点只有左孩子(分情况看它挂到哪)</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = currentNode.left.value;</span><br><span class="line">                parentNode.left = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = currentNode.right.value;</span><br><span class="line">                parentNode.right = currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (currentNode.right != <span class="keyword">null</span>) &amp;&amp; (currentNode.left == <span class="keyword">null</span>) ) &#123;   <span class="comment">//删除节点只有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = parentNode.left.value;</span><br><span class="line">                parentNode.left = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = parentNode.right.value;</span><br><span class="line">                parentNode.right = currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//待删除节点既有左子树，又有右子树(思路:将待删除节点右子树的最小节点赋值给待删除节点)</span></span><br><span class="line">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class="line">            oldValue = directPostNode.value;</span><br><span class="line">            currentNode.key = directPostNode.key;</span><br><span class="line">            currentNode.value = directPostNode.value;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>得到待删除节点的直接后继节点：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getDirectPostNode</span><span class="params">(Node delNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Node parentNode = delNode;  <span class="comment">//用来保存待删除节点的（直接后继节点的父亲节点）</span></span><br><span class="line">     Node directNode = delNode;  <span class="comment">//用来保存待删除节点的（直接后继节点）</span></span><br><span class="line">     Node currentNode = delNode.right;   <span class="comment">// 待删除节点右子树</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">         parentNode = directNode;</span><br><span class="line">         directNode = currentNode;</span><br><span class="line">         currentNode = currentNode.left;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 直接删除此后继节点(因为不是直接相连的,最小的肯定是叶子节点或者没有左子树)</span></span><br><span class="line">     <span class="keyword">if</span> (directNode != delNode.right) &#123;</span><br><span class="line">         parentNode.left = directNode.right;</span><br><span class="line">         directNode.right = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> directNode;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体的可以看图：</strong></p>
<p><img src="http://images2015.cnblogs.com/blog/938494/201702/938494-20170209210350729-446211360.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89TreeMap/">数据结构思维笔记（十三）TreeMap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/TreeMap-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">TreeMap 二叉搜索树</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>这一章展示了<strong>二叉搜索树</strong>，它是个<code>Map</code>接口的高效实现。如果我们想让元素<strong>有序</strong>，它非常实用。</p>
</blockquote>
<br>

<h6 id="1-哈希的不足"><a href="#1-哈希的不足" class="headerlink" title="1.哈希的不足"></a>1.哈希的不足</h6><p><code>HashMap</code>被广泛使用，但并不是唯一的<code>Map</code>实现。有几个原因可能需要另一个实现：</p>
<ul>
<li><strong>哈希可能很慢</strong>，所以即使<code>HashMap</code>操作是常数时间，“常数”可能很大。 如果哈希函数将键均匀分配给子映射，效果很好。但设计良好的散列函数并不容易，如果太多的键在相同的子映射上，那么<code>HashMap</code>的性能可能会很差。</li>
<li><strong>哈希表中的键不以任何特定顺序存储</strong>；实际上，当表增长并且键被重新排列时，顺序可能会改变。对于某些应用程序，必须或至少保持键的顺序，这很有用。</li>
</ul>
<p>很难同时解决所有这些问题，但是 Java 提供了一个称为<code>TreeMap</code>的实现：</p>
<ul>
<li><strong>它不使用哈希函数</strong>，所以它避免了哈希的开销和选择哈希函数的困难。</li>
<li>在<code>TreeMap</code>之中，<strong>键被存储在二叉搜索树中</strong>，这使我们可以以线性时间顺序遍历键。</li>
<li>核心方法的<strong>运行时间与<code>log(n)</code>成正比</strong>，并不像常数时间那样好，但仍然非常好。</li>
</ul>
<p>下一节中，我将解释二进制搜索树如何工作，然后你将使用它来实现<code>Map</code>。</p>
<br>



<h6 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2.二叉搜索树"></a>2.二叉搜索树</h6><p>二叉搜索树（BST）是一个树，其中每个<code>node</code>（节点）包含一个键，并且每个都具有“BST 属性”：</p>
<ul>
<li>如果<code>node</code>有一个左子树，左子树中的所有键都必须小于<code>node</code>的键。</li>
<li>如果<code>node</code>有一个右子树，右子树中的所有键都必须大于<code>node</code>的键。</li>
</ul>
<p>二叉搜索树示例：</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/12-1.jpg" alt=""></p>
<p>在二叉搜索树中查找一个键是很快的，因为我们不必搜索整个树。从根节点开始，我们可以使用以下算法：</p>
<ul>
<li>将你要查找的键<code>target</code>，与当前节点的键进行比较。如果他们相等，你就完成了。</li>
<li>如果<code>target</code>小于当前键，搜索左子树。如果没有，<code>target</code>不在树上。</li>
<li>如果<code>target</code>大于当前键，搜索右子树。如果没有，<code>target</code>不在树上。</li>
</ul>
<p>在树的每一层，你只需要搜索一个子树。例如，如果你在上图中查找<code>target = 4</code>，则从根节点开始，它包含键<code>8</code>。因为<code>target</code>小于<code>8</code>，你走了左边。因为<code>target</code>大于<code>3</code>，你走了右边。因为<code>target</code>小于<code>6</code>，你走了左边。然后你找到你要找的键</p>
<p>现在你可能会看到这个规律。如果我们将树的层数从<code>1</code>数到<code>n</code>，第<code>i</code>层可以拥有多达<code>2^(n-1)</code>个节点。<code>h</code>层的树共有<code>2^h-1</code>个节点。如果我们有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span>^h - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们可以对两边取以<code>2</code>为底的对数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log2(n) ≈ h</span><br></pre></td></tr></table></figure>

<p>意思是树的高度正比于<code>logn</code>，<strong>如果它是满的(每一层包含最大数量的节点)</strong>，满二叉树。</p>
<br>



<h6 id="3-TreeMap结构"><a href="#3-TreeMap结构" class="headerlink" title="3.TreeMap结构"></a>3.TreeMap结构</h6><p>这里将要使用<strong>二叉搜索树</strong>编写<code>Map</code>接口的一个实现，这是开头结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTreeMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><code>size</code>追踪键的数量，<code>root</code>为根节点，下面是<code>Node</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Node right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们可以实现一些相对简单的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">       root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89HashMap/">数据结构思维笔记（十二）HashMap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/HashMap-%E6%91%8A%E9%94%80%E5%88%86%E6%9E%90/">HashMap 摊销分析</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>上一章中，我们写了一个使用哈希的<code>Map</code>接口的实现。我们期望这个版本更快，<strong>因为它搜索的列表较短，但增长顺序仍然是线性的（k太小，而且是固定的）</strong>。</p>
</blockquote>
<p>如果存在<code>n</code>个条目和<code>k</code>个子映射，则子映射的大小平均为<code>n/k</code>，这仍然与<code>n</code>成正比。但是，如果我们<strong>与<code>n</code>一起增加<code>k</code>，我们可以限制<code>n/k</code>的大小</strong>。<br>例如，<strong>假设每次<code>n</code>超过<code>k</code>的时候，我们都使<code>k</code>加倍；在这种情况下，每个映射的条目的平均数量将小于<code>1</code>，</strong>并且几乎总是小于<code>10</code>，只要<strong>散列函数能够很好地展开键</strong>。<br>如果<strong>每个子映射的条目数是不变的，我们可以在常数时间内搜索一个子映射</strong>。并且计算散列函数通常是常数时间（它可能取决于键的大小，但不取决于键的数量）。这使得<code>Map</code>的核心方法， <code>put</code>和<code>get</code>时间不变。</p>
<br>

<h6 id="1-MyHashMap"><a href="#1-MyHashMap" class="headerlink" title="1.MyHashMap"></a>1.MyHashMap</h6><p>在<code>MyHashMap.java</code>中，我提供了哈希表的大纲，它会按需增长。这里是定义的起始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">MyBetterMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常数FACTOR（称为负载因子）确定每个子映射的平均最大条目数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> FACTOR = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">super</span>.put(key,value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size()&gt; maps.size() * FACTOR) &#123;</span><br><span class="line">            rehash();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>MyHashMap</code>扩展了<code>MyBetterMap</code>，所以它继承了那里定义的方法。<strong>它覆盖的唯一方法是<code>put</code>，</strong>它调用了超类中的<code>put</code> – 也就是说，它调用了<code>MyBetterMap</code>中的<code>put</code>版本 – <strong>然后它检查它是否必须<code>rehash</code>。</strong>调用<code>size</code>返回总数量<code>n</code>。调用<code>maps.size</code>返回内嵌映射的数量<code>k</code>。</p>
<p><strong>常数<code>FACTOR</code>（称为负载因子）确定每个子映射的平均最大条目数。如果<code>n &gt; k * FACTOR</code>，这意味着<code>n/k &gt; FACTOR</code>，意味着每个子映射的条目数超过阈值，所以我们调用<code>rehash</code>。</strong></p>
<p>下面是给出的<code>rehash</code>方法（<strong>收集表中的条目，调整表的大小，然后重新放入条目</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    List&lt;MyLinearMap&lt;K,V&gt;&gt; oldMaps = maps;</span><br><span class="line">    makeMaps(maps.size()*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将旧的map放进去</span></span><br><span class="line">    <span class="keyword">for</span> (MyLinearMap&lt;K,V&gt; map: oldMaps) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.getEntries()) &#123;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<h6 id="2-分析HashMap"><a href="#2-分析HashMap" class="headerlink" title="2.分析HashMap"></a>2.分析HashMap</h6><p>如果<strong>最大子映射中的条目数</strong>(FACTOR)<strong>与<code>n/k</code>成正比</strong>，并且<code>k</code>与<code>n</code>成正比，那么多个核心方法就是常数时间的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> containsKey（Object target）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（target）; </span><br><span class="line">    <span class="keyword">return</span> map.containsKey（target）; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V get（Object key）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（key）; <span class="keyword">return</span> map.get（key）; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> V remove（Object key）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（key）; </span><br><span class="line">    <span class="keyword">return</span> map.remove（key）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个方法都计算键的哈希，这是常数时间，然后在一个子映射上调用一个方法，这个方法是常数时间的。<strong>（这些发方法总体上都是常数的）</strong></p>
<p>但另一个核心方法，<code>put</code>有点难分析。当我们<strong>不需要<code>rehash</code>时，它是常数时间</strong>，反之，它是线性的。这样同之前的<strong>摊销分析</strong>类似。</p>
<p>假设子映射的初始数量<code>k</code>为<code>2</code>，负载因子为<code>1</code>。<strong>现在我们来看看<code>put</code>一系列的键需要多少工作量</strong>。作为基本的“工作单位”，我们<strong>将计算对密钥哈希，并将其添加到子映射中的次数</strong>。</p>
<p>我们第一次调用<code>put</code>时，它需要<code>1</code>个工作单位。第二次也需要<code>1</code>个单位。第三次我们需要<code>rehash</code>，所以需要<code>2</code>个单位重新填充现有的键，和<code>1</code>个单位来对新键哈希。</p>
<p>现在哈希表的大小是<code>4</code>，所以下次调用<code>put</code>时 ，需要<code>1</code>个工作单位。但是下一次我们必须<code>rehash</code>，需要<code>4</code>个单位来<code>rehash</code>现有的键，和<code>1</code>个单位来对新键哈希。</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/11-1.jpg" alt=""></p>
<p>如图所示，<strong>对新键哈希的正常工作量在底部展示（计算哈希），额外工作量展示为塔楼</strong>(扩容部分)。</p>
<p>如箭头所示，如果我们把塔楼推倒，每个积木都会在下一个塔楼之前填满空间。结果似乎<code>2</code>个单位的均匀高度，这表明<code>put</code>的平均工作量约为<code>2</code>个单位。<strong>这意味着<code>put</code>平均是常数时间</strong>。</p>
<p>这个图还显示了，当我们<code>rehash</code>的时候，为什么加倍子映射数量<code>k</code>很重要。<strong>如果我们只是加上<code>k</code>而不是加倍，那么这些塔楼会靠的太近，他们会开始堆积。这样就不会是常数时间了</strong>。</p>
<br>



<h6 id="3-权衡"><a href="#3-权衡" class="headerlink" title="3.权衡"></a>3.权衡</h6><p>我们已经表明，<code>containsKey</code>，<code>get</code>和<code>remove</code>是常数时间，<code>put</code>平均为常数时间。我们应该花一点时间来欣赏它有多么出色。<strong>无论哈希表有多大，这些操作的性能几乎相同</strong>。</p>
<p>记住，我们的分析基于一个简单的计算模型，其中每个“工作单位”花费相同的时间量。真正的电脑比这更复杂。特别是，当处理足够小，适应高速缓存的数据结构时，它们通常最快；如果结构不适合高速缓存但仍适合内存，则稍慢一点；如果结构不适合在内存中，则非常慢。</p>
<p>这个实现的<strong>另一个限制是</strong>，<strong>如果我们得到了一个值而不是一个键时，那么散列是不会有帮助的</strong>：<code>containsValue</code>是线性的，因为它必须搜索所有的子映射。查找一个值并找到相应的键（或可能的键），没有特别有效的方式。</p>
<p>还有一个限制：<code>MyLinearMap</code>的<strong>一些常数时间的方法变成了线性的</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maps.size(); i++) &#123;</span><br><span class="line">        maps.get(i).clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clear</code>必须清除所有的子映射，子映射的数量与<code>n</code>成正比，所以它是线性的。幸运的是，这个操作并不常用，所以在大多数应用中，这种权衡是可以接受的。</p>
<br>



<h6 id="4-检查MyHashMap"><a href="#4-检查MyHashMap" class="headerlink" title="4.检查MyHashMap"></a>4.检查MyHashMap</h6><p>在我们继续之前，我们应该检查一下，<code>MyHashMap.put</code>是否真的是常数时间。</p>
<p>下面是测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileMyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> MyHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                map.put(String.format(<span class="string">"%10d"</span>,i),i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMillis = <span class="number">5000</span>;</span><br><span class="line">    runProfiler(<span class="string">"MyHashMap put"</span>, timeable, startN, endMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>, <span class="number">131</span></span><br><span class="line"><span class="number">2000</span>, <span class="number">366</span></span><br><span class="line"><span class="number">4000</span>, <span class="number">974</span></span><br><span class="line"><span class="number">8000</span>, <span class="number">3088</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">11760</span></span><br><span class="line">Estimated slope= <span class="number">1.6053112075356588</span></span><br></pre></td></tr></table></figure>

<p>可以发现，<strong>它的斜率为1.6左右，这表明这个实现不是一直都是常数的</strong>，检查一下问题出在哪里.</p>
<br>



<h6 id="5-修复MyHashMap"><a href="#5-修复MyHashMap" class="headerlink" title="5.修复MyHashMap"></a>5.修复MyHashMap</h6><p><code>MyHashMap</code>的问题是<code>size</code>，它继承自<code>MyBetterMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (MyLinearMap&lt;K, V&gt; map: maps) &#123;</span><br><span class="line">        total += map.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了累计整个大小，它必须迭代子映射。<strong>由于我们增加了子映射的数量<code>k</code>，随着条目数<code>n</code>增加，所以<code>k</code>与<code>n</code>成正比，所以<code>size</code>是线性的。</strong></p>
<p><strong><code>put</code>也是线性的</strong>，因为它使用<code>size</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    V oldValue = <span class="keyword">super</span>.put(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; maps.size() * FACTOR) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>size</code>是线性的，我们做的一切都浪费了。幸运的是，有一个简单的解决方案，我们以前看过：我们必须维护实例变量中的条目数，并且每当我们调用一个改变它的方法时更新它。（<strong>实时更新size</strong>）</p>
<p>下面是它的初始结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFixedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们不修改<code>MyHashMap</code>，我定义一个扩展它的新类。它添加一个新的实例变量<code>size</code>，它被初始化为零。</p>
<p>更新<code>remove</code>和<code>put</code>有点困难，因为当我们调用超类的该方法，我们不能得知子映射的大小是否改变。这是我的解决方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    size -= map.size();</span><br><span class="line">    V oldValue = map.remove(key);</span><br><span class="line">    size += map.size();</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove</code>使用<code>chooseMap</code>找到正确的子映射，然后减去子映射的大小。它会在子映射上调用<code>remove</code>，根据是否找到了键，它可以改变子映射的大小，也可能不会改变它的大小。但是无论哪种方式，<strong>我们将子映射的新大小加到<code>size</code>，所以最终的<code>size</code>值是正确的。</strong></p>
<p>新版的<code>put</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    size -= map.size();</span><br><span class="line">    V oldValue = map.put(key, value);</span><br><span class="line">    size += map.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; maps.size() * FACTOR) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我测量这个解决方案时，我发现放入<code>n</code>个键的总时间正比于<code>n</code>，也就是说，<strong>每个<code>put</code>是常数时间的</strong>，符合预期。</p>
<p>我们正常的去走下流程，<code>chooseMap</code>为常数时间，子映射的<code>push</code>为常数时间，<code>rehash</code>为常数时间，<strong>现在的<code>put</code>方法是常数时间，</strong>同之前对比，我们所作的改变主要体现在两个方面：</p>
<ul>
<li><strong>摊销分析</strong>，通过摊销分析，随着map变大，扩充哈希表，添加子映射摊销时间复杂度，通过加载因子控制每个子映射的数量</li>
<li><strong>实时更新Size</strong>，由于之前的摊销分析，增加了多个子映射，size()由原来的常数级变为线性级方法，我们实时维护更新它，使得它也变为常数级方法</li>
</ul>
<p>下面给出性能测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileMyFixedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> MyFixedHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                map.put(String.format(<span class="string">"%10d"</span>,i),i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMillis = <span class="number">1000</span>;</span><br><span class="line">    runProfiler(<span class="string">"MyHashMap put"</span>, timeable, startN, endMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试图：<br><img src="https://img-blog.csdnimg.cn/20190424102817217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8000</span>, <span class="number">243</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">288</span></span><br><span class="line"><span class="number">32000</span>, <span class="number">428</span></span><br><span class="line"><span class="number">64000</span>, <span class="number">615</span></span><br><span class="line"><span class="number">128000</span>, <span class="number">1281</span></span><br><span class="line">Estimated slope= <span class="number">0.5891002112256021</span></span><br></pre></td></tr></table></figure>
<br>



<h6 id="6-UML类图"><a href="#6-UML类图" class="headerlink" title="6.UML类图"></a>6.UML类图</h6><p>这里用 <a href="http://yuml.me/" target="_blank" rel="noopener">yUML</a> 生成<strong>UML类图</strong>，帮助我们梳理本章中的类</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/11-2.jpg" alt=""></p>
<p>不同的关系由不同的箭头表示：</p>
<ul>
<li>实心箭头表示 HAS-A 关系。例如，每个<code>MyBetterMap</code>实例包含多个<code>MyLinearMap</code>实例，因此它们通过实线箭头连接。</li>
<li>空心和实线箭头表示 IS-A 关系。例如，<code>MyHashMap</code>扩展 了<code>MyBetterMap</code>，因此它们通过 IS-A 箭头连接。</li>
<li>空心和虚线箭头表示一个类实现了一个接口;在这个图中，每个类都实现 <code>Map</code>。</li>
</ul>
<p><strong>UML 类图提供了一种简洁的方式，来表示大量类集合的信息。</strong>在设计阶段中，它们用于交流备选设计，在实施阶段中，用于维护项目的共享思维导图，并在部署过程中记录设计。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%93%88%E5%B8%8C/">数据结构思维笔记（十一）哈希</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%93%88%E5%B8%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">哈希 数据结构</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>在本章中，我定义了一个比<code>MyLinearMap</code>更好的<code>Map</code>接口实现，<code>MyBetterMap</code>，并引入哈希，这使得<code>MyBetterMap</code>效率更高。</p>
</blockquote>
<br>


<h6 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h6><p>为了提高<code>MyLinearMap</code>的性能，我们将编写一个新的类，它被称为<code>MyBetterMap</code>，它包含<code>MyLinearMap</code>对象的集合。<strong>它在内嵌的映射之间划分键，因此每个映射中的条目数量更小</strong>，这加快了<code>findEntry</code>，以及依赖于它的方法的速度。</p>
<p>类定义的开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBetterMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBetterMap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        makeMaps(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k值关系到hashCode的分配</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">makeMaps</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        maps = <span class="keyword">new</span> ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            maps.add(<span class="keyword">new</span> MyLinearMap&lt;K, V&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量<code>maps</code>是一组<code>MyLinearMap</code>对象。构造函数接受一个参数<code>k</code>，<strong>决定至少最开始，要使用多少个映射</strong>。然后<code>makeMaps</code>创建内嵌的映射并将其存储在一个<code>ArrayList</code>中。</p>
<p>现在，完成这项工作的关键是，<strong>我们需要一些方法来查看一个键，并决定应该进入哪个映射(首先要放进去，放到哪里用HashCode算法决定)</strong>。当我们<code>put</code>一个新的键时，我们选择一个映射；当我们<code>get</code>同样的键时，我们必须记住我们把它放在哪里(<strong>重点是要确定如何跟踪</strong>)。</p>
<p>一种可能性是<strong>随机选择一个子映射</strong>，并跟踪我们把每个键放在哪里(<strong>无法跟踪</strong>)。</p>
<p>一个更好的方法是<strong>使用一个哈希函数</strong>，它接受一个<code>Object</code>，一个任意的<code>Object</code>，并返回一个称为哈希码的整数。重要的是，<strong>如果它不止一次看到相同的<code>Object</code>，它总是返回相同的哈希码</strong>。这样，如果我们使用哈希码来存储键，当我们查找时，我们将得到相同的哈希码。</p>
<p>在Java中，每个<code>Object</code>都提供了<code>hashCode</code>，一种计算哈希函数的方法。<strong>这种方法的实现对于不同的对象是不同的</strong>；我们会很快看到一个例子。</p>
<p>选择到正确的子映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 为一个给定的键选择正确的子映射（同makeMaps的初始化数量有关）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 10:53 2019/4/23</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MyLinearMap&lt;K, V&gt; <span class="title">chooseMap</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123; </span><br><span class="line">        index = Math.abs(key.hashCode()) % maps.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maps.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>key</code>是<code>null</code>，我们选择索引为<code>0</code>的子映射。否则，我们使用<code>hashCode</code>获取一个整数，调用<code>Math.abs</code>来确保它是非负数，然后使用余数运算符<code>%</code>，<strong>这保证结果在<code>0</code>和<code>maps.size()-1</code>之间</strong>。<strong>所以<code>index</code>总是一个有效的<code>maps</code>索引</strong>。然后<code>chooseMap</code>返回为其所选的映射的引用。</p>
<p>我们使用<code>chooseMap</code>的<code>put</code>和<code>get</code>，所以<strong>当我们查询键的时候，我们得到添加时所选的相同映射，我们选择了相同的映射</strong>。至少应该是 - 稍后我会解释为什么这<strong>可能不起作用</strong>。</p>
<p><code>put</code>和<code>get</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>chooseMap</code>来找到正确的子映射，然后在子映射上调用一个方法，我们考虑一下性能.</p>
<p><strong>如果在<code>k</code>个子映射中分配了<code>n</code>个条目，则平均每个映射将有<code>n/k</code>个条目。当我们查找一个键时，我们必须计算其哈希码，这需要一些时间，然后我们搜索相应的子映射。</strong></p>
<p>因为<code>MyBetterMap</code>中的条目列表，比<code>MyLinearMap</code>中的短<code>k</code>倍，我们的预期是<code>ķ</code>倍的搜索速度。<strong>但运行时间仍然与<code>n</code>成正比(n/k)，所以<code>MyBetterMap</code>仍然是线性的</strong>。在下一个练习中，你将看到如何解决这个问题。</p>
<p>关于此问题的思考，现在考虑一种比较极端的情况，如果恰好所有数据都集中在一个子映射中，那么效率将跟线性方法一样.<br></p>
<br>

<h6 id="2-哈希如何工作"><a href="#2-哈希如何工作" class="headerlink" title="2.哈希如何工作"></a>2.哈希如何工作</h6><p>哈希函数的基本要求是，<strong>每次相同的对象应该产生相同的哈希码</strong>。对于不变的对象，这是比较容易的。对于具有可变状态的对象，我们必须花费更多精力。</p>
<p>作为一个不可变对象的例子，我将定义一个<code>SillyString</code>类，它包含一个<code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyString</span><span class="params">(String innerString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.innerString = innerString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用它来展示，一个类如何定义它自己的哈希函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;innerString.length(); i++) &#123;</span><br><span class="line">        total += innerString.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>SillyString</code>重写了<code>equals</code>和<code>hashCode</code>。这个很重要。为了正常工作，<code>equals</code>必须和<code>hashCode</code>一致，这意味着如果两个对象被认为是相等的 - 也就是说，<code>equals</code>返回<code>true</code> - 它们应该有相同的哈希码。<strong>但这个要求只是单向的；如果两个对象具有相同的哈希码，则它们不一定必须相等。</strong>（不可逆）</p>
<p><code>hashCode</code>的原理是，<strong>迭代<code>String</code>中的字符并将它们相加</strong>。当你向<code>int</code>添加一个字符时，Java 将使用其 Unicode 代码点，将字符转换为整数。</p>
<p>该哈希函数满足要求：<strong>如果两个<code>SillyString</code>对象包含相等的内嵌字符串，则它们将获得相同的哈希码。</strong></p>
<p>这可以正常工作，<strong>但它可能不会产生良好的性能，因为它为许多不同的字符串返回相同的哈希码</strong>。如果两个字符串以任何顺序包含相同的字母，它们将具有相同的哈希码。即使它们不包含相同的字母，它们可能会产生相同的总量，例如<code>&quot;ac&quot;</code>和<code>&quot;bb&quot;</code>。或者<code>abc</code>同<code>cab</code>的哈希码也是一致的</p>
<p><strong>如果许多对象具有相同的哈希码，它们将在同一个子映射中。如果一些子映射比其他映射有更多的条目，那么当我们有<code>k</code>个映射时，加速比可能远远小于<code>k</code>。</strong>所以哈希函数的<strong>目的之一是统一</strong>；也就是说，以相等的可能性，在这个范围内产生任何值。(<strong>等概率的在子映射中分配条目，这正是之前我们所担心的</strong>)</p>
<br>



<h6 id="3-哈希和可变性"><a href="#3-哈希和可变性" class="headerlink" title="3.哈希和可变性"></a>3.哈希和可变性</h6><p><code>String</code>是不可变的，<code>SillyString</code>也是不可变的，因为<code>innerString</code>定义为<code>final</code>。一旦你创建了一个<code>SillyString</code>，你不能使<code>innerString</code>引用不同的<code>String</code>，你不能修改所指向的<code>String</code>。因此，它将始终具有相同的哈希码。</p>
<p>我们现在用一个Array，和以上的一样，改变的是之前是String,现在是数组(<strong>可变</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyArray</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            total += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>SillyArray</code>也提供<code>setChar</code>，它能够修改修改数组内的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.array[i] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设我们创建了一个<code>SillyArray</code>，并将其添加到<code>map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SillyArray array1 = <span class="keyword">new</span> SillyArray(<span class="string">"Word1"</span>.toCharArray());</span><br><span class="line">map.put(array1, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这个数组的哈希码是<code>461</code>。现在如果我们修改了数组内容，之后尝试查询它，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1.setChar(<span class="number">0</span>, <span class="string">'C'</span>);</span><br><span class="line">Integer value = map.get(array1);</span><br></pre></td></tr></table></figure>

<p>修改之后的哈希码是<code>441</code>。<strong>使用不同的哈希码，我们就很可能进入了错误的子映射</strong>。这就很糟糕了。</p>
<p><strong>一般来说，使用可变对象作为散列数据结构中的键是很危险的</strong>，这包括<code>MyBetterMap</code>和<code>HashMap</code>。如果你可以<strong>保证映射中的键不被修改，或者任何更改都不会影响哈希码</strong>，那么这可能是正确的。但是避免这样做可能是一个好主意。（个人认为还是直接避免这种不安全的操作比较好）</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89Map%E6%8E%A5%E5%8F%A3/">数据结构思维笔记（十）Map接口</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E7%BA%BF%E6%80%A7Map-Map%E6%8E%A5%E5%8F%A3/">线性Map Map接口</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>在接下来的几个练习中，我介绍了<code>Map</code>接口的几个实现。其中一个基于哈希表，这可以说是所发明的最神奇的数据结构。另一个是类似的<code>TreeMap</code>，不是很神奇，但它有附加功能，它可以按顺序迭代元素。</p>
<p>我们从一个<code>Map</code>开始，它使用键值对的<code>List</code>实现。</p>
</blockquote>
<br>


<h6 id="1-实现MyLinearMap"><a href="#1-实现MyLinearMap" class="headerlink" title="1.实现MyLinearMap"></a>1.实现MyLinearMap</h6><p>简单来说，就是继承Map,放入List中,来看下初始结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinearMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; entries = <span class="keyword">new</span> ArrayList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure>

<p><code>MyLinearMap</code>对象具有单个实例变量，<code>entries</code>，这是一个<code>Entry</code>的<code>ArrayList</code>对象。每个<code>Entry</code>都包含一个键值对。这里是定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>



<h6 id="2-分析MyLinearMap"><a href="#2-分析MyLinearMap" class="headerlink" title="2.分析MyLinearMap"></a>2.分析MyLinearMap</h6><p>两个私有方法<code>FindEntry</code>用于根据key值，找到对应的实体，<code>equal</code>用于比较，下边是实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">findEntry</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry entry: entries) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equals(target, entry.getKey())) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object target, Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.equals(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals</code>运行时间取决于值的大小，跟数目无关，<strong>是常数时间O(1)</strong>.</p>
<p><code>findEntry</code>运行时间取决于数目，最好的情况下，可以一开始就找到，但是平均下来的话，仍要遍历整个map,是线性时间，<strong>时间复杂度为O(n)</strong>.</p>
<p>大部分的<code>MyLinearMap</code>核心方法使用<code>findEntry</code>，包括<code>put</code>，<code>get</code>，和<code>remove</code>。这就是他们的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entries.add(<span class="keyword">new</span> Entry(key, value));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V oldValue = entry.getValue();</span><br><span class="line">        entry.setValue(value);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V value = entry.getValue();</span><br><span class="line">        entries.remove(entry);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法中，调用<code>findEntry</code>是线性时间，其余操作都为常数时间，<strong>所以总的时间复杂度为线性时间</strong>。</p>
<p>总而言之，核心方法都是线性的，这就是为什么我们将这个实现称为<code>MyLinearMap</code></p>
<p><strong>如果我们知道输入的数量很少，这个实现可能会很好（很好的原因就是，数目少了有更大机率查找为常数时间）</strong>，但是我们可以做得更好。<strong>实际上，<code>Map</code>所有的核心方法都是常数时间的实现</strong>。当你第一次听到这个消息时，可能似乎觉得不可能。实际上我们所说的是，你可以在常数时间内大海捞针，不管海有多大。这是魔法。</p>
<p>我们不是将条目存储在一个大的<code>List</code>中，<strong>而是把它们分解成许多短的列表（这样查找时就为常数时间）</strong>。对于每个键，我们将使用哈希码（在下一节中进行说明）来确定要使用的列表。 使用大量的简短列表比仅仅使用一个更快，但正如我将解释的，它不会改变增长级别；核心功能仍然是线性的。但还有一个技巧：<strong>如果我们增加列表的数量来限制每个列表的条目数，就会得到一个恒定时间的映射</strong>。你会在下一个练习中看到细节，但是首先要了解哈希！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B4%A2%E5%BC%95%E5%99%A8/">数据结构思维笔记（九）索引器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E7%B4%A2%E5%BC%95%E5%99%A8/">搜索引擎 索引器</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>目前，我们构建了一个基本的 Web 爬虫；我们下一步将是索引。在网页搜索的上下文中，<strong>索引是一种数据结构，可以查找检索词并找到该词出现的页面</strong>。此外，我们想知道每个页面上显示检索词的次数，这将有助于确定与该词最相关的页面。</p>
<p>例如，如果用户提交检索词“Java”和“编程”，我们将查找两个检索词并获得两组页面。带有“Java”的页面将包括 Java 岛屿，咖啡昵称以及编程语言的网页。具有“编程”一词的页面将包括不同编程语言的页面，以及该单词的其他用途。通过选择具有两个检索词的页面，我们希望消除不相关的页面，并找到 Java 编程的页面。现在我们了解索引是什么，它执行什么操作，我们可以设计一个数据结构来表示它</p>
</blockquote>
<h6 id="1-数据结构选取"><a href="#1-数据结构选取" class="headerlink" title="1.数据结构选取"></a>1.数据结构选取</h6><p>索引的基本操作是查找；具体来说，我们需要能够查找检索词并找到包含它的所有页面。最简单的实现将是页面的集合。给定一个检索词，我们可以遍历页面的内容，并选择包含检索词的内容。但运行时间与所有页面上的总字数成正比，这太慢了(最简单的思路就这样)。</p>
<p>一个更好的选择是一个映射（<code>字典</code>），它是一个数据结构，表示键值对的集合，并提供了一种方法，快速查找键以及相应值。例如，我们将要构建的第一个映射是<code>TermCounter</code>，<strong>它将每个检索词映射为页面中出现的次数。键是检索词，值是计数（也称为“频率”）</strong>。</p>
<p>Java 提供了<code>Map</code>的调用接口，它指定映射应该提供的方法；最重要的是：</p>
<ul>
<li><code>get(key)</code>：此方法查找一个键并返回相应的值。</li>
<li><code>put(key, value)</code>：该方法向<code>Map</code>添加一个新的键值对，或者如果该键已经在映射中，它将替换与<code>key</code>关联的值。</li>
</ul>
<p>除了检索词到计数的映射<code>TermCounter</code>之外，我们将定义一个被称为<code>Index</code>的类，<strong>它将检索词映射为出现的页面的集合</strong>。而这又引发了下一个问题，即如何表示页面集合。同样，如果我们考虑我们想要执行的操作，它们就指导了我们的决定。</p>
<p><strong>在这种情况下，我们需要组合两个或多个集合，并找到所有这些集合中显示的页面</strong>（敲黑板，也就是需要找到包含并集的页面）。你可以将此操作看做集合的交集：两个集合的交集是出现在两者中的一组元素。</p>
<p>你可能猜到了，Java 提供了一个<code>Set</code>接口，来定义集合应该执行的操作。它实际上并不提供设置交集，但它提供了方法，使我们能够有效地实现交集和其他结合操作。核心的<code>Set</code>方法是：</p>
<ul>
<li><code>add(element)</code>：该方法将一个元素添加到集合中；如果元素已经在集合中，则它不起作用。</li>
<li><code>contains(element)</code>：该方法检查给定元素是否在集合中。</li>
</ul>
<p>现在我们自顶向下设计了我们的数据结构，我们将从内到外实现它们，从<code>TermCounter</code>开始。<br><br></p>
<h6 id="2-TermCounter"><a href="#2-TermCounter" class="headerlink" title="2.TermCounter"></a>2.<code>TermCounter</code></h6><p><code>TermCounter</code>是一个类，表示检索词到页面中出现次数的映射。这是类定义的第一部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TermCounter</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量<code>map</code>包含检索词到计数的映射（这里使用HashMap），并且<code>label</code>标识检索词的来源文档；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String term, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    map.put(term, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Integer count = map.get(term);</span><br><span class="line">    <span class="keyword">return</span> count == <span class="keyword">null</span> ? <span class="number">0</span> : count;   <span class="comment">//没有就返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTermCount</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    put(term, get(term) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>帮助索引网页的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElements</span><span class="params">(Elements paragraphs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node node: paragraphs) &#123;</span><br><span class="line">           processTree(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node node: <span class="keyword">new</span> WikiNodeIterable(root)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">               processText(((TextNode) node).text());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 用空格替换标点符号，转换为小写，并以空格为分隔符</span></span><br><span class="line">       String[] array = text.replaceAll(<span class="string">"\\pP|\\pS"</span>,<span class="string">" "</span>)</span><br><span class="line">                           .toLowerCase()</span><br><span class="line">                           .split(<span class="string">"\\s+"</span>);</span><br><span class="line">       <span class="keyword">for</span> (String term : array) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!term.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">               incrementTermCount(term);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别强调，这里还要去除””,否则结果会显示计数</strong></p>
<p><code>测试用例</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line">WikiFetcher wf = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line">Elements para = wf.fetchWikiPedia(url);</span><br><span class="line"></span><br><span class="line">TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">tc.processElements(para);</span><br><span class="line">tc.printCounts();</span><br></pre></td></tr></table></figure>

<p><code>部分测试结果(截取底部数据)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command,<span class="number">2</span></span><br><span class="line">performance,<span class="number">4</span></span><br><span class="line"><span class="keyword">boolean</span>,<span class="number">1</span></span><br><span class="line">currently,<span class="number">1</span></span><br><span class="line">compliance,<span class="number">1</span></span><br><span class="line">response,<span class="number">1</span></span><br><span class="line">variable,<span class="number">2</span></span><br><span class="line">arguments,<span class="number">3</span></span><br><span class="line">Total of counts:<span class="number">4020</span></span><br></pre></td></tr></table></figure>

<br>



<h6 id="3-Index类的实现"><a href="#3-Index类的实现" class="headerlink" title="3.Index类的实现"></a>3.Index类的实现</h6><p>这个类的主要目的是实现：<strong>实例变量<code>index</code>是每个检索词到一组<code>TermCounter</code>对象的映射。每个<code>TermCounter</code>表示检索词出现的页面。</strong></p>
<p>这是它的基础结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Set&lt;TermCounter&gt;&gt; index = </span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String term, TermCounter tc)</span> </span>&#123;</span><br><span class="line">        Set&lt;TermCounter&gt; set = get(term);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we're seeing a term for the first time, make a new Set</span></span><br><span class="line">        <span class="keyword">if</span> (set == <span class="keyword">null</span>) &#123;</span><br><span class="line">            set = <span class="keyword">new</span> HashSet&lt;TermCounter&gt;();</span><br><span class="line">            index.put(term, set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise we can modify an existing Set</span></span><br><span class="line">        set.add(tc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;TermCounter&gt; <span class="title">get</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index.get(term);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>add</code>方法向集合添加新的<code>TermCounter</code>，它与检索词关联。当我们索引一个尚未出现的检索词时，我们必须创建一个新的集合。否则我们可以添加一个新的元素到一个现有的集合。在这种情况下，<code>set.add</code>修改位于<code>index</code>里面的集合，但不会修改<code>index</code>本身。  <strong>我们唯一修改<code>index</code>的时候是添加一个新的检索词</strong></p>
<p>这种数据结构比较复杂。回顾一下，<code>Index</code>包含<code>Map</code>，将每个检索词映射到<code>TermCounter</code>对象的<code>Set</code>，每个<code>TermCounter</code>包含一个<code>Map</code>，<strong>将检索词映射到计数</strong>（这是值得一提的部分）。</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/8-1.jpg" alt=""></p>
<p><code>printIndex</code>方法展示了如何解压缩此数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String term: index.keySet()) &#123;</span><br><span class="line">            System.out.println(term);</span><br><span class="line"></span><br><span class="line">            Set&lt;TermCounter&gt; tcs = get(term);</span><br><span class="line">            <span class="keyword">for</span> (TermCounter tc: tcs) &#123;</span><br><span class="line">                Integer count = tc.get(term);</span><br><span class="line">                System.out.println(tc.getLabel()+ <span class="string">"   "</span>+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>外层循环遍历检索词。内层循环迭代<code>TermCounter</code>对象。</strong></p>
<p><code>indexPage</code>统计页面中的检索词:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexPage</span><span class="params">(String url, Elements paragraphs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  生成一个 TermCounter 并统计段落中的检索词</span></span><br><span class="line">       TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">       tc.processElements(paragraphs);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 对于 TermCounter 中的每个检索词，将 TermCounter 添加到索引</span></span><br><span class="line">       <span class="keyword">for</span> (String term: tc.keySet()) &#123;</span><br><span class="line">           add(term,tc);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>测试</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WikiFetcher wikiFetcher = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line">Index indexer = <span class="keyword">new</span> Index();</span><br><span class="line"></span><br><span class="line">String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line">Elements paragraphs = wikiFetcher.fetchWikiPedia(url);</span><br><span class="line">indexer.indexPage(url,paragraphs);</span><br><span class="line"></span><br><span class="line">String url1 = <span class="string">"https://en.wikipedia.org/wiki/Programming_language"</span>;</span><br><span class="line">Elements paragraphs1 = wikiFetcher.fetchWikiPedia(url);</span><br><span class="line">indexer.indexPage(url1,paragraphs1);</span><br><span class="line"></span><br><span class="line">indexer.printIndex();</span><br></pre></td></tr></table></figure>

<p><code>部分测试结果</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   1</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   1</span></span><br><span class="line">variable</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   2</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   2</span></span><br><span class="line">arguments</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   3</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   3</span></span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%B0%E8%BE%BE%E5%93%B2%E5%AD%A6/">数据结构思维笔记（八）到达哲学</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E5%88%B0%E8%BE%BE%E5%93%B2%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">到达哲学 数据结构思维</a></span><div class="content"><a id="more"></a>

<blockquote>
<p>本章的目标是开发一个Web爬虫，同时验证之前提到的 <code>到达哲学</code> </p>
</blockquote>
<h6 id="1-起步"><a href="#1-起步" class="headerlink" title="1.起步"></a>1.起步</h6><p>首先介绍本章中帮你起步的代码：</p>
<ul>
<li><code>WikiNodeExample.java</code>包含前一章的代码，展示了 DOM 树中深度优先搜索（DFS）的递归和迭代实现。</li>
<li><code>WikiNodeIterable.java</code>包含<code>Iterable</code>类，用于遍历 DOM 树。我将在下一节中解释这段代码。</li>
<li><code>WikiFetcher.java</code>包含一个工具类，使用<code>jsoup</code>从维基百科下载页面。为了帮助你遵守维基百科的服务条款，此类限制了你下载页面的速度；如果你每秒请求许多页，在下载下一页之前会休眠一段时间。</li>
<li><code>WikiPhilosophy.java</code>包含你为此练习编写的代码的大纲。我们将在下面进行说明。</li>
</ul>
<br>



<h6 id="2-可迭代对象和迭代器"><a href="#2-可迭代对象和迭代器" class="headerlink" title="2.可迭代对象和迭代器"></a>2.可迭代对象和迭代器</h6><p>在前一章中，我展示了迭代式深度优先搜索（DFS），并且认为与递归版本相比， <strong>迭代版本的优点</strong>在于， <strong>它更容易包装在<code>Iterator</code>对象中（Iterable是一种数据结构，Iterator是用来迭代的迭代器）</strong>。在本节中，我们将看到如何实现它。</p>
<p><strong>外层的类<code>WikiNodeIterable</code>实现<code>Iterable&lt;Node&gt;</code>接口，所以我们可以在一个<code>for</code>循环中使用它：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node root = ...</span><br><span class="line">Iterable&lt;Node&gt; iter = <span class="keyword">new</span> WikiNodeIterable(root);</span><br><span class="line"><span class="keyword">for</span> (Node node: iter) &#123;</span><br><span class="line">    visit(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 root为树的根节点，visit() 是到Node节点时，你想做的任意的事.</p>
<p><code>WikiNodeIterable</code>的实现遵循以下惯例：</p>
<ul>
<li>构造函数接受并存储根<code>Node</code>的引用。</li>
<li><code>iterator</code>方法创建一个返回一个<code>Iterator</code>对象。</li>
</ul>
<p>下边是它的样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiNodeIterable</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从给定的节点开始创造一个迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiNodeIterable</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Node&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WikiNodeIterator(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类  <code>WikiNodeIterator</code>，<strong>执行所有实际工作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Iterator的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiNodeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个堆栈跟踪等待访问的节点</span></span><br><span class="line">    Deque&lt;Node&gt;  stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用堆栈上的根节点初始化Iterator。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiNodeIterator</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        <span class="comment">// 反转后将child节点放入堆栈中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;(node.childNodes());</span><br><span class="line">        Collections.reverse(nodes);</span><br><span class="line">        <span class="keyword">for</span> (Node child : nodes) &#123;</span><br><span class="line">            stack.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码与 DFS 的迭代版本几乎相同(<strong>DFS是写在一块的</strong>)，但现在分为三个方法：</p>
<ul>
<li>构造函数初始化栈（使用一个<code>ArrayDeque</code>实现）并将根节点压入这个栈。</li>
<li><code>isEmpty</code>检查栈是否为空。</li>
<li><code>next</code>从<code>Node</code>栈中弹出下一个节点，按相反的顺序压入子节点，并返回弹出的<code>Node</code>。如果有人在空<code>Iterator</code>上调用<code>next</code>，则会抛出异常。</li>
</ul>
<p>可能不明显的是，值得使用两个类和五个方法，来重写一个完美的方法。但是现在我们已经完成了，在需要<code>Iterable</code>的任何地方，我们可以使用<code>WikiNodeIterable</code>，这使得它的语法整洁，易于将迭代逻辑（DFS）与我们对节点的处理分开。<br><br></p>
<h6 id="3-WikiFetcher"><a href="#3-WikiFetcher" class="headerlink" title="3.WikiFetcher"></a>3.<code>WikiFetcher</code></h6><p>编写 Web 爬虫时，很容易下载太多页面，这<strong>可能会违反你要下载的服务器的服务条款</strong>。为了帮助你避免这种情况，我提供了一个<code>WikiFetcher</code>类，它可以做两件事情:</p>
<ul>
<li>它封装了我们在上一章中介绍的代码，用于从维基百科下载页面，<strong>解析 HTML 以及选择内容文本</strong>。</li>
<li>它测量请求之间的时间，如果我们在请求之间没有足够的时间，它将休眠直到经过了合理的间隔。默认情况下，间隔为<code>1</code>秒（<strong>防止过度请求</strong>）。</li>
</ul>
<p>这里是<code>WikiFetcher</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiFetcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRequestTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minIterval = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  找到并解析数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 10:15 2019/4/16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Elements <span class="title">fetchWikiPedia</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sleepIfNeed();</span><br><span class="line">        Connection connection = Jsoup.connect(url);</span><br><span class="line">        Document doc = connection.get();</span><br><span class="line">        Element content = doc.getElementById(<span class="string">"mw-content-text"</span>);</span><br><span class="line">        Elements para = content.select(<span class="string">"p"</span>);</span><br><span class="line">        <span class="keyword">return</span> para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过最小访问时间来限制范围访问频率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 10:43 2019/4/16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepIfNeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRequestTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> nextRequestTime = lastRequestTime + minIterval;</span><br><span class="line">            <span class="keyword">if</span> (currentTime &lt; lastRequestTime) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(nextRequestTime - currentTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Warning: sleep interrupted in fetchWikipedia."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastRequestTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的代码是<code>sleepIfNeeded</code>，它检查自上次请求以来的时间，如果经过的时间小于<code>minInterval</code>（毫秒），则休眠。<br><br></p>
<h6 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h6><p>在<code>WikiPhilosophy.java</code>中，你会发现一个简单的<code>main</code>方法，展示了如何使用这些部分。从这个代码开始，你的工作是写一个爬虫：</p>
<ol>
<li>获取维基百科页面的 URL，下载并分析。</li>
<li>它应该<strong>遍历所得到的 DOM 树来找到第一个 有效的链接</strong>。我会在下面解释“有效”的含义。</li>
<li>如果页面没有链接，或者如果第一个链接是我们已经看到的页面，程序应该指示失败并退出。</li>
<li>如果链接匹配维基百科页面上的哲学网址，程序应该提示成功并退出。</li>
<li>否则应该回到步骤<code>1</code>。</li>
</ol>
<p>该程序应该为它访问的 URL 构建<code>List</code>，<strong>并在结束时显示结果（无论成功还是失败）</strong>。</p>
<p><code>那么我们应该认为什么是“有效的”链接？</code></p>
<ul>
<li>这个链接<strong>应该在页面的内容文本中</strong>，而不是侧栏或弹出框。</li>
<li>它<strong>不应该是斜体或括号</strong>。</li>
<li>你应该<strong>跳过外部链接</strong>，当前页面的链接和红色链接。</li>
<li>在某些版本中，如果文本以大写字母开头，则应跳过链接。</li>
</ul>
<p><code>如果你有足够的信息来起步，请继续。或者你可能想要阅读这些提示：</code></p>
<ul>
<li>当你遍历树的时候，你将需要处理的两种<code>Node</code>是<code>TextNode</code>和<code>Element</code>。如果你找到一个<code>Element</code>，你可能需要转换它的类型，来访问标签和其他信息。</li>
<li>当你<strong>找到包含链接的<code>Element</code>时</strong>，<strong>通过向上跟踪父节点链，可以检查是否是斜体</strong>。如果父节点链中有一个<code>&lt;i&gt;</code>或<code>&lt;em&gt;</code>标签，链接为斜体。</li>
<li>为了检查链接是否在括号中，你必须在遍历树时扫描文本，并跟踪开启和闭合括号（理想情况下，你的解决方案应该能够处理嵌套括号（像这样））。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/blog/2019/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%20%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">数据结构思维笔记（七） 树的遍历</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/blog/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-DFS/">树的遍历 DFS</a></span><div class="content"><a id="more"></a>


<blockquote>
<p>本章将介绍一个 Web 搜索引擎，我们将在本书其余部分开发它。我描述了搜索引擎的元素，并介绍了第一个应用程序，一个从<strong>维基百科下载和解析页面的 Web 爬行器</strong>。本章还介绍了<strong>深度优先搜索的递归实现</strong>，以及迭代实现，它使用 Java <code>Deque</code>实现“后入先出”的栈。</p>
</blockquote>
<h6 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1.搜索引擎"></a>1.搜索引擎</h6><p>网络搜索引擎，像谷歌搜索或 Bing，接受一组“检索项”，并返回一个网页列表，它们和这些项相关。</p>
<p><strong>搜索引擎的基本组成部分是</strong>：</p>
<ul>
<li><strong>抓取</strong>：我们需要一个程序，可以下载网页，解析它，并提取文本和任何其他页面的链接。 </li>
<li><strong>索引</strong>：我们需要一个数据结构，可以查找一个检索项，并找到包含它的页面。</li>
<li><strong>检索：</strong>我们需要一种方法，从索引中收集结果，并识别与检索项最相关的页面。</li>
</ul>
<p>我们以爬虫开始。<strong>爬虫的目标是查找和下载一组网页</strong>。对于像 Google 和 Bing 这样的搜索引擎，目标是查找所有网页，但爬虫通常仅限于较小的域。在我们的例子中，我们只会读取维基百科的页面。</p>
<p>作为第一步，我们将构建一个读取维基百科页面的爬虫，找到第一个链接，并跟着链接来到另一个页面，然后重复。我们将使用这个爬虫来测试“到达哲学”的猜想，它是：</p>
<blockquote>
<p>点击维基百科文章正文中的第一个小写的链接，然后对后续文章重复这个过程，通常最终会到达“哲学”的文章。</p>
</blockquote>
<p>在几个章节之内，我们将处理索引器，然后我们将到达检索器.<br><br></p>
<h6 id="2-解析HTML"><a href="#2-解析HTML" class="headerlink" title="2.解析HTML"></a>2.解析HTML</h6><p>下载网页时，内容使用HTML编写。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们的爬虫下载页面时，它需要解析 HTML，以便提取文本并找到链接。为此，我们将使用<code>jsoup</code>，<strong>它是一个下载和解析 HTML 的开源 Java 库</strong>。</p>
<p><strong>解析 HTML 的结果是文档对象模型（DOM）树</strong>，其中包含文档的元素，包括文本和标签。树是由节点组成的链接数据结构；节点表示文本，标签和其他文档元素.</p>
<p>节点之间的关系由文档的结构决定。在上面的例子中，第一个节点称为根，是<code>&lt;html&gt;</code>标签，它包含指向所包含两个节点的链接， <code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>；这些节点是根节点的子节点。</p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/6-1.jpg" alt=""></p>
<h6 id="3-使用jsoup"><a href="#3-使用jsoup" class="headerlink" title="3.使用jsoup"></a>3.使用jsoup</h6><p><code>jsoup</code>非常易于下载，和解析 Web 页面，以及访问 DOM 树。这里是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载并解析元素</span></span><br><span class="line">    Connection connection = Jsoup.connect(url);</span><br><span class="line">    Document doc = connection.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择内容，并解析初其中所有的段落</span></span><br><span class="line">    Element content = doc.getElementById(<span class="string">"mw-content-text"</span>);</span><br><span class="line">    Elements paragraphs = content.select(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Element xx : paragraphs) &#123;</span><br><span class="line">        System.out.println(xx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Jsoup.connect</code>接受<code>String</code>形式的<code>url</code>，并连接 Web 服务器。get<code>方法下载 HTML，解析，并返回</code>Document`对象，他表示 DOM。</p>
<p><code>Document</code>提供了导航树和选择节点的方法,这里主要展示了两种：</p>
<ul>
<li><code>getElementById</code>获取某个标签下的所有内容</li>
<li><code>select</code>可对获取的内容进行遍历，选择初想要的元素的集合(支持css选择器)</li>
</ul>
<p><code>Node</code>表示 DOM 树中的一个节点；有几个扩展<code>Node</code>的子类，其中包括 <code>Element</code>，<code>TextNode</code>，<code>DataNode</code>，和<code>Comment</code>。<code>Elements</code>是<code>Element</code>对象的<code>Collection</code></p>
<p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/6-3.jpg" alt=""></p>
<br>



<h6 id="4-遍历HTML"><a href="#4-遍历HTML" class="headerlink" title="4.遍历HTML"></a>4.遍历HTML</h6><p>为了使你变得更轻松，这里提供了一个<code>WikiNodeIterable</code>类，可以让你遍历 DOM 树中的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Elements paragraphs = content.select(<span class="string">"p"</span>);</span><br><span class="line">Element firstPara = paragraphs.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Iterable&lt;Node&gt; iter = <span class="keyword">new</span> WikiNodeIterable(firstPara);</span><br><span class="line"><span class="keyword">for</span> (Node node: iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">        System.out.print(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子紧接着上一个例子。它选择<code>paragraphs</code>中的第一个段落，然后创建一个<code>WikiNodeIterable</code>，它实现<code>Iterable&lt;Node&gt;</code>。<code>WikiNodeIterable</code>执行“<strong>深度优先搜索</strong>”，<strong>它按照它们将出现在页面上的顺序产生节点</strong>(这个是创造它的目的)。</p>
<p>在这个例子中，仅当<code>Node</code>是<code>TextNode</code>时，我们打印它，并忽略其他类型的<code>Node</code>，特别是代表标签的<code>Element</code>对象。结果是没有任何标记的 HTML 段落的纯文本。<br><br></p>
<h6 id="5-深度优先搜索"><a href="#5-深度优先搜索" class="headerlink" title="5.深度优先搜索"></a>5.深度优先搜索</h6><p>有几种方式可以合理地遍历一个树，每个都有不同的应用。我们从<strong>深度优先搜索（DFS</strong>）开始。DFS 从树的根节点开始，并选择第一个子节点。如果子节点有子节点，则再次选择第一个子节点。当它到达没有子节点的节点时，它回溯，沿树向上移动到父节点，在那里它选择下一个子节点，如果有的话；否则它会再次回溯。当它探索了根节点的最后一个子节点，就完成了(<strong>跟之前思维导图遍历节点一样</strong>)。</p>
<p>有两种常用的方式来实现 DFS，递归和迭代。</p>
<p>递归（代码简洁）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveDFS</span> <span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">           System.out.println(node);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Node child : node.childNodes()) &#123;</span><br><span class="line">           recursiveDFS(child);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法对树中的每一个<code>Node</code>调用，从根节点开始。如果<code>Node</code>是一个<code>TextNode</code>，它打印其内容。如果<code>Node</code>有任何子节点，它会按顺序在每一个子节点上调用<code>recursiveDFS</code>（<strong>前序遍历</strong>）。</p>
<p>通过进行递归调用，<code>recursiveDFS</code>使用<strong>调用栈来跟踪子节点并以正确的顺序处理它们</strong>。作为替代，我们可以使用栈数据结构自己跟踪节点；如果我们这样做，我们可以<strong>避免递归并迭代遍历树</strong>（非递归的好处）。<br><br></p>
<h6 id="6-Java中的栈"><a href="#6-Java中的栈" class="headerlink" title="6.Java中的栈"></a>6.Java中的栈</h6><p>在我解释 DFS 的迭代版本之前，我将解释栈数据结构。我们将从栈的一般概念开始，我将使用小写<code>s</code>指代“栈”。然后我们将讨论两个 Java<code>接口</code>，它们定义了栈的方法：<code>Stack</code>和<code>Deque</code>。</p>
<p>栈是与列表类似的数据结构：<strong>它是维护元素顺序的集合</strong>。栈和列表之间的主要区别是栈<strong>提供的方法较少</strong>。在通常的惯例中，它提供：</p>
<ul>
<li><p><code>push</code>：它将一个元素添加到栈顶。</p>
</li>
<li><p><code>pop</code>：它从栈中删除并返回最顶部的元素。</p>
</li>
<li><p><code>peek</code>：它返回最顶部的元素而不修改栈。 </p>
</li>
<li><p><code>isEmpty</code>：表示栈是否为空。</p>
<p>因为<code>pop</code>总是返回最顶部的元素，栈也称为 LIFO，代表“后入先出”。栈的替代品是“队列”，它返回的元素顺序和添加顺序相同；即“先入先出（FIFO）。</p>
</li>
</ul>
<p><strong>为什么栈和队列是有用的</strong>，可能不是很明显：它们不提供任何列表没有的功能；实际上它们提供的功能更少。那么为什么不使用列表的一切？有两个原因：</p>
<ul>
<li>如果你将自己限制于一小部分方法 - 也就是小型 API - <strong>你的代码将更加易读，更不容易出错</strong>。例如，如果使用列表来表示栈，则可能会以错误的顺序删除元素。使用栈 API，这种错误在字面上是不可能的。避免错误的最佳方法是使它们不可能(<strong>小型API可以给到很多限制，大型的兼容性强</strong>)。</li>
<li>如果一个数据结构提供了小型 API，那么它<strong>更容易实现</strong>。例如，实现栈的简单方法是单链表。当我们压入一个元素时，我们将它添加到列表的开头；当我们弹出一个元素时，我们在开头删除它。对于链表，在开头添加和删除是常数时间的操作，因此这个实现是高效的。相反，大型 API 更难实现高效。</li>
</ul>
<p>为了<strong>在 Java 中实现栈</strong>，你有三个选项：</p>
<ul>
<li>继续使用<code>ArrayList</code>或<code>LinkedList</code>。如果使用<code>ArrayList</code>，请务必从最后添加和删除，这是一个常数时间的操作。并且小心不要在错误的地方添加元素，或以错误的顺序删除它们。</li>
<li>Java 提供了一个<code>Stack</code>类，它提供了一组标准的栈方法。但是这个类是 Java 的一个旧部分：它与 Java 集合框架不兼容，后者之后才出现。</li>
<li>最<strong>好的选择可能是使用<code>Deque</code>接口的一个实现</strong>，如<code>ArrayDeque</code>。</li>
</ul>
<p><code>Deque</code>代表“<strong>双向队列</strong>”；在 Java 中， <code>Deque</code>接口提供<code>push</code>，<code>pop</code>，<code>peek</code>和<code>isEmpty</code>，因此你可以将<code>Deque</code>用作栈。<br><br></p>
<h6 id="7-迭代式DFS"><a href="#7-迭代式DFS" class="headerlink" title="7.迭代式DFS"></a>7.迭代式DFS</h6><p>这里是 DFS 的迭代版本，它使用<code>ArrayDeque</code>来表示<code>Node</code>对象的栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorDFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里必须反转，因为开始压栈时，顺序会反，所有需要反转，确保顺序正确</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;Node&gt;(node.childNodes());</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">for</span> (Node child : list) &#123;</span><br><span class="line">            stack.push(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>root</code>是我们想要遍历的树的根节点，所以我们首先创建栈并将根节点压入它。</p>
<p>循环持续到栈为空。每次迭代，它会从栈中弹出<code>Node</code>。如果它得到<code>TextNode</code>，它打印内容。然后它把子节点们压栈。<strong>为了以正确的顺序处理子节点，我们必须以相反的顺序将它们压栈;</strong> 我们通过将子节点复制成一个<code>ArrayList</code>，原地反转元素，然后遍历反转的<code>ArrayList</code>。</p>
<p>DFS 的迭代版本的一个优点是，<strong>更容易实现为 Java <code>Iterator</code></strong>；你会在下一章看到如何实现。<br><br><br><br><br>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/6.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/6.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/blog/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" href="/blog/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Ragty</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="http://beian.miit.gov.cn " target="_blank" rel="noopener" charset="utf-8"> ICP备案号:京ICP备<13502>号 </a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.7.0"></script><script src="/blog/js/fancybox.js?version=1.7.0"></script><script src="/blog/js/sidebar.js?version=1.7.0"></script><script src="/blog/js/copy.js?version=1.7.0"></script><script src="/blog/js/fireworks.js?version=1.7.0"></script><script src="/blog/js/transition.js?version=1.7.0"></script><script src="/blog/js/scroll.js?version=1.7.0"></script><script src="/blog/js/head.js?version=1.7.0"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>