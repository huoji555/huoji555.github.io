<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构思维笔记（十一）哈希"><meta name="keywords" content="哈希 数据结构"><meta name="author" content="Ragty"><meta name="copyright" content="Ragty"><title>数据结构思维笔记（十一）哈希 | Ragty の Blog</title><link rel="shortcut icon" href="/blog/melody-favicon.ico"><link rel="stylesheet" href="/blog/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-哈希"><span class="toc-text">1.哈希</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-哈希如何工作"><span class="toc-text">2.哈希如何工作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-哈希和可变性"><span class="toc-text">3.哈希和可变性</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/blog/img/avatar.jpg"></div><div class="author-info__name text-center">Ragty</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/huoji555" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">79</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">72</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">36</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接-Links</div><a class="author-info-links__name text-center" href="https://blog.csdn.net/huoji555" target="_blank" rel="noopener">MY-CSDN</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/blog/img/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">Ragty の Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/blog">Home</a><a class="site-page" href="/blog/archives">Archives</a><a class="site-page" href="/blog/categories">Categories</a><a class="site-page" href="/blog/tags">Tags</a><a class="site-page" href="/blog/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">数据结构思维笔记（十一）哈希</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4/">数据结构思维</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><a id="more"></a>

<blockquote>
<p>在本章中，我定义了一个比<code>MyLinearMap</code>更好的<code>Map</code>接口实现，<code>MyBetterMap</code>，并引入哈希，这使得<code>MyBetterMap</code>效率更高。</p>
</blockquote>
<br>


<h6 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h6><p>为了提高<code>MyLinearMap</code>的性能，我们将编写一个新的类，它被称为<code>MyBetterMap</code>，它包含<code>MyLinearMap</code>对象的集合。<strong>它在内嵌的映射之间划分键，因此每个映射中的条目数量更小</strong>，这加快了<code>findEntry</code>，以及依赖于它的方法的速度。</p>
<p>类定义的开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBetterMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBetterMap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        makeMaps(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k值关系到hashCode的分配</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">makeMaps</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        maps = <span class="keyword">new</span> ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            maps.add(<span class="keyword">new</span> MyLinearMap&lt;K, V&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量<code>maps</code>是一组<code>MyLinearMap</code>对象。构造函数接受一个参数<code>k</code>，<strong>决定至少最开始，要使用多少个映射</strong>。然后<code>makeMaps</code>创建内嵌的映射并将其存储在一个<code>ArrayList</code>中。</p>
<p>现在，完成这项工作的关键是，<strong>我们需要一些方法来查看一个键，并决定应该进入哪个映射(首先要放进去，放到哪里用HashCode算法决定)</strong>。当我们<code>put</code>一个新的键时，我们选择一个映射；当我们<code>get</code>同样的键时，我们必须记住我们把它放在哪里(<strong>重点是要确定如何跟踪</strong>)。</p>
<p>一种可能性是<strong>随机选择一个子映射</strong>，并跟踪我们把每个键放在哪里(<strong>无法跟踪</strong>)。</p>
<p>一个更好的方法是<strong>使用一个哈希函数</strong>，它接受一个<code>Object</code>，一个任意的<code>Object</code>，并返回一个称为哈希码的整数。重要的是，<strong>如果它不止一次看到相同的<code>Object</code>，它总是返回相同的哈希码</strong>。这样，如果我们使用哈希码来存储键，当我们查找时，我们将得到相同的哈希码。</p>
<p>在Java中，每个<code>Object</code>都提供了<code>hashCode</code>，一种计算哈希函数的方法。<strong>这种方法的实现对于不同的对象是不同的</strong>；我们会很快看到一个例子。</p>
<p>选择到正确的子映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 为一个给定的键选择正确的子映射（同makeMaps的初始化数量有关）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 10:53 2019/4/23</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MyLinearMap&lt;K, V&gt; <span class="title">chooseMap</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123; </span><br><span class="line">        index = Math.abs(key.hashCode()) % maps.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maps.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>key</code>是<code>null</code>，我们选择索引为<code>0</code>的子映射。否则，我们使用<code>hashCode</code>获取一个整数，调用<code>Math.abs</code>来确保它是非负数，然后使用余数运算符<code>%</code>，<strong>这保证结果在<code>0</code>和<code>maps.size()-1</code>之间</strong>。<strong>所以<code>index</code>总是一个有效的<code>maps</code>索引</strong>。然后<code>chooseMap</code>返回为其所选的映射的引用。</p>
<p>我们使用<code>chooseMap</code>的<code>put</code>和<code>get</code>，所以<strong>当我们查询键的时候，我们得到添加时所选的相同映射，我们选择了相同的映射</strong>。至少应该是 - 稍后我会解释为什么这<strong>可能不起作用</strong>。</p>
<p><code>put</code>和<code>get</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>chooseMap</code>来找到正确的子映射，然后在子映射上调用一个方法，我们考虑一下性能.</p>
<p><strong>如果在<code>k</code>个子映射中分配了<code>n</code>个条目，则平均每个映射将有<code>n/k</code>个条目。当我们查找一个键时，我们必须计算其哈希码，这需要一些时间，然后我们搜索相应的子映射。</strong></p>
<p>因为<code>MyBetterMap</code>中的条目列表，比<code>MyLinearMap</code>中的短<code>k</code>倍，我们的预期是<code>ķ</code>倍的搜索速度。<strong>但运行时间仍然与<code>n</code>成正比(n/k)，所以<code>MyBetterMap</code>仍然是线性的</strong>。在下一个练习中，你将看到如何解决这个问题。</p>
<p>关于此问题的思考，现在考虑一种比较极端的情况，如果恰好所有数据都集中在一个子映射中，那么效率将跟线性方法一样.<br></p>
<br>

<h6 id="2-哈希如何工作"><a href="#2-哈希如何工作" class="headerlink" title="2.哈希如何工作"></a>2.哈希如何工作</h6><p>哈希函数的基本要求是，<strong>每次相同的对象应该产生相同的哈希码</strong>。对于不变的对象，这是比较容易的。对于具有可变状态的对象，我们必须花费更多精力。</p>
<p>作为一个不可变对象的例子，我将定义一个<code>SillyString</code>类，它包含一个<code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyString</span><span class="params">(String innerString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.innerString = innerString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用它来展示，一个类如何定义它自己的哈希函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;innerString.length(); i++) &#123;</span><br><span class="line">        total += innerString.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>SillyString</code>重写了<code>equals</code>和<code>hashCode</code>。这个很重要。为了正常工作，<code>equals</code>必须和<code>hashCode</code>一致，这意味着如果两个对象被认为是相等的 - 也就是说，<code>equals</code>返回<code>true</code> - 它们应该有相同的哈希码。<strong>但这个要求只是单向的；如果两个对象具有相同的哈希码，则它们不一定必须相等。</strong>（不可逆）</p>
<p><code>hashCode</code>的原理是，<strong>迭代<code>String</code>中的字符并将它们相加</strong>。当你向<code>int</code>添加一个字符时，Java 将使用其 Unicode 代码点，将字符转换为整数。</p>
<p>该哈希函数满足要求：<strong>如果两个<code>SillyString</code>对象包含相等的内嵌字符串，则它们将获得相同的哈希码。</strong></p>
<p>这可以正常工作，<strong>但它可能不会产生良好的性能，因为它为许多不同的字符串返回相同的哈希码</strong>。如果两个字符串以任何顺序包含相同的字母，它们将具有相同的哈希码。即使它们不包含相同的字母，它们可能会产生相同的总量，例如<code>&quot;ac&quot;</code>和<code>&quot;bb&quot;</code>。或者<code>abc</code>同<code>cab</code>的哈希码也是一致的</p>
<p><strong>如果许多对象具有相同的哈希码，它们将在同一个子映射中。如果一些子映射比其他映射有更多的条目，那么当我们有<code>k</code>个映射时，加速比可能远远小于<code>k</code>。</strong>所以哈希函数的<strong>目的之一是统一</strong>；也就是说，以相等的可能性，在这个范围内产生任何值。(<strong>等概率的在子映射中分配条目，这正是之前我们所担心的</strong>)</p>
<br>



<h6 id="3-哈希和可变性"><a href="#3-哈希和可变性" class="headerlink" title="3.哈希和可变性"></a>3.哈希和可变性</h6><p><code>String</code>是不可变的，<code>SillyString</code>也是不可变的，因为<code>innerString</code>定义为<code>final</code>。一旦你创建了一个<code>SillyString</code>，你不能使<code>innerString</code>引用不同的<code>String</code>，你不能修改所指向的<code>String</code>。因此，它将始终具有相同的哈希码。</p>
<p>我们现在用一个Array，和以上的一样，改变的是之前是String,现在是数组(<strong>可变</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyArray</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            total += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>SillyArray</code>也提供<code>setChar</code>，它能够修改修改数组内的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.array[i] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设我们创建了一个<code>SillyArray</code>，并将其添加到<code>map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SillyArray array1 = <span class="keyword">new</span> SillyArray(<span class="string">"Word1"</span>.toCharArray());</span><br><span class="line">map.put(array1, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这个数组的哈希码是<code>461</code>。现在如果我们修改了数组内容，之后尝试查询它，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1.setChar(<span class="number">0</span>, <span class="string">'C'</span>);</span><br><span class="line">Integer value = map.get(array1);</span><br></pre></td></tr></table></figure>

<p>修改之后的哈希码是<code>441</code>。<strong>使用不同的哈希码，我们就很可能进入了错误的子映射</strong>。这就很糟糕了。</p>
<p><strong>一般来说，使用可变对象作为散列数据结构中的键是很危险的</strong>，这包括<code>MyBetterMap</code>和<code>HashMap</code>。如果你可以<strong>保证映射中的键不被修改，或者任何更改都不会影响哈希码</strong>，那么这可能是正确的。但是避免这样做可能是一个好主意。（个人认为还是直接避免这种不安全的操作比较好）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ragty</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gitee.com/huoji555/blog/2019/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%93%88%E5%B8%8C/">https://gitee.com/huoji555/blog/2019/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%93%88%E5%B8%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gitee.com/huoji555/blog">Ragty の Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E5%93%88%E5%B8%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">哈希 数据结构</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/blog/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89HashMap/"><i class="fa fa-chevron-left">  </i><span>数据结构思维笔记（十二）HashMap</span></a></div><div class="next-post pull-right"><a href="/blog/2019/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89Map%E6%8E%A5%E5%8F%A3/"><span>数据结构思维笔记（十）Map接口</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '64bb26cd3e1c8abc30b9',
  clientSecret: '2c12bfa74e197296c7f3fe590350ba444099ef0b',
  repo: 'huoji555.github.io',
  owner: 'huoji555',
  admin: 'huoji555',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/blog/img/top_img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Ragty</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><a href="http://beian.miit.gov.cn " target="_blank" rel="noopener" charset="utf-8"> ICP备案号:京ICP备<13502>号 </a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/blog/js/utils.js?version=1.7.0"></script><script src="/blog/js/fancybox.js?version=1.7.0"></script><script src="/blog/js/sidebar.js?version=1.7.0"></script><script src="/blog/js/copy.js?version=1.7.0"></script><script src="/blog/js/fireworks.js?version=1.7.0"></script><script src="/blog/js/transition.js?version=1.7.0"></script><script src="/blog/js/scroll.js?version=1.7.0"></script><script src="/blog/js/head.js?version=1.7.0"></script><script src="/blog/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>