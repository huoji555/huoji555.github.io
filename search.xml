<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AC自动机详解及实现</title>
      <link href="/blog/2020/04/10/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/blog/2020/04/10/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>之前的<code>Trie树</code>，<code>DBTrie</code>都属于前缀树，虽然DAT每次状态转移的时间复杂度都是常数，但全切分长度为n的文本时，时间复杂度为O(n^2)。这是因为<strong>扫描过程中需要不断的挪动起点，发起新的查询</strong>。所以说，DAT的全切分复杂度为O(n^2)。</p><br><h2 id="2-为什么需要AC自动机"><a href="#2-为什么需要AC自动机" class="headerlink" title="2.为什么需要AC自动机"></a>2.为什么需要AC自动机</h2><p>显然，<strong>前缀树的短板是扫描</strong>，查询一个句子时，前缀树需要不断的挪动起点，发起新查询，这个过程浪费了大量时间。</p><blockquote><p>举个栗子，扫描”清华大学”这个短语，算法以”清”为起点扫描”清”，”清华”，”清华大”，“清华大学”，之后再回退到”华”，继续扫描”华”，”华大”……</p><p>如果能够在扫描到”清华大学”的同时想办法知道，”华大学”，”大学”，”学”在不在字典树中，那么就可以省略掉这三次查询，观察一下这三个字符串，它们共享递进式的后缀，首尾对调后(“学”,”学大”，”学大华”)恰好可以用另一颗前缀树索引，称它为<strong>后缀树</strong>。</p></blockquote><p><strong><code>AC(Aho-Corasick)自动机</code>的原理就是在前缀树的基础上，为前缀树上的每个节点建立一颗后缀树，从而节省了大量查询。</strong>这使得每次扫描由原来的O(n^2)降到了O(n)，<code>AC自动机</code>现在被广泛的用于<code>多字符串匹配</code>。</p><br><h2 id="3-AC自动机的结构"><a href="#3-AC自动机的结构" class="headerlink" title="3.AC自动机的结构"></a>3.AC自动机的结构</h2><ul><li>success表：用于状态的成功转移，本质上是一个前缀树</li><li>output表：记录命中的模式串</li><li>failture表：保存状态间的一对一的关系，存储状态转移失败后应当回退的最佳状态，这里的最佳状态是指能记住已匹配上的字符串的最长后缀的那个状态。</li></ul><br><h2 id="4-AC自动机的构建过程"><a href="#4-AC自动机的构建过程" class="headerlink" title="4.AC自动机的构建过程"></a>4.AC自动机的构建过程</h2><p>整体流程如下：</p><ul><li>添加模式串keyWord，构建树，根据seccess函数构建success表</li><li>构建完成后，对树进行扫描，根据fail函数构建fail表</li><li>外界输入文本，输出被命中的模式串</li></ul><p>下面以图为例，图来源于<a href="https://www.processon.com/view/5628c824e4b0d30f15b21aae" target="_blank" rel="noopener">ProcessOn</a>:</p><p><img src="https://img-blog.csdnimg.cn/20200410154147229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt=""></p><br><h2 id="5-建立success表"><a href="#5-建立success表" class="headerlink" title="5.建立success表"></a>5.建立success表</h2><p><code>sucess表</code>的本质是前缀树，所以构建不再赘述，唯一不同的是，根节点不光可以按第一层的节点转移(比如像图中的h和s)，还可以接受其它字符，转移终点都是自己。下面是构建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/1 14:22</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: success跳转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Character character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(character);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/1 14:23</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 状态转移(此处的transition为转移的状态，可理解为接收的一个词)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">nextState</span><span class="params">(Character transition)</span> </span>&#123;</span><br><span class="line">    Node state = <span class="keyword">this</span>.find(transition);             <span class="comment">//先按success跳转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isRoot) &#123;                              <span class="comment">//如果跳转到根结点还是失败，则返回根结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.failure.nextState(transition);      <span class="comment">// 跳转失败，按failure跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="6-建立Fail表-核心"><a href="#6-建立Fail表-核心" class="headerlink" title="6.建立Fail表(核心)"></a>6.建立Fail表(核心)</h2><p><code>Fail表</code>保存的是状态(节点)间的一对一的关系，存储状态转移失败后应当回退的最佳状态(<strong>敲黑板，看下面的实例讲解！！！</strong>)。</p><p>以图为例，匹配she之后到达状态5，再来一个字符，状态转移失败，此时，最长后缀为he，对应路径为0-1-2。因此，状态2是状态5 fail的最佳选择，fail到状态2之后，做好了接受r的准备。</p><p>再比如，匹配his后到达状态7，此时his的最长后缀为is，但是途中没有找到is的路径，于是找次长后缀s，对应路径为0-3，因此状态7的最佳fail为3。</p><p>下面是构建方法：</p><ul><li>将深度为1的节点设为根节点，<strong>第二层中的节点的失败路径直接指向根节点</strong></li><li><strong>为深度大于1的节点建立fail表</strong>，此处需要层序遍历，用BFS进行广度优先遍历。整个过程可以概括为一句话：设这个节点上的字母为C，沿着他父亲的失败指针走，直到找到一个节点，孩子节点也为C。然后把当前节点的fail指向刚找到的孩子节点C。如果一直走到了root都没找到，那就把fail指向root。</li></ul><p>下面是具体的构建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/1 16:04</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 建立Fail表(核心,BFS遍历)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructFailureStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node depthOneState : <span class="keyword">this</span>.root.children()) &#123;</span><br><span class="line">        depthOneState.setFailure(<span class="keyword">this</span>.root);</span><br><span class="line">        queue.add(depthOneState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.failureStatesConstructed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node parentNode = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Character transition : parentNode.getTransitions()) &#123;</span><br><span class="line">            Node childNode = parentNode.find(transition);</span><br><span class="line">            queue.add(childNode);</span><br><span class="line">            Node failNode = parentNode.getFailure().nextState(transition);   <span class="comment">//在这里构建failNode</span></span><br><span class="line">            childNode.setFailure(failNode);</span><br><span class="line">            childNode.addEmit(failNode.emit());<span class="comment">//用路径后缀构建output表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="7-建立output表"><a href="#7-建立output表" class="headerlink" title="7.建立output表"></a>7.建立output表</h2><p><code>output表</code>用来记录命中的模式串，output表中的元素有两种：</p><ul><li><strong>从初始状态到当前状态的路径本身对应的模式串</strong>（比如2号状态的he）</li><li><strong>路径的后缀所对应的模式串</strong>（比如5号状态中的he）</li></ul><p>所以output表的构造也分为两步：</p><ul><li>第一步与字典树类似，记录完整路径所对应的模式串</li><li>第二步则是找出所有路径后缀及其模式串(这一步放在了构建fail表的最后)</li></ul><p>下面是构建代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/1 15:10</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 添加一个模式串(内部使用字典树构建)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyword == <span class="keyword">null</span> || keyword.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node currentState = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (Character character : keyword.toCharArray()) &#123;</span><br><span class="line">        currentState = currentState.insert(character);</span><br><span class="line">    &#125;</span><br><span class="line">    currentState.addEmit(keyword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="8-模式匹配"><a href="#8-模式匹配" class="headerlink" title="8.模式匹配"></a>8.模式匹配</h2><p>模式匹配实现的功能是，<strong>输入一段文本，输出AC自动机中所有匹配的词</strong>，下面是实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/4/1 17:43</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 模式匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Emit&gt; <span class="title">parseText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    checkForConstructedFailureStates();</span><br><span class="line">    Node currentState = <span class="keyword">this</span>.root;</span><br><span class="line">    List&lt;Emit&gt; collectedEmits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; text.length(); position++) &#123;</span><br><span class="line">        Character character = text.charAt(position);</span><br><span class="line">        currentState = currentState.nextState(character);</span><br><span class="line">        Collection&lt;String&gt; emits = currentState.emit();</span><br><span class="line">        <span class="keyword">if</span> (emits == <span class="keyword">null</span> || emits.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String emit : emits) &#123;</span><br><span class="line">            collectedEmits.add(<span class="keyword">new</span> Emit(position - emit.length() + <span class="number">1</span>, position, emit));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collectedEmits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="9-单元测试"><a href="#9-单元测试" class="headerlink" title="9.单元测试"></a>9.单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AhoCorasickTrie trie = <span class="keyword">new</span> AhoCorasickTrie();</span><br><span class="line">    trie.addKeyword(<span class="string">"hers"</span>);</span><br><span class="line">    trie.addKeyword(<span class="string">"his"</span>);</span><br><span class="line">    trie.addKeyword(<span class="string">"she"</span>);</span><br><span class="line">    trie.addKeyword(<span class="string">"he"</span>);</span><br><span class="line">   </span><br><span class="line">    Collection&lt;Emit&gt; emits = trie.parseText(<span class="string">"ushers"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Emit emit : emits) &#123;</span><br><span class="line">        System.out.println(emit.start + <span class="string">" "</span> + emit.end + <span class="string">"\t"</span> + emit.getKeyword());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入文本为”ushers”时，输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span>she</span><br><span class="line"><span class="number">2</span> <span class="number">3</span>he</span><br><span class="line"><span class="number">2</span> <span class="number">5</span>hers</span><br></pre></td></tr></table></figure><br><h2 id="10-基于双数组字典树的AC自动机"><a href="#10-基于双数组字典树的AC自动机" class="headerlink" title="10.基于双数组字典树的AC自动机"></a>10.基于双数组字典树的AC自动机</h2><p>基于双数组字典树的AC自动机会进一步优化，结构上只需将原来的success表的构建由Trie树替换为DATrie，效果上与双数组字典树不相上下，原因为：</p><ul><li>汉语中的词汇都不太长，前缀树的优势占了较大比重，AC自动机的fail机制发挥不了太大作用</li><li>全切分需要将结果添加到链表，也会占用时间</li></ul><p>总结一下，<strong>当含有短模式串时，优先用双数组字典树，否则优先使用基于双数组字典树的AC自动机</strong></p><br><h2 id="11-源码"><a href="#11-源码" class="headerlink" title="11.源码"></a>11.源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AhoCorasickTrie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean failureStatesConstructed = <span class="keyword">false</span>;   <span class="comment">//是否建立了failure表</span></span><br><span class="line">    <span class="keyword">private</span> Node root;                                  <span class="comment">//根结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 13:49</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: ACTire初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AhoCorasickTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 13:54</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: ACTrie节点(内部用字典树构建)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; emits;         <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">private</span> Node failure;               <span class="comment">//失败中转</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isRoot = <span class="keyword">false</span>;     <span class="comment">//是否为根结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        emits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Boolean isRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.isRoot = isRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Character character)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">this</span>.map.get(character);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node();</span><br><span class="line">            map.put(character, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmit</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">            emits.add(keyword);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmit</span><span class="params">(Collection&lt;String&gt; keywords)</span> </span>&#123;</span><br><span class="line">            emits.addAll(keywords);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@Date</span>: 2020/4/1 14:22</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@Description</span>: success跳转</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Character character)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(character);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@Date</span>: 2020/4/1 14:23</span></span><br><span class="line"><span class="comment">         *  <span class="doctag">@Description</span>: 状态转移(此处的transition为转移的状态，可理解为接收的一个词)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">nextState</span><span class="params">(Character transition)</span> </span>&#123;</span><br><span class="line">            Node state = <span class="keyword">this</span>.find(transition);             <span class="comment">//先按success跳转</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isRoot) &#123;                              <span class="comment">//如果跳转到根结点还是失败，则返回根结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.failure.nextState(transition);      <span class="comment">// 跳转失败，按failure跳转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Node&gt; <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.map.values();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFailure</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            failure = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> failure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;Character&gt; <span class="title">getTransitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">emit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.emits == <span class="keyword">null</span> ? Collections.&lt;String&gt;emptyList() : <span class="keyword">this</span>.emits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 15:01</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 模式串(用于模式串匹配)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emit</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String keyword;   <span class="comment">//匹配到的模式串</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;        <span class="comment">//起点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;          <span class="comment">//终点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> start, <span class="keyword">final</span> <span class="keyword">int</span> end, <span class="keyword">final</span> String keyword)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.keyword = keyword;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKeyword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.keyword;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"="</span> + <span class="keyword">this</span>.keyword;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 15:10</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 添加一个模式串(内部使用字典树构建)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(String keyword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyword == <span class="keyword">null</span> || keyword.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node currentState = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (Character character : keyword.toCharArray()) &#123;</span><br><span class="line">            currentState = currentState.insert(character);</span><br><span class="line">        &#125;</span><br><span class="line">        currentState.addEmit(keyword);          <span class="comment">//记录完整路径的output表(第一步)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 17:43</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 模式匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Emit&gt; <span class="title">parseText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        checkForConstructedFailureStates();</span><br><span class="line">        Node currentState = <span class="keyword">this</span>.root;</span><br><span class="line">        List&lt;Emit&gt; collectedEmits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; text.length(); position++) &#123;</span><br><span class="line">            Character character = text.charAt(position);</span><br><span class="line">            currentState = currentState.nextState(character);</span><br><span class="line">            Collection&lt;String&gt; emits = currentState.emit();</span><br><span class="line">            <span class="keyword">if</span> (emits == <span class="keyword">null</span> || emits.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String emit : emits) &#123;</span><br><span class="line">                collectedEmits.add(<span class="keyword">new</span> Emit(position - emit.length() + <span class="number">1</span>, position, emit));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> collectedEmits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 16:04</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 建立Fail表(核心,BFS遍历)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructFailureStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node depthOneState : <span class="keyword">this</span>.root.children()) &#123;</span><br><span class="line">            depthOneState.setFailure(<span class="keyword">this</span>.root);</span><br><span class="line">            queue.add(depthOneState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.failureStatesConstructed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node parentNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (Character transition : parentNode.getTransitions()) &#123;</span><br><span class="line">                Node childNode = parentNode.find(transition);</span><br><span class="line">                queue.add(childNode);</span><br><span class="line">                Node failNode = parentNode.getFailure().nextState(transition);   <span class="comment">//在这里构建failNode</span></span><br><span class="line">                childNode.setFailure(failNode);</span><br><span class="line">                childNode.addEmit(failNode.emit());                             <span class="comment">//用路径后缀构建output表(第二步)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/4/1 15:28</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 检查是否建立了Fail表(若没建立，则建立)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForConstructedFailureStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.failureStatesConstructed) &#123;</span><br><span class="line">            constructFailureStates();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AhoCorasickTrie trie = <span class="keyword">new</span> AhoCorasickTrie();</span><br><span class="line">        trie.addKeyword(<span class="string">"hers"</span>);</span><br><span class="line">        trie.addKeyword(<span class="string">"his"</span>);</span><br><span class="line">        trie.addKeyword(<span class="string">"she"</span>);</span><br><span class="line">        trie.addKeyword(<span class="string">"he"</span>);</span><br><span class="line"></span><br><span class="line">        Collection&lt;Emit&gt; emits = trie.parseText(<span class="string">"ushers"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Emit emit : emits) &#123;</span><br><span class="line">            System.out.println(emit.start + <span class="string">" "</span> + emit.end + <span class="string">"\t"</span> + emit.getKeyword());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双数组字典树(DATrie)详解及实现</title>
      <link href="/blog/2020/03/10/%E5%8F%8C%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E6%A0%91(DATrie)%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2020/03/10/%E5%8F%8C%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E6%A0%91(DATrie)%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p><code>Trie树</code>本质是一个确定的有限状态自动机(DFA)，核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。<strong>但由于<code>Trie树</code>的稀疏现象严重，空间利用率较低</strong>为了让<code>Trie树</code>实现占用较少的空间，同时还要保证查询的效率，最后提出了用2个线性数组来进行<code>Trie树</code>的表示，即<code>双数组Trie(Double Array Trie)</code>.</p><br><h3 id="2-算法及公式解析"><a href="#2-算法及公式解析" class="headerlink" title="2.算法及公式解析"></a><strong>2.算法及公式解析</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base[s] + c = t</span><br><span class="line">check[t] =  s</span><br></pre></td></tr></table></figure><p>往往读到这里，大家都是一头雾水，不知所云，我们首先了解下<code>base</code>和<code>check</code>代表的意义及作用</p><blockquote><p>base数组的每个元素表示一个<code>Trie节点</code>，即一个状态(分为空闲状态和占用状态)<br>check数组的每个元素表示某个状态的前驱状态</p></blockquote><p>现在我们分析一下以上出现的公式</p><blockquote><p>base树组中的<code>s</code>代表当前状态的下标，<code>t</code>代表转移状态的下标，<code>c</code>代表输入字符的数值</p><p>base[s] + c =  t   //表示一次状态转移</p><p>由于转移后状态下标为<code>t</code>,且父子关系是唯一的，所以可通过检验当前元素的前驱状态确定转移是否成功</p><p>check[t] =  s    //检验状态转移是否成功</p></blockquote><p>那么这种算法相对于传统的<code>Trie树</code>的<strong>优点</strong>是，<strong>只需要一个加法一次比较即可完成一次状态转移，只花费了常数时间</strong>，下面给出了<code>双数组Trie树</code>的原理图（注意观察状态转移的过程）<br><img src="https://img-blog.csdnimg.cn/20200310233002360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><br><h3 id="3-状态冲突及解决方案-划重点"><a href="#3-状态冲突及解决方案-划重点" class="headerlink" title="3.状态冲突及解决方案(划重点)"></a><strong>3.状态冲突及解决方案(划重点)</strong></h3><blockquote><p>说的简单一点，状态冲突的意思就是，进行状态转移时，发现转换的位置base[t]已经被人占了(<strong>状态冲突</strong>)，那你怎么办呢，重新改变c值(<strong>改变父节点的转移基数</strong>)，让它放在base数组中未被占用的位置</p><p>解决方案，用while函数由发生冲突的位置向前遍历，一旦发现有空位置便占用并更新转移基数(<strong>也就是c值</strong>)，可以把这个过程看作为公交车上从后往前占座的过程</p><p>构造字典时，如果有新词加入，若新词的首字未出现，写入时有冲突的情况下，导致根节点的转移基数改变，会导致重构整个树的情况(否则不能进行正确的状态转移)，所以<strong>构建树时建议先构建每个词的首字，再构建各个词的子节点</strong>，这样产生冲突的情况下，可以将冲突局限在单个父节点和子节点之间，不至于大范围的节点重构</p></blockquote><br><h3 id="4-叶子节点的构造与处理"><a href="#4-叶子节点的构造与处理" class="headerlink" title="4.叶子节点的构造与处理"></a><strong>4.叶子节点的构造与处理</strong></h3><p>下面介绍几种处理叶子节点的处理方案：</p><ul><li><strong>将每个词的词尾设置为特殊字符(/0)</strong>，因为最后一个字已经不需要状态转移，所以可以这样构造，但是增加了节点的数量，构建字典时会造成消耗</li><li><strong>将每个词的词尾设置为转移基数的负数(只有词尾为负值)</strong>，这样能够节省构建时间，不过进行转移时要将状态转移函数改为<code>|base[s]|+code(字符)</code></li></ul><p>我们的实现中采用后一种构建方案</p><br><h3 id="5-双字典树结构"><a href="#5-双字典树结构" class="headerlink" title="5.双字典树结构"></a><strong>5.双字典树结构</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">655350</span>;  <span class="comment">//数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_ROOT = <span class="number">1</span>;        <span class="comment">//base根节点状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_NULL = <span class="number">0</span>;        <span class="comment">//base空闲状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CHECK_ROOT = -<span class="number">1</span>;      <span class="comment">//check根节点状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CHECK_NULL = -<span class="number">2</span>;      <span class="comment">//check空闲状态</span></span><br><span class="line"><span class="keyword">private</span> TrieNode base[];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> check[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/3/5 16:05</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: DATrie节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> transferRatio; <span class="comment">//转移基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLeaf = <span class="keyword">false</span>; <span class="comment">//是否为叶子节点</span></span><br><span class="line">    <span class="keyword">private</span> Character label = <span class="keyword">null</span>; <span class="comment">//节点标识即插入的字符本身</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = -<span class="number">1</span>; <span class="comment">//当该节点为叶子节点时关联的字典表中对应词条的索引号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTransferRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transferRatio;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransferRatio</span><span class="params">(<span class="keyword">int</span> transferRatio)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transferRatio = transferRatio;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaf</span><span class="params">(<span class="keyword">boolean</span> leaf)</span> </span>&#123;</span><br><span class="line">        isLeaf = leaf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Character <span class="title">getLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(Character label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="6-双字典树的构建"><a href="#6-双字典树的构建" class="headerlink" title="6.双字典树的构建"></a><strong>6.双字典树的构建</strong></h3><blockquote><p>这里说一句，构建的准则是，<strong>先构建每个词的首字，后构建每个词的剩余节点</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/3/10 19:37</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 构造DATrie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> shut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; words.size(); idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> startState = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> chars[] = words.get(idx).toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shut == <span class="keyword">false</span>) &#123;</span><br><span class="line">            TrieNode node = insert(startState, getCode(chars[<span class="number">0</span>]), (chars.length == <span class="number">1</span>), idx);</span><br><span class="line">            node.setLabel(chars[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;chars.length; j++) &#123;</span><br><span class="line">                startState = transfer(startState, getCode(chars[j-<span class="number">1</span>]));</span><br><span class="line">                TrieNode node = insert(startState, getCode(chars[j]), (chars.length == j+<span class="number">1</span>), idx);</span><br><span class="line">                node.setLabel(chars[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == words.size()-<span class="number">1</span> &amp;&amp; shut == <span class="keyword">false</span>) &#123;</span><br><span class="line">            idx = -<span class="number">1</span>;   <span class="comment">//因为开始的时候还有一个加的过程</span></span><br><span class="line">            shut = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/3/5 16:06</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 初始化DATrie（base，check数组全部初始化）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    base = <span class="keyword">new</span> TrieNode[ARRAY_SIZE];</span><br><span class="line">    check = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">        TrieNode node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        node.setTransferRatio(BASE_NULL);</span><br><span class="line">        base[i] = node;</span><br><span class="line">        check[i] = CHECK_NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    root.setTransferRatio(BASE_ROOT);</span><br><span class="line">    base[<span class="number">0</span>] = root;</span><br><span class="line">    check[<span class="number">0</span>] = CHECK_ROOT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="7-双数组字典树的插入"><a href="#7-双数组字典树的插入" class="headerlink" title="7.双数组字典树的插入"></a>7.双数组字典树的插入</h3><blockquote><p>插入时，有冲突需要解决冲突，无冲突再检查是否为叶子节点，最后进行状态转移</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/3/5 18:49</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 根据起始状态和转移技术插入新节点并返回插入的节点</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> startState 起始状态</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> offset  状态偏移量</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> isLeaf  是否为叶子节点</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span> idx 当前节点在词典中的索引号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">insert</span><span class="params">(<span class="keyword">int</span> startState, <span class="keyword">int</span> offset, <span class="keyword">boolean</span> isLeaf, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endState = transfer(startState, offset); <span class="comment">//状态转移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base[endState].getTransferRatio() != BASE_NULL &amp;&amp; check[endState] != startState) &#123; <span class="comment">//已被占用</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            endState += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (base[endState].getTransferRatio() != BASE_NULL);</span><br><span class="line"></span><br><span class="line">        base[startState].setTransferRatio(endState - offset); <span class="comment">//改变父节点转移基数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">        base[endState].setTransferRatio(Math.abs(base[startState].getTransferRatio())*-<span class="number">1</span>); <span class="comment">//叶子节点转移基数标识为父节点转移基数的相反数</span></span><br><span class="line">        base[endState].setLeaf(<span class="keyword">true</span>);</span><br><span class="line">        base[endState].setValue(idx); <span class="comment">//为叶子节点时需要记录下该词在字典中的索引号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (base[endState].getTransferRatio() == BASE_NULL) &#123; <span class="comment">//未有节点经过</span></span><br><span class="line">            base[endState].setTransferRatio(Math.abs(base[startState].getTransferRatio())); <span class="comment">//非叶子节点的转移基数一定为正</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    check[endState] = startState;<span class="comment">//check中记录当前状态的父状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base[endState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="8-双数组字典树的查询"><a href="#8-双数组字典树的查询" class="headerlink" title="8.双数组字典树的查询"></a><strong>8.双数组字典树的查询</strong></h3><p>这里我写的比较简单，用<strong>正向匹配</strong>做的，这里比较关键的一句是这个</p><blockquote><p><code>base[endState].getTransferRatio() != BASE_NULL &amp;&amp; check[endState] == startState</code></p></blockquote><p>可以检测出节点是否在树上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/3/5 18:54</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 查询匹配项(正向匹配)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">match</span><span class="params">(String keyWord)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> startState, endState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> chars[] = keyWord.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        startState = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; chars.length; j++) &#123;</span><br><span class="line">            endState = transfer(startState, getCode(chars[j]));</span><br><span class="line">            <span class="keyword">if</span> (base[endState].getTransferRatio() != BASE_NULL &amp;&amp; check[endState] == startState) &#123; <span class="comment">//节点存在于 Trie 树上</span></span><br><span class="line">                <span class="keyword">if</span> (base[endState].isLeaf()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.contains(base[endState].getValue())) &#123;</span><br><span class="line">                        result.add(base[endState].getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                startState = endState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="9-双数组字典树测试"><a href="#9-双数组字典树测试" class="headerlink" title="9.双数组字典树测试"></a>9.<strong>双数组字典树测试</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    words.add(<span class="string">"清华"</span>);</span><br><span class="line">    words.add(<span class="string">"清华大学"</span>);</span><br><span class="line">    words.add(<span class="string">"清新"</span>);</span><br><span class="line">    words.add(<span class="string">"中华"</span>);</span><br><span class="line">    words.add(<span class="string">"中华人民"</span>);</span><br><span class="line">    words.add(<span class="string">"华人"</span>);</span><br><span class="line">    words.add(<span class="string">"学生"</span>);</span><br><span class="line">    words.add(<span class="string">"大学生"</span>);</span><br><span class="line">    words.add(<span class="string">"wo"</span>);</span><br><span class="line">    words.add(<span class="string">"shi"</span>);</span><br><span class="line">    words.add(<span class="string">"human"</span>);</span><br><span class="line">    words.add(<span class="string">"this"</span>);</span><br><span class="line">    words.add(<span class="string">"is"</span>);</span><br><span class="line">    words.add(<span class="string">"ragty"</span>);</span><br><span class="line">    words.add(<span class="string">"pump"</span>);</span><br><span class="line">    words.add(<span class="string">"it"</span>);</span><br><span class="line">    words.add(<span class="string">"up"</span>);</span><br><span class="line">    words.add(<span class="string">"中国"</span>);</span><br><span class="line">    words.add(<span class="string">"人名"</span>);</span><br><span class="line">    words.add(<span class="string">"中国人民"</span>);</span><br><span class="line">    words.add(<span class="string">"人民"</span>);</span><br><span class="line">    words.add(<span class="string">"java"</span>);</span><br><span class="line">    words.add(<span class="string">"java学习"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建 Trie 树</span></span><br><span class="line">    DATrie daTrie = <span class="keyword">new</span> DATrie();</span><br><span class="line">    daTrie.build(words);</span><br><span class="line">    daTrie.printTrie();</span><br><span class="line"></span><br><span class="line">    String keyWord = <span class="string">"清华大学生都是华人"</span>;</span><br><span class="line">    List&lt;Integer&gt; result = daTrie.match(keyWord);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">"输入语句为："</span>+keyWord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印匹配结果</span></span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.printf(<span class="string">"Match: &#123;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s"</span>, words.get(result.get(i)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">", %s"</span>, words.get(result.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">"&#125;"</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="10-测试结果"><a href="#10-测试结果" class="headerlink" title="10.测试结果"></a><strong>10.测试结果</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  idx      <span class="number">0</span>     <span class="number">98</span>     <span class="number">99</span>    <span class="number">100</span>    <span class="number">104</span>    <span class="number">105</span>    <span class="number">106</span>    <span class="number">107</span>    <span class="number">108</span>    <span class="number">109</span>    <span class="number">110</span>    <span class="number">111</span>    <span class="number">112</span>    <span class="number">113</span>    <span class="number">114</span>    <span class="number">115</span>    <span class="number">116</span>    <span class="number">117</span>    <span class="number">118</span>    <span class="number">119</span>    <span class="number">120</span>    <span class="number">121</span>    <span class="number">122</span>    <span class="number">123</span>    <span class="number">124</span>    <span class="number">125</span>    <span class="number">126</span>    <span class="number">127</span>    <span class="number">128</span>    <span class="number">129</span>    <span class="number">130</span>    <span class="number">131</span>    <span class="number">132</span>  <span class="number">20014</span>  <span class="number">20099</span>  <span class="number">20155</span>  <span class="number">20156</span>  <span class="number">20157</span>  <span class="number">20158</span>  <span class="number">21327</span>  <span class="number">21328</span>  <span class="number">21329</span>  <span class="number">21518</span>  <span class="number">22272</span>  <span class="number">22824</span>  <span class="number">22825</span>  <span class="number">23399</span>  <span class="number">23400</span>  <span class="number">23401</span>  <span class="number">23433</span>  <span class="number">26034</span>  <span class="number">27666</span>  <span class="number">27668</span>  <span class="number">27669</span>  <span class="number">28166</span>  <span class="number">29984</span>  <span class="number">29986</span></span><br><span class="line"> <span class="keyword">char</span>   <span class="keyword">null</span>      a      a      a      g      h      i      j      h      i      h      m      o      p      n      r      s      t      u      u      w      i      s      t      u      m      t      p      y      p      v      s      a      中      习      人      人      人      人      华      华      华      名      国      大      大      学      学      学      学      新      民      民      民      清      生      生</span><br><span class="line"> base      <span class="number">1</span>      <span class="number">1</span>      <span class="number">4</span>     <span class="number">12</span>      <span class="number">7</span>      <span class="number">2</span>     <span class="number">10</span>      <span class="number">3</span>      <span class="number">4</span>     -<span class="number">4</span>     <span class="number">16</span>      <span class="number">2</span>     -<span class="number">1</span>      <span class="number">7</span>     -<span class="number">4</span>      <span class="number">1</span>      <span class="number">4</span>      <span class="number">6</span>     <span class="number">15</span>      <span class="number">2</span>      <span class="number">1</span>     <span class="number">16</span>     -<span class="number">7</span>      <span class="number">7</span>     <span class="number">16</span>     <span class="number">17</span>    -<span class="number">10</span>    -<span class="number">15</span>     -<span class="number">7</span>    -<span class="number">17</span>     <span class="number">35</span>    -<span class="number">16</span>    -<span class="number">35</span>      <span class="number">3</span>    -<span class="number">35</span>      <span class="number">1</span>     -<span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">2</span>     -<span class="number">2</span>     -<span class="number">3</span>     -<span class="number">1</span>      <span class="number">4</span>      <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span>     -<span class="number">2</span>      <span class="number">3</span>     <span class="number">35</span>     -<span class="number">2</span>     -<span class="number">1</span>     -<span class="number">3</span>     -<span class="number">4</span>      <span class="number">2</span>     -<span class="number">1</span>     -<span class="number">3</span></span><br><span class="line">check     -<span class="number">1</span>    <span class="number">115</span>    <span class="number">111</span>    <span class="number">107</span>     <span class="number">98</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">116</span>    <span class="number">108</span>    <span class="number">117</span>    <span class="number">119</span>    <span class="number">120</span>      <span class="number">0</span>     <span class="number">99</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">105</span>      <span class="number">0</span>    <span class="number">110</span>    <span class="number">106</span>    <span class="number">104</span>    <span class="number">113</span>    <span class="number">124</span>    <span class="number">106</span>    <span class="number">118</span>    <span class="number">123</span>    <span class="number">125</span>    <span class="number">100</span>    <span class="number">121</span>    <span class="number">130</span>      <span class="number">0</span>  <span class="number">23433</span>      <span class="number">0</span>  <span class="number">21327</span>  <span class="number">21329</span>  <span class="number">22272</span>      <span class="number">0</span>  <span class="number">28166</span>  <span class="number">20014</span>  <span class="number">20155</span>  <span class="number">20014</span>      <span class="number">0</span>  <span class="number">21328</span>      <span class="number">0</span>  <span class="number">22825</span>  <span class="number">22824</span>    <span class="number">132</span>  <span class="number">28166</span>  <span class="number">20155</span>  <span class="number">20157</span>  <span class="number">20158</span>      <span class="number">0</span>  <span class="number">23399</span>  <span class="number">23401</span></span><br><span class="line"> leaf      否      否      否      否      否      否      否      否      否      是      否      否      是      否      是      否      否      否      否      否      否      否      是      否      否      否      是      是      是      是      否      是      是      否      是      否      是      否      否      否      是      是      是      是      否      否      否      是      否      否      是      是      是      是      否      是      是</span><br><span class="line">  idx     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>      <span class="number">9</span>     -<span class="number">1</span>     -<span class="number">1</span>      <span class="number">8</span>     -<span class="number">1</span>     <span class="number">10</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     <span class="number">12</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>     <span class="number">15</span>     <span class="number">16</span>     <span class="number">13</span>     <span class="number">14</span>     -<span class="number">1</span>     <span class="number">11</span>     <span class="number">21</span>     -<span class="number">1</span>     <span class="number">22</span>     -<span class="number">1</span>      <span class="number">5</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>      <span class="number">0</span>      <span class="number">3</span>     <span class="number">18</span>     <span class="number">17</span>     -<span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>      <span class="number">1</span>     -<span class="number">1</span>     -<span class="number">1</span>      <span class="number">2</span>     <span class="number">20</span>      <span class="number">4</span>     <span class="number">19</span>     -<span class="number">1</span>      <span class="number">6</span>      <span class="number">7</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输入语句为：清华大学生都是华人</span><br><span class="line"></span><br><span class="line">Match: &#123;清华, 清华大学, 大学生, 学生, 华人&#125;</span><br></pre></td></tr></table></figure><br><h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a><strong>11.总结</strong></h3><blockquote><p>我刚开始写的时候没有任何头绪，看到那两个公式一头雾水，查了很多博客也写得一知半解，而且没有公式解析和实现代码。经过查阅文献以及自己的思考，有了这篇文章，希望能帮到更多想了解<code>DATrie</code>的人。</p><p>任何事情你清楚他要解决的问题和实现原理后，会发现它很简单。就像<code>DATrie</code>，它的难点在于核心公式的理解以及对于冲突的解决方案。只要理解了这个，实现是很简单的一件事。</p></blockquote><br><h3 id="12-完整代码-可直接运行"><a href="#12-完整代码-可直接运行" class="headerlink" title="12.完整代码(可直接运行)"></a><strong>12.完整代码(可直接运行)</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Dictionary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DATrie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SIZE = <span class="number">655350</span>;  <span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_ROOT = <span class="number">1</span>;        <span class="comment">//base根节点状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_NULL = <span class="number">0</span>;        <span class="comment">//base空闲状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CHECK_ROOT = -<span class="number">1</span>;      <span class="comment">//check根节点状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CHECK_NULL = -<span class="number">2</span>;      <span class="comment">//check空闲状态</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode base[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> check[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 16:05</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: DATrie节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> transferRatio; <span class="comment">//转移基数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isLeaf = <span class="keyword">false</span>; <span class="comment">//是否为叶子节点</span></span><br><span class="line">        <span class="keyword">private</span> Character label = <span class="keyword">null</span>; <span class="comment">//节点标识即插入的字符本身</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value = -<span class="number">1</span>; <span class="comment">//当该节点为叶子节点时关联的字典表中对应词条的索引号</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTransferRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transferRatio;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransferRatio</span><span class="params">(<span class="keyword">int</span> transferRatio)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.transferRatio = transferRatio;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isLeaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeaf</span><span class="params">(<span class="keyword">boolean</span> leaf)</span> </span>&#123;</span><br><span class="line">            isLeaf = leaf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Character <span class="title">getLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(Character label)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/10 19:37</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 构造DATrie</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> shut = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; words.size(); idx++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> startState = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> chars[] = words.get(idx).toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shut == <span class="keyword">false</span>) &#123;</span><br><span class="line">                TrieNode node = insert(startState, getCode(chars[<span class="number">0</span>]), (chars.length == <span class="number">1</span>), idx);</span><br><span class="line">                node.setLabel(chars[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;chars.length; j++) &#123;</span><br><span class="line">                    startState = transfer(startState, getCode(chars[j-<span class="number">1</span>]));</span><br><span class="line">                    TrieNode node = insert(startState, getCode(chars[j]), (chars.length == j+<span class="number">1</span>), idx);</span><br><span class="line">                    node.setLabel(chars[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (idx == words.size()-<span class="number">1</span> &amp;&amp; shut == <span class="keyword">false</span>) &#123;</span><br><span class="line">                idx = -<span class="number">1</span>;   <span class="comment">//因为开始的时候还有一个加的过程</span></span><br><span class="line">                shut = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 18:54</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 查询匹配项(正向匹配)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">match</span><span class="params">(String keyWord)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> startState, endState;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> chars[] = keyWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            startState = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; chars.length; j++) &#123;</span><br><span class="line">                endState = transfer(startState, getCode(chars[j]));</span><br><span class="line">                <span class="keyword">if</span> (base[endState].getTransferRatio() != BASE_NULL &amp;&amp; check[endState] == startState) &#123; <span class="comment">//节点存在于 Trie 树上</span></span><br><span class="line">                    <span class="keyword">if</span> (base[endState].isLeaf()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!result.contains(base[endState].getValue())) &#123;</span><br><span class="line">                            result.add(base[endState].getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    startState = endState;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 19:00</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 打印DATrie</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"idx"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7d\t"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"char"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7c\t"</span>, base[i].getLabel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"base"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7d\t"</span>, base[i].getTransferRatio());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"check"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7d\t"</span>, check[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"leaf"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7s\t"</span>, base[i].isLeaf() ? <span class="string">"是"</span> : <span class="string">"否"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"%5s"</span>, <span class="string">"idx"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i].getTransferRatio() != BASE_NULL) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%7d\t"</span>, base[i].getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 18:49</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 根据起始状态和转移技术插入新节点并返回插入的节点</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> startState 起始状态</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> offset  状态偏移量</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> isLeaf  是否为叶子节点</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> idx 当前节点在词典中的索引号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">insert</span><span class="params">(<span class="keyword">int</span> startState, <span class="keyword">int</span> offset, <span class="keyword">boolean</span> isLeaf, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endState = transfer(startState, offset); <span class="comment">//状态转移</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (base[endState].getTransferRatio() != BASE_NULL &amp;&amp; check[endState] != startState) &#123; <span class="comment">//已被占用</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                endState += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (base[endState].getTransferRatio() != BASE_NULL);</span><br><span class="line"></span><br><span class="line">            base[startState].setTransferRatio(endState - offset); <span class="comment">//改变父节点转移基数</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isLeaf) &#123;</span><br><span class="line">            base[endState].setTransferRatio(Math.abs(base[startState].getTransferRatio())*-<span class="number">1</span>); <span class="comment">//叶子节点转移基数标识为父节点转移基数的相反数</span></span><br><span class="line">            base[endState].setLeaf(<span class="keyword">true</span>);</span><br><span class="line">            base[endState].setValue(idx); <span class="comment">//为叶子节点时需要记录下该词在字典中的索引号</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (base[endState].getTransferRatio() == BASE_NULL) &#123; <span class="comment">//未有节点经过</span></span><br><span class="line">                base[endState].setTransferRatio(Math.abs(base[startState].getTransferRatio())); <span class="comment">//非叶子节点的转移基数一定为正</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        check[endState] = startState;<span class="comment">//check中记录当前状态的父状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> base[endState];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 18:53</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 根据起始状态和转移基数返回结束状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> startState, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(base[startState].getTransferRatio())+offset; <span class="comment">//状态转移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 19:13</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 获取base数组的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)c;<span class="comment">//这里必须大于0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Date</span>: 2020/3/5 16:06</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Description</span>: 初始化DATrie（base，check数组全部初始化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        base = <span class="keyword">new</span> TrieNode[ARRAY_SIZE];</span><br><span class="line">        check = <span class="keyword">new</span> <span class="keyword">int</span>[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">            TrieNode node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            node.setTransferRatio(BASE_NULL);</span><br><span class="line">            base[i] = node;</span><br><span class="line">            check[i] = CHECK_NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        root.setTransferRatio(BASE_ROOT);</span><br><span class="line">        base[<span class="number">0</span>] = root;</span><br><span class="line">        check[<span class="number">0</span>] = CHECK_ROOT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        words.add(<span class="string">"清华"</span>);</span><br><span class="line">        words.add(<span class="string">"清华大学"</span>);</span><br><span class="line">        words.add(<span class="string">"清新"</span>);</span><br><span class="line">        words.add(<span class="string">"中华"</span>);</span><br><span class="line">        words.add(<span class="string">"中华人民"</span>);</span><br><span class="line">        words.add(<span class="string">"华人"</span>);</span><br><span class="line">        words.add(<span class="string">"学生"</span>);</span><br><span class="line">        words.add(<span class="string">"大学生"</span>);</span><br><span class="line">        words.add(<span class="string">"wo"</span>);</span><br><span class="line">        words.add(<span class="string">"shi"</span>);</span><br><span class="line">        words.add(<span class="string">"human"</span>);</span><br><span class="line">        words.add(<span class="string">"this"</span>);</span><br><span class="line">        words.add(<span class="string">"is"</span>);</span><br><span class="line">        words.add(<span class="string">"ragty"</span>);</span><br><span class="line">        words.add(<span class="string">"pump"</span>);</span><br><span class="line">        words.add(<span class="string">"it"</span>);</span><br><span class="line">        words.add(<span class="string">"up"</span>);</span><br><span class="line">        words.add(<span class="string">"中国"</span>);</span><br><span class="line">        words.add(<span class="string">"人名"</span>);</span><br><span class="line">        words.add(<span class="string">"中国人民"</span>);</span><br><span class="line">        words.add(<span class="string">"人民"</span>);</span><br><span class="line">        words.add(<span class="string">"java"</span>);</span><br><span class="line">        words.add(<span class="string">"java学习"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建 Trie 树</span></span><br><span class="line">        DATrie daTrie = <span class="keyword">new</span> DATrie();</span><br><span class="line">        daTrie.build(words);</span><br><span class="line">        daTrie.printTrie();</span><br><span class="line"></span><br><span class="line">        String keyWord = <span class="string">"清华大学生都是华人"</span>;</span><br><span class="line">        List&lt;Integer&gt; result = daTrie.match(keyWord);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"输入语句为："</span>+keyWord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印匹配结果</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(<span class="string">"Match: &#123;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%s"</span>, words.get(result.get(i)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">", %s"</span>, words.get(result.get(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><p>1.<a href="https://segmentfault.com/a/1190000008877595" target="_blank" rel="noopener">小白详解Trie树</a><br>2.<a href="http://www.cnki.com.cn/Article/CJFDTotal-RJDK201207007.htm" target="_blank" rel="noopener">《基于双数组Ｔｒｉｅ树算法的字典改进和实现》</a><br>3.<a href="https://www.semanticscholar.org/paper/An-Efficient-Implementation-of-Trie-Structures-Aoe-Morimoto/f2ad2a67218e458a979afafb311d1d7867f3f624" target="_blank" rel="noopener">Theppitak Karoonboonyanan, An Implementation of Double-Array Trie.</a></p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 词典分词 </tag>
            
            <tag> DATrie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树原理分析及实现(支持中文插入)</title>
      <link href="/blog/2020/02/25/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0(%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E6%8F%92%E5%85%A5)/"/>
      <url>/blog/2020/02/25/%E5%AD%97%E5%85%B8%E6%A0%91%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0(%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E6%8F%92%E5%85%A5)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h5 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h5><p>匹配算法的瓶颈之一在于<strong>如何判断字典中是否含有字符串</strong>，如果用的是有序集合(<code>TreeMap</code>)的话，复杂度是<code>O(logn)</code>，如果用散列表(<code>HashMap</code>)，账面上的时间复杂度虽然下降了，但内存复杂度上去了。我们要寻找一种速度又快，又省内存的数据结构。</p><br><h5 id="2-字典树概念："><a href="#2-字典树概念：" class="headerlink" title="2.字典树概念："></a>2.字典树概念：</h5><blockquote><p>又称单词查找树，<a href="https://baike.baidu.com/item/Trie%E6%A0%91" target="_blank" rel="noopener">Trie树</a>，是一种<a href="https://baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/9663807" target="_blank" rel="noopener">树形结构</a>，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6" target="_blank" rel="noopener">字符</a>串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。（看图马上理解）</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcuNTF3ZW5kYW5nLmNvbS9waWMvMWNhM2M3NGZmYzNhZTE3MzIxNzZiNzYxLzItODEwLWpwZ182LTEwODAtMC0wLTEwODAuanBn?x-oss-process=image/format,png" alt=""></p><br><h5 id="3-字典树特点："><a href="#3-字典树特点：" class="headerlink" title="3.字典树特点："></a><strong>3.字典树特点</strong>：</h5><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><br><h5 id="4-字典树的实现原理："><a href="#4-字典树的实现原理：" class="headerlink" title="4.字典树的实现原理："></a><strong>4.字典树的实现原理</strong>：</h5><p>从确定有限状态自动机(DFA)的角度来讲，每个节点都是一个状态，状态表示当前已经查询到的前缀。从父节点到子节点的移动过程可以看作一次<code>状态转移</code>。以下是查询步骤：</p><ul><li>我们输入一个想要查询的词，如果有满足条件的边，状态转移；如果找不到，直接失败</li><li>完成了全部转移时，拿到了最后一个字符的状态，询问该状态是否为<strong>终点状态</strong>，如果是则查到了单词，否则该单词不在字典中</li></ul><p>“删改改查”都是一回事，以下不再赘述</p><br><h5 id="5-字典树节点结构："><a href="#5-字典树节点结构：" class="headerlink" title="5.字典树节点结构："></a><strong>5.字典树节点结构</strong>：</h5><p>这里我们用<code>HashMap</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>  字典树节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>   2020/2/27 0:00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> path;        <span class="comment">//表示多少个词共用该前缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> status;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Character, TrieNode&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        path = <span class="number">0</span>;</span><br><span class="line">        status = <span class="keyword">false</span>;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="6-字典树的实现："><a href="#6-字典树的实现：" class="headerlink" title="6.字典树的实现："></a><strong>6.字典树的实现</strong>：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:01</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieTree1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:02</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 插入节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    node.path++;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.map.get(words[i]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.map.put(words[i], <span class="keyword">new</span> TrieNode());</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.map.get(words[i]);</span><br><span class="line">        node.path++;</span><br><span class="line">    &#125;</span><br><span class="line">    node.status = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:02</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 寻找节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.map.get(words[i]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node = node.map.get(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:06</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 删除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        node.path--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--node.map.get(words[i]).path == <span class="number">0</span>) &#123;</span><br><span class="line">                node.map.remove(words[i]);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map.get(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:07</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 前缀遍历，若有前缀，返回它最后一个节点的path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">char</span>[] pres = pre.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pres.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.map.get(pres[i]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        node = node.map.get(pres[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/27 0:50</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preWalk</span><span class="params">(TrieNode root)</span> </span>&#123;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character,TrieNode&gt; map : root.map.entrySet()) &#123;</span><br><span class="line">        node = map.getValue();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(map.getKey());</span><br><span class="line">            preWalk(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TrieNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="7-测试："><a href="#7-测试：" class="headerlink" title="7.测试："></a>7.<strong>测试</strong>：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TrieTree1 trieTree = <span class="keyword">new</span> TrieTree1();</span><br><span class="line"></span><br><span class="line">    trieTree.insert(<span class="string">"字典树"</span>);</span><br><span class="line">    trieTree.insert(<span class="string">"字典书"</span>);</span><br><span class="line">    trieTree.insert(<span class="string">"字典"</span>);</span><br><span class="line">    trieTree.insert(<span class="string">"天气"</span>);</span><br><span class="line">    trieTree.insert(<span class="string">"气人"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(trieTree.search(<span class="string">"字典"</span>));</span><br><span class="line">    System.out.println(trieTree.search(<span class="string">"字"</span>));</span><br><span class="line">    System.out.println(trieTree.prefixNumber(<span class="string">"字典树"</span>));</span><br><span class="line"></span><br><span class="line">    TrieNode root = trieTree.getRoot();</span><br><span class="line"></span><br><span class="line">    trieTree.preWalk(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="8-测试结果："><a href="#8-测试结果：" class="headerlink" title="8.测试结果："></a><strong>8.测试结果</strong>：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">气--人--字--典--树--书--天--气</span><br></pre></td></tr></table></figure><br><h5 id="9-算法分析："><a href="#9-算法分析：" class="headerlink" title="9.算法分析："></a><strong>9.算法分析</strong>：</h5><p>当字典大小为n时，虽然最坏情怀下字典树的复杂度依然是O(logn)。但它的实际速度比二分查找快，这是因为随着路径的深入，前缀匹配是递进的过程，算法不必比较字符串的前缀，因此可以节省很多用来比较的时间。</p><br><h5 id="10-算法改进："><a href="#10-算法改进：" class="headerlink" title="10.算法改进："></a><strong>10.算法改进</strong>：</h5><p>这里我们查询某个词的时候还需要逐个对比，若我们将对象转换为散列值，散列函数输出区间为[0,65535]之间的整数，这时候我们直接访问下标就可以访问到对应的字符，不过这种做法只适用于第一行，否则会内存指数膨胀，后边的按数组存放即可，查询时直接二分法查询。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词典分词 </tag>
            
            <tag> 字典树 </tag>
            
            <tag> 字典树原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词典分词算法实现详解</title>
      <link href="/blog/2020/02/14/%E8%AF%8D%E5%85%B8%E5%88%86%E8%AF%8D%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2020/02/14/%E8%AF%8D%E5%85%B8%E5%88%86%E8%AF%8D%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p><code>中文分词</code>指的是将一段文本拆分为一系列单词的过程，这是中文信息处理的第一站，中文分词备受关注。中文分词大致分为以下两类：</p><ul><li><strong>基于词典规则</strong></li><li><strong>基于机器学习</strong></li></ul><p>这里我们主要介绍词典分词</p><br><h6 id="2-词典分词"><a href="#2-词典分词" class="headerlink" title="2.词典分词"></a>2.词典分词</h6><p><strong>词典分词</strong>是最简单，最常见的分词算法，需要的材料为：</p><ul><li><strong>一部词典</strong></li><li><strong>一套查词典的规则</strong></li></ul><p>简单来说，词典分词就是一个确定的查词与输出的规则系统。词典分词的重点不在于分词本身，而在于<strong>支撑词典的数据结构</strong>。</p><br><h6 id="3-词典分类及加载"><a href="#3-词典分类及加载" class="headerlink" title="3.词典分类及加载"></a>3.词典分类及加载</h6><p>互联网上有许多公开的中文词典，比如搜狗实验室发布的互联网词库<code>SogouW</code>，清华大学开放中文词库<code>THUOCL</code>，以及千万级巨型汉语词库<code>HanLP</code>。我们这里用<code>HanLP</code></p><br><p><code>HanLP</code>中词典的格式是一种以空格分隔的表格形式，第一列是单词本身，之后表示词性与相应的词频，下面举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">希望  v  <span class="number">386</span>  n <span class="number">96</span></span><br><span class="line">希罕  a  <span class="number">1</span></span><br><span class="line">希冀  v  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>下载的话，需要先下载好<code>HanLP</code>的数据包，推荐从<code>码云</code>直接<a href="https://gitee.com/weiyy153/HanLP/tree/1.x/data">下载</a>，<code>GitHub</code>很慢。</p><p>加载的话很简单，我们把下载好的数据包放在<code>src</code>目录下，只需要以下的代码即可完成字典的加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String,CoreDictionary.Attribute&gt; dictionary = IOUtil.loadDictionary(<span class="string">"src/HanLP/data/dictionary/CoreNatureDictionary.mini.txt"</span>);</span><br></pre></td></tr></table></figure><br><h6 id="4-词典切分算法"><a href="#4-词典切分算法" class="headerlink" title="4.词典切分算法"></a>4.词典切分算法</h6><p>词典确定之后，<strong>句子中可能含有很多词典中的词语</strong>。它们可能相互重叠，到底输出哪一个由规定的规则决定。常用的规则有以下几种（都基于完全切分过程）：</p><ul><li><strong>完全切分算法</strong></li><li><strong>正向最长匹配算法</strong></li><li><strong>逆向最长匹配算法</strong></li><li><strong>双向最长匹配算法</strong></li></ul><br><h6 id="5-完全切分算法"><a href="#5-完全切分算法" class="headerlink" title="5. 完全切分算法"></a>5. 完全切分算法</h6><p>  <code>核心思想</code>：找出一段文本中的所有单词。</p><p>  <code>代码实现</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/9 21:38</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 完全切分式的中文算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">segmentFully</span><span class="params">(String text, TreeMap&lt;String, CoreDictionary.Attribute&gt; dictionary)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; wordList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; text.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=text.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            String word = text.substring(i,j);</span><br><span class="line">            <span class="keyword">if</span> (dictionary.containsKey(word))</span><br><span class="line">            &#123;</span><br><span class="line">                wordList.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wordList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>单元测试</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(segmentFully(<span class="string">"就读北京大学"</span>, dictionary));</span><br></pre></td></tr></table></figure><p>  <code>测试结果</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[就, 就读, 读, 北, 北京, 北京大学, 京, 大, 大学, 学]</span><br></pre></td></tr></table></figure><p>  <code>结果分析</code>:</p><p>  以上的输出并不是中文分词，我们需要的是有意义的词语序列，而不是所有出现在字典中的单词所构成的列表，我们需要完善这个规则。</p><br><h6 id="6-正向最长匹配算法"><a href="#6-正向最长匹配算法" class="headerlink" title="6.正向最长匹配算法"></a>6.正向最长匹配算法</h6><p>  <code>核心思想</code>：考虑到越长的单词表达的意义越丰富，于是是我们定义单词越长优先级越高。就是在全切分的基础上添加<strong>优先输出更长的单词且扫描顺序为从前往后</strong>的规则。</p><p>  <code>代码实现</code>：​    </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/9 22:11</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 正向最长匹配中文分词算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">segmentForwardLongest</span> <span class="params">(String text, TreeMap&lt;String, CoreDictionary.Attribute&gt; dictionary)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; wordList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; text.length(); )</span><br><span class="line">    &#123;</span><br><span class="line">        String longestWord = text.substring(i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=text.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            String word = text.substring(i,j);</span><br><span class="line">            <span class="keyword">if</span> (dictionary.containsKey(word))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.length() &gt; longestWord.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    longestWord = word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.add(longestWord);</span><br><span class="line">        i += longestWord.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wordList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>单元测试</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(segmentForwardLongest(<span class="string">"就读北京大学"</span>,dictionary));</span><br><span class="line">System.out.println(segmentForwardLongest(<span class="string">"研究生命起源"</span>,dictionary));</span><br></pre></td></tr></table></figure><p>  <code>测试结果</code>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[就读, 北京大学]</span><br><span class="line">[研究生, 命, 起源]</span><br></pre></td></tr></table></figure><p>  <code>结果分析</code>：</p><p>  前一个结果更加符合预期了，但是在第二个实例中，研究生的优先级是大于研究的。我们需要解决这个优先级的冲突。</p>  <br><h6 id="7-逆向最长匹配"><a href="#7-逆向最长匹配" class="headerlink" title="7.逆向最长匹配"></a>7.逆向最长匹配</h6><p>  <code>核心思想</code>：与正向匹配的唯一区别在于扫描的方向</p><p>  <code>代码实现</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>:  22:25</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 逆向最长匹配的中文分词算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">segmentBackwardLongest</span> <span class="params">(String text, TreeMap&lt;String, CoreDictionary.Attribute&gt; dictionary)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; wordList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=text.length()-<span class="number">1</span> ; i &gt;= <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        String longestWord = text.substring(i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            String word = text.substring(j,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (dictionary.containsKey(word))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word.length() &gt; longestWord.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    longestWord = word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.add(<span class="number">0</span>,longestWord);</span><br><span class="line">        i -= longestWord.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wordList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>单元测试</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(segmentBackwardLongest(<span class="string">"研究生命起源"</span>,dictionary));</span><br><span class="line">System.out.println(segmentBackwardLongest(<span class="string">"项目的研究"</span>,dictionary));</span><br></pre></td></tr></table></figure><p>  <code>测试结果</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[研究, 生命, 起源]</span><br><span class="line">[项，目的，研究]</span><br></pre></td></tr></table></figure><p>  <code>结果分析</code>：</p><p>  虽然逆向最长匹配算法能解决一些问题，但同时也出现了新的问题。</p>  <br><h6 id="8-双向最长匹配"><a href="#8-双向最长匹配" class="headerlink" title="8.双向最长匹配"></a>8.双向最长匹配</h6><p>  <code>核心思想</code>：综合前两种规则，取长补短。规则如下所述</p><ul><li><p>同时执行正向和逆向最长匹配，若两者词数不同，则返回次数更少的一个</p></li><li><p>否则，返回两者中单字最少的那一个。单子数目相同时，优先返回逆向最长匹配的结果</p><p><code>代码实现</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/9 22:29</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 统计分词中的单字数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countingSingleChar</span><span class="params">(List&lt;String&gt; wordList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String word : wordList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">1</span>)</span><br><span class="line">            size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>: Ragty</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Date</span>: 2020/2/9 22:37</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@Description</span>: 双向最长匹配的中文分词算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">segmentBidirectional</span> <span class="params">(String text, TreeMap&lt;String, CoreDictionary.Attribute&gt; dictionary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; forwardLongest = segmentForwardLongest(text, dictionary);</span><br><span class="line">    List&lt;String&gt; backwardLongest = segmentBackwardLongest(text, dictionary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forwardLongest.size() &lt; backwardLongest.size())</span><br><span class="line">        <span class="keyword">return</span> forwardLongest;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (forwardLongest.size() &gt; backwardLongest.size())</span><br><span class="line">        <span class="keyword">return</span> backwardLongest;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (countingSingleChar(forwardLongest) &lt; countingSingleChar(backwardLongest))</span><br><span class="line">            <span class="keyword">return</span> forwardLongest;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> backwardLongest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>单元测试</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(segmentBidirectional(<span class="string">"研究生命起源"</span>,dictionary));</span><br></pre></td></tr></table></figure><p><code>测试结果</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[研究, 生命, 起源]</span><br></pre></td></tr></table></figure><p><code>结果分析</code>：</p><p>调用了两次匹配算法，所以速度上较慢，而且很多时候是帮倒忙，不实用</p></li></ul><br><h6 id="9-匹配规则效果对比"><a href="#9-匹配规则效果对比" class="headerlink" title="9.匹配规则效果对比"></a>9.匹配规则效果对比</h6><table><thead><tr><th>序号</th><th>原文</th><th>正向最长匹配</th><th>逆向最长匹配</th><th>双向最长匹配</th></tr></thead><tbody><tr><td>1</td><td>项目的研究</td><td><strong>[项目，的，研究]</strong></td><td>[项，目的，研究]</td><td>[项，目的，研究]</td></tr><tr><td>2</td><td>商品和服务</td><td>[商品，和服，务]</td><td><strong>[商品，和，服务]</strong></td><td><strong>[商品，和，服务]</strong></td></tr><tr><td>3</td><td>研究生命起源</td><td>[研究生，命, 起源]</td><td><strong>[研究, 生命, 起源]</strong></td><td><strong>[研究, 生命, 起源]</strong></td></tr></tbody></table><br><h6 id="10-词典切分算法总结"><a href="#10-词典切分算法总结" class="headerlink" title="10.词典切分算法总结"></a>10.词典切分算法总结</h6><p>由以上的表格分析，规则系统的脆弱可见一斑。规则集的维护又是是拆东墙补西墙，有时会帮倒忙。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
            <tag> 词典分词 </tag>
            
            <tag> 正向最长匹配算法 </tag>
            
            <tag> 逆向最长匹配算法 </tag>
            
            <tag> 双向最长匹配算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP概述</title>
      <link href="/blog/2020/02/10/NLP%E6%A6%82%E8%BF%B0/"/>
      <url>/blog/2020/02/10/NLP%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h6><p>自然语言处理（Nature Language Processing，NLP）是一门融合了计算机科学，人工智能以及语言学的交叉学科。<br><br></p><h6 id="2-研究目标"><a href="#2-研究目标" class="headerlink" title="2.研究目标"></a>2.研究目标</h6><p>通过机器学习等技术，<strong>让计算机学会处理人类语言</strong>，乃至实现终极目标——理解人类语言或人工智能。</p><br><h6 id="3-自然语言的处理层次"><a href="#3-自然语言的处理层次" class="headerlink" title="3.自然语言的处理层次"></a>3.自然语言的处理层次</h6><ul><li><p><strong>语音、图像和文本</strong></p><p>自然语言处理系统的输入源一共有3个，语音，图像和文本，但前两者存储的信息总量没有文本多，所以需要先<strong>转换为文本</strong>再处理，转换分别称为语音识别(Speech Recognition)和光学字符识别(OCR)。</p></li><li><p><strong>词法分析</strong></p><p>主要任务是<strong>将文本分隔为有意义的词语 **(中文分词)，</strong>消除每个词语的歧义<strong>(词性标注)，再</strong>识别出一些特殊的专有名词**(命名体识别)。</p></li><li><p><strong>信息抽取</strong></p><p>词法分析之后，文本已经呈现结构化趋势。显示为有意义的单词列表。根据单词与标签，我们可以抽取出一部分有用的信息，从简单的高频词到高级算法<strong>提取关键词</strong>。</p></li><li><p><strong>句法分析</strong></p><p>词法分析只能得到零散的词汇信息，计算机不知道词语之间的关系。句法分析的目标就是，<strong>得到句子中词语之间的关系</strong>。</p></li><li><p><strong>语义分析与篇章分析</strong></p><p>相对于句法分析来看，语义分析侧重于语义而非语法，它包括<strong>词义消歧</strong>(确定一个词在语境中的含义)、<strong>语义角色标注</strong>(标注句子中谓语与其他成分的关系)，<strong>语义依存分析</strong>(分析句子中词语之间的关系)</p></li></ul><br><h6 id="4-自然语言处理的流派"><a href="#4-自然语言处理的流派" class="headerlink" title="4.自然语言处理的流派"></a>4.自然语言处理的流派</h6><ul><li><p><strong>基于规则的专家系统</strong></p><p>设计专家针对需求而设计许多规则组成的系统，比较死板僵硬与不稳定。</p></li><li><p><strong>基于统计学的方法</strong></p><p>收集制作<code>语料库</code>，让机器根据语料库自动学习这些规则（与机器学习相结合）</p></li></ul><br><h6 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h6><p>机器学习是人工智能的子集，而NLP则是人工智能与语言学，计算机科学的交集。这个交集虽然小，它的难度却很大。为了实现理解自然语言这个宏伟目标，人们尝试了规则系统，并最终发展到基于大规模语料库的<code>统计学习系统</code>。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot 分页方法过时解决</title>
      <link href="/blog/2019/12/18/Spring%20boot%20%E5%88%86%E9%A1%B5%E6%96%B9%E6%B3%95%E8%BF%87%E6%97%B6%E8%A7%A3%E5%86%B3/"/>
      <url>/blog/2019/12/18/Spring%20boot%20%E5%88%86%E9%A1%B5%E6%96%B9%E6%B3%95%E8%BF%87%E6%97%B6%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-问题表现"><a href="#1-问题表现" class="headerlink" title="1.问题表现"></a>1.问题表现</h4><p>源代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"login_time"</span>);</span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(Integer.parseInt(page), Integer.parseInt(size), sort);</span><br></pre></td></tr></table></figure><p>报错代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Sort(org.springframework.data.domain.Sort.Direction,java.util.List&lt;java.lang.String&gt;)'</span> has <span class="keyword">private</span> access in <span class="string">'org.springframework.data.domain.Sort'</span></span><br><span class="line"></span><br><span class="line">PageRequest(<span class="keyword">int</span>, <span class="keyword">int</span>, org.springframework.data.domain.Sort)<span class="string">' has protected access in '</span>org.springframework.data.domain.PageRequest</span><br></pre></td></tr></table></figure><br><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h4><p>很明显，Spring Boot新版本中已经升级相关的类，不支持原来的写法了。</p><p>以<code>Sort</code>为例，我们看一下他的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">Sort</span>.<span class="title">Order</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5737186511678863905L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sort UNSORTED = by();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sort.Direction DEFAULT_DIRECTION;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Sort.Order&gt; orders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sort</span><span class="params">(Sort.Direction direction, List&lt;String&gt; properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="keyword">null</span> &amp;&amp; !properties.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.orders = (List)properties.stream().map((it) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Sort.Order(direction, it);</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You have to provide at least one property to sort by!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sort <span class="title">by</span><span class="params">(String... properties)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(properties, <span class="string">"Properties must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> properties.length == <span class="number">0</span> ? unsorted() : <span class="keyword">new</span> Sort(DEFAULT_DIRECTION, Arrays.asList(properties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sort <span class="title">by</span><span class="params">(List&lt;Sort.Order&gt; orders)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(orders, <span class="string">"Orders must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> orders.isEmpty() ? unsorted() : <span class="keyword">new</span> Sort(orders);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sort <span class="title">by</span><span class="params">(Sort.Order... orders)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(orders, <span class="string">"Orders must not be null!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sort(Arrays.asList(orders));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sort <span class="title">by</span><span class="params">(Sort.Direction direction, String... properties)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(direction, <span class="string">"Direction must not be null!"</span>);</span><br><span class="line">        Assert.notNull(properties, <span class="string">"Properties must not be null!"</span>);</span><br><span class="line">        Assert.isTrue(properties.length &gt; <span class="number">0</span>, <span class="string">"At least one property must be given!"</span>);</span><br><span class="line">        <span class="keyword">return</span> by((List)Arrays.stream(properties).map((it) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sort.Order(direction, it);</span><br><span class="line">        &#125;).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>这里<code>Sort</code>的属性已有原来的public变为private了</strong>，而且我们原来的方法变更为Sort.by()</p><p>同理，<strong>PageRequest的原有的属性由public变为procted</strong></p><br><h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h4><p>按照新版本源码提供的方案修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sort sort = Sort.by(Sort.Order.desc(<span class="string">"create_date"</span>));</span><br><span class="line">Pageable pageable =PageRequest.of(Integer.parseInt(page), Integer.parseInt(size), sort);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jpa分页过时 </tag>
            
            <tag> PageRequest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRC循环冗余校验码原理解析(附实例)</title>
      <link href="/blog/2019/11/26/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E9%99%84%E5%AE%9E%E4%BE%8B)/"/>
      <url>/blog/2019/11/26/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E9%99%84%E5%AE%9E%E4%BE%8B)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-CRC简介"><a href="#1-CRC简介" class="headerlink" title="1.CRC简介"></a>1.CRC简介</h4><p><code>CRC循环冗余校验码</code>是数据通信中的一种查错校验码。</p><br><h4 id="2-CRC原理"><a href="#2-CRC原理" class="headerlink" title="2.CRC原理"></a>2.CRC原理</h4><p>CRC 算法的基本思想是将传输的数据<code>[M(X)]</code> 当做一个位数很长的数。将这个数除以另一个数[G(X)] ,得到的余数[R(X)] 作为校验数据附加到原数据后面,组成循环校验码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M(X)代表待编码的有效信息</span><br><span class="line">G(X)代表约定好的多项式</span><br><span class="line">R(X)代表代表检验位</span><br></pre></td></tr></table></figure><p>由于，<strong>CRC的结构 = 信息位(N位) + 校验位(K位)</strong></p><p>所以，<strong>CRC编码 = M(X) + R(X)</strong></p><br><h4 id="3-CRC编码方法"><a href="#3-CRC编码方法" class="headerlink" title="3.CRC编码方法"></a>3.CRC编码方法</h4><ul><li><p>把待编码的N位有效信息位表示为多项式M(X)</p></li><li><p>把M(X)左移K位，得到<code>M(X)*X^K</code>，这样就空出了K位，以便拼接K位余数，<strong>这里的<code>K</code>位是由多项式<code>G(X)</code>的最高位决定的</strong></p></li><li><p>选取一个生成多项式G(x)，对<code>M(X)*X^K</code>做<strong>模二除</strong> (多项式G(X)一般会直接给你，模二除看下面例子，<strong>实质是异或运算</strong>)，以下是运算公式</p><p><strong>( <code>M(X) * X^K</code> ) / G(X) = Q(X) + R(X) / G(X)</strong></p><p>这里的<code>Q(X)</code>是商，它本身不重要，<strong>这里最重要的是求出余数<code>R(X)</code></strong></p></li><li><p>将信息位M(X)与余数R(X)拼接起来，构成CRC循环冗余校验码</p><p><strong>CRC编码 = M(X) + R(X)</strong></p></li></ul><br><h4 id="4-举个栗子"><a href="#4-举个栗子" class="headerlink" title="4.举个栗子"></a>4.举个栗子</h4><p>题目：<strong>选择产生多项式位1011，把4位有效信息1100编成CRC码</strong></p><ul><li><p>M(X) = X^3 + X^2 = 1100</p></li><li><p>M(X) * X^3 = X^6 + X^5 = 1100000 （<strong>这里多项式最高位位3，左移3位</strong>）</p></li><li><p>G(X) = X^3 +X +1 = 1011</p></li><li><p>( <code>M(X) * X^K</code> ) / G(X) = 1100000 / 1011 =  1110 + <code>010</code> / 1011 (<strong>关键</strong>，这里进行模二运算，<strong>实质上是异或运算</strong>，求<code>R(X)</code>)<br><img src="https://img-blog.csdnimg.cn/20191126153117465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 经运算，此时确定R(X)为 <code>010</code></p></li><li><p>此时得出CRC编码 = M(X) + R(X) = 1100010</p></li></ul><br><h4 id="5-CRC编码的校验"><a href="#5-CRC编码的校验" class="headerlink" title="5.CRC编码的校验"></a>5.CRC编码的校验</h4><p>校验原理：<strong>将得到的CRC码用约定的G(X)去除，余数为0，结果正确 ，某一位出错，则余数不为0</strong></p><p>纠错的话，与G(X)的选择有关系，这方面比较深，<strong>考研大纲不考察纠错这块的知识点</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRC循环冗余校验码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉明码原理解析(清晰实例讲解)</title>
      <link href="/blog/2019/11/25/%E6%B1%89%E6%98%8E%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E6%B8%85%E6%99%B0%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3)/"/>
      <url>/blog/2019/11/25/%E6%B1%89%E6%98%8E%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E6%B8%85%E6%99%B0%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-汉明码实质及原理"><a href="#1-汉明码实质及原理" class="headerlink" title="1.汉明码实质及原理"></a>1.汉明码实质及原理</h4><p>汉明码实质上是<strong>多重奇偶校验</strong>，其实现原理是：在有效信息位中加入几个校验位形成汉明码，使码距比较均匀的拉大。<strong>具有检验并纠正一位错误的能力</strong>。</p><br><h4 id="2-核心公式介绍"><a href="#2-核心公式介绍" class="headerlink" title="2.核心公式介绍"></a>2.核心公式介绍</h4><p><strong>2^k &gt;= N+K+1</strong></p><p>其中，<code>K</code>代表<strong>校验位的位数</strong>，<code>N</code>代表<strong>信息位的位数</strong></p><p>下面是 <strong>信息位N值与校验位K值的对应关系表</strong>(重要)</p><table><thead><tr><th>信息码位数(N)</th><th>1</th><th>2~4</th><th>5~11</th><th>12~26</th><th>27~57</th><th align="center">58~120</th></tr></thead><tbody><tr><td>校验码位数(M)</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td align="center">7</td></tr></tbody></table><br><h4 id="3-确定校验位的位置"><a href="#3-确定校验位的位置" class="headerlink" title="3.确定校验位的位置"></a>3.确定校验位的位置</h4><p>根据上表确定校验码位数之后，将它插入到信息码中(这里信息码用D表示，校验码用P表示)，规则是：</p><ul><li><strong>校验码Pi 必须是在2的i-1次方位置，即只能放在H1，H2，H4，H8…</strong></li><li><strong>这里指的位置都是从右向左排序（信息码和校验码都一样）</strong></li></ul><p>举个例子，现有一个<code>4位信息码(D1,D2,D3,D4)</code>，它的排列是这样的：</p><p>D4 D3 D2  <strong>P3</strong>  D1 <strong>P2</strong>  <strong>P1</strong> </p><p>知道位置之后，下一步就是确定校验位的值了</p><br><h4 id="4-确定校验位的值-核心）"><a href="#4-确定校验位的值-核心）" class="headerlink" title="4.确定校验位的值(核心）"></a>4.确定校验位的值(核心）</h4><p>我之前是卡在这一步了，我觉得大部分博客没有直观的将这部分相关的知识讲到位，都是含糊其辞，其实用对方法后，是很简单的，下面是确定校验位值的思路：</p><ul><li><strong>根据校验位的位数，确定每个位置占用的校验位号</strong></li><li><strong>根据参与校验的信息位的位置，确定信息位的值(异或计算)</strong></li></ul><br><p>下面通过一个例子介绍，现在有一个二进制编码1011(D1,D2,D3,D4)，求它的汉明码</p><ul><li><p><strong>首先确定校验位的位数及位置</strong></p><p>信息码共<code>4</code>位，校验码通过公式计算为<code>3</code>位，一共<code>7</code>位，排列如下</p><p>D4 D3 D2  <strong>P3</strong>  D1 <strong>P2</strong>  <strong>P1</strong></p><p><strong>它的校验位的对应表如下：</strong></p></li></ul><table><thead><tr><th>位置(从右至左)</th><th>占用的校验位号</th><th align="center">备注</th></tr></thead><tbody><tr><td>1</td><td>1</td><td align="center">1=1</td></tr><tr><td>2</td><td>2</td><td align="center">2=2</td></tr><tr><td>3</td><td>1，2</td><td align="center">3=1+2</td></tr><tr><td>4</td><td>4</td><td align="center">4=4</td></tr><tr><td>5</td><td>1，4</td><td align="center">5=1+4</td></tr><tr><td>6</td><td>2，4</td><td align="center">6=2+4</td></tr><tr><td>7</td><td>1，2，4</td><td align="center">7=1+2+4</td></tr></tbody></table><br><ul><li><p><strong>确定校验位的值(敲黑板)</strong></p><p>确定各校验码 的参与校验位的信息位的位置，如下表</p></li></ul><table><thead><tr><th>校验码名称(位置)</th><th>参与校验码的信息位的位置</th></tr></thead><tbody><tr><td>P1 (位置为1)</td><td>1，3，5，7      <strong>(1出现过的位置)</strong></td></tr><tr><td>P2 (位置为2)</td><td>2，3，6，7      <strong>(2出现过的位置)</strong></td></tr><tr><td>P3 (位置为4)</td><td>4，5，6，7      <strong>(4出现过的位置)</strong></td></tr></tbody></table><p>​    <strong>现在就可以根据上表确定各校验位的值了(异或运算)：</strong></p><p>​    P1 = D1⊕D2⊕D4 = 1⊕0⊕1 = 0</p><p>​    P2 = D1⊕D3⊕D4 = 1⊕1⊕1 =1</p><p>​    P3 = D2⊕D3⊕D4 = 1⊕0⊕1 = 0</p><p>​    <strong>异或运算简单来说，就是两个相同的数结果为0，不同的数结果为1，这里看1的个数就成，偶数为0，奇数就是1</strong><br><br></p><p>所以生成的海明码为</p><p>D4 D3 D2  <strong>P3</strong>  D1 <strong>P2</strong>  <strong>P1</strong></p><p>1    1   0     <strong>0</strong>     1    <strong>1</strong>    <strong>0</strong></p><br><h4 id="5-汉明码纠正"><a href="#5-汉明码纠正" class="headerlink" title="5.汉明码纠正"></a>5.汉明码纠正</h4><p>假设传输中H6(D3)发生了错误，原码就变为：</p><p>1    <u>0</u>   0     <strong>0</strong>     1    <strong>1</strong>    <strong>0</strong></p><p>检错过程很简单，<strong>将接收到的码字重新进行奇偶校验</strong> ：</p><p>S1 = P1⊕D1⊕D2⊕D4 = 0⊕1⊕0⊕1 = 0</p><p>S2 = P2⊕D1⊕D3⊕D4 = 1⊕1⊕0⊕1 = 1</p><p>S3 = P3⊕D2⊕D3⊕D4 = 0⊕0⊕0⊕1 = 1</p><p>所以真值为<code>S3,S2,S1</code>，即110，转换为十进制为6，即第六位发生了错误，纠正</p><p>1    <u>1</u>   0     <strong>0</strong>     1    <strong>1</strong>    <strong>0</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校验码 </tag>
            
            <tag> 汉明校验码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot升级到2.2.x数据连接报错及分析</title>
      <link href="/blog/2019/11/21/Spring%20Boot%E5%8D%87%E7%BA%A7%E5%88%B02.2.x%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/11/21/Spring%20Boot%E5%8D%87%E7%BA%A7%E5%88%B02.2.x%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h4><p>最近需要升级下项目，我之前版本是<code>1.5.6</code>，升级到最新的<code>2.2.x</code>时，发现会报以下错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-11</span><span class="number">-21</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">42.998</span>  WARN <span class="number">224</span> --- [  restartedMain] com.zaxxer.hikari.util.DriverDataSource  : Registered driver <span class="keyword">with</span> driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.</span><br><span class="line"><span class="number">2019</span><span class="number">-11</span><span class="number">-21</span> <span class="number">20</span>:<span class="number">36</span>:<span class="number">47.104</span> ERROR <span class="number">224</span> --- [  restartedMain] com.zaxxer.hikari.pool.HikariPool        : HikariPool<span class="number">-1</span> - Exception during pool initialization.</span><br><span class="line">java.sql.SQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect <span class="number">3</span> times. Giving up.</span><br></pre></td></tr></table></figure><br><h4 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h4><p>问题很显然是<strong>数据库驱动找不到了</strong>，经过查阅资料，这是Spring Boot的更新日志：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Upgrade to Commons Pool2 2.6.1 #15946</span><br><span class="line">Upgrade to Lettuce 5.1.4.RELEASE #15945</span><br><span class="line">Upgrade to Lombok 1.18.6 #15928</span><br><span class="line">Upgrade to Pooled Jms Version 1.0.4 #15927</span><br><span class="line">Upgrade to Liquibase 3.6.3 #15926</span><br><span class="line">Upgrade to Mimepull 1.9.11 #15925</span><br><span class="line">Upgrade to Infinispan 9.4.6.Final #15924</span><br><span class="line">Upgrade to Groovy 2.5.6 #15923</span><br><span class="line">Upgrade to Tomcat 9.0.16 #15922</span><br><span class="line">Upgrade to Log4j2 2.11.2 #15921</span><br><span class="line">Upgrade to Artemis 2.6.4 #15920</span><br><span class="line">Upgrade to Byte Buddy 1.9.10 #15919</span><br><span class="line">Upgrade to Mysql 8.0.15 #15918</span><br></pre></td></tr></table></figure><p>日志中将<code>Mysql</code>更新到了8.0.15，新版中的Mysql引擎进行了升级，所以需要改动一下配置文件，主要是修改以下几个地方</p><ul><li><code>spring.datasource.driver-class-name</code></li><li><code>spring.datasource.url</code></li></ul><br><h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h4><p>将<code>spring.datasource.driver-class-name</code>属性替换为<code>com.mysql.cj.jdbc.Driver</code></p><p>将<code>spring.datasource.url</code>属性值替换为<code>jdbc:mysql://localhost:3306/finger?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</code></p><p>注意这里加了个对于时区的设置，默认是<code>UTC</code>，但是与我们国家的时差相差8个小时，这里我将它设置为<code>Asia/Shanghai</code>,也可设置成<code>Asia/HongKong</code></p><p>下面我贴下新版本的完整配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/finger?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=<span class="number">100</span></span><br><span class="line">spring.datasource.hikari.max-lifetime=<span class="number">27000000</span></span><br><span class="line">spring.datasource.hikari.minimum-idle=<span class="number">20</span></span><br></pre></td></tr></table></figure><br><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>主要问题在于新版本的<strong>数据库引擎进行了升级</strong>，所以需要对新版本的数据库引擎进行适配，下面是官方的更新<a href="https://github.com/spring-projects/spring-boot/releases/tag/v2.1.3.RELEASE" target="_blank" rel="noopener">日志地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot升级 </tag>
            
            <tag> 数据库连接报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>朋友圈投票活动-刷票案例实现与分析</title>
      <link href="/blog/2019/11/17/%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%8A%95%E7%A5%A8%E6%B4%BB%E5%8A%A8-%E5%88%B7%E7%A5%A8%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/11/17/%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%8A%95%E7%A5%A8%E6%B4%BB%E5%8A%A8-%E5%88%B7%E7%A5%A8%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-声明"><a href="#1-声明" class="headerlink" title="1.声明"></a>1.声明</h4><p>本文只讨论技术范畴内的刷票行为。</p><br><h4 id="2-案例描述"><a href="#2-案例描述" class="headerlink" title="2.案例描述"></a>2.案例描述</h4><p>某商城（以下简称A商城）在微信平台上举办了一场在线投票活动，微信用户可通过活动链接访问到投票页面，对喜欢的作品进行投票；每个微信帐号每天只能给单个作品投1张选票</p><br><h4 id="3-漏洞分析"><a href="#3-漏洞分析" class="headerlink" title="3.漏洞分析"></a>3.漏洞分析</h4><p>表面上看，A商城已经对投票活动进行了反作弊处理，因为限制了每个微信用户每天只能投一张票。如果用户都是正常地通过微信访问这个投票服务进行投票的话，的确是能起到预期效果的。</p><p>然而，如果查看投票页面的原始地址，即按住页面向下拖动，会发现屏幕顶端显示为”本网页由<code>XXX</code>提供”（这里的<code>&quot;XXX&quot;</code>并不是<code>&quot;mp.weixin.qq.com&quot;</code>），而是A商城的域名。也就是说，这个投票活动的程序是运行在A商城的服务器上面的。</p><p>基于以上分析，可以推断出用户投票操作的网络拓扑结构示意图应该是这样的：<br><img src="https://img-blog.csdnimg.cn/20191117214608307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>微信用户访问投票页面时，微信服务器只是进行了请求转发，具体的投票计数与校验都是在A商城的服务器上的。</p><p>那么，商城是怎么来区分投票用户的呢？</p><p>这里就涉及到微信公众平台<code>OpenID</code>的概念了。官方对<code>OpenID</code>的解释是：加密后的微信号，每个用户对每个公众号的OpenID是唯一的。要验证这一点也很容易，只需要通过采用多个微信账号进行投票，并对投票过程进行<strong>网络抓包</strong>（这一步是最关键的点，我用Charles进行的抓包，这里是关于<a href="https://blog.csdn.net/huoji555/article/details/103098969" target="_blank" rel="noopener">Charles抓包的教程</a>），这里主要是为了获取第三方的请求参数</p><p>基于这一点，微信公众平台在转发投票请求时，会在POST参数中包含用户的<code>OpenID</code>；A商城在接收到投票的POST请求后，通过查询当前<code>OpenID</code>是否在当天已经投过票，就可以阻止单一用户重复投票的行为了。</p><p>然而，这里面却存在一个很大的漏洞，<strong>A商城只能判断<code>OpenID</code>是否出现了重复，但是却无法校验<code>OpenID</code>的有效性，因为它是无法调用微信服务器来对这个<code>OpenID</code>进行校验的。</strong></p><br><h4 id="4-实现思路"><a href="#4-实现思路" class="headerlink" title="4.实现思路"></a><strong>4.实现思路</strong></h4><ul><li>抓包获取到请求参数，模拟Https请求</li><li>生成随机位数的<code>Openid</code></li><li>为防止服务器拦截请求，随机时间后向服务器发送请求</li><li>动态模拟不同的设备，即修改<code>User-Agent</code>，否则，服务端可以较为容易地识别作弊行为</li></ul><br><h4 id="5-作弊与反作弊"><a href="#5-作弊与反作弊" class="headerlink" title="5.作弊与反作弊"></a>5.作弊与反作弊</h4><p>看到这里，也许有的同学心中窃喜，以后投票都可以采用这种方式“刷票”了么？</p><p>很遗憾，当然不是。其实本文中案例的漏洞是很低级的，只是，当前的确还存在不少比例的投票活动是采用这种模式。</p><p>要判断一个投票活动是否可以采用这种方式来作弊也很简单。采用本文中的方法，若查看到活动的网址是非微信官方的，而且整个投票过程也没有额外的校验，那么实现作弊的可能性就很大了；再通过抓包看下通讯交互过程，并用网络请求工具修改参数后重新请求下，即可验证是否真的可以作弊了。</p><p>不过，活动举办方可以通过一些手段，大大提高作弊的门槛：</p><ul><li>要求投票用户先关注活动举办方的公众号，然后调用微信官方的投票功能；</li><li>要求投票用户在投票活动举办方的网站上进行注册（手机号验证、实名验证）</li></ul><p>不管采用这两种方式中的哪一种，本文中的“刷票”方法就完全失效了</p><br><h4 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6.代码实现"></a>6.代码实现</h4><p>本案例只提供实现的流程，不提供刷票的网站及参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @auther: Ragty</span></span><br><span class="line"><span class="comment"> * @describe: Get请求远程接口</span></span><br><span class="line"><span class="comment"> * @param: [url, parameters]</span></span><br><span class="line"><span class="comment"> * @return: java.lang.String</span></span><br><span class="line"><span class="comment"> * @date: 2019/1/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendGet</span><span class="params">(String url, Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String result=<span class="string">""</span>;</span><br><span class="line">    BufferedReader in = <span class="keyword">null</span>;<span class="comment">// 读取响应输入流</span></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">// 存储参数</span></span><br><span class="line">    String params = <span class="string">""</span>;<span class="comment">// 编码之后的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 编码请求参数</span></span><br><span class="line">        <span class="keyword">if</span>(parameters.size()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String name:parameters.keySet())&#123;</span><br><span class="line">                sb.append(name).append(<span class="string">"="</span>).append(java.net.URLEncoder.encode(parameters.get(name), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            params=sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : parameters.keySet()) &#123;</span><br><span class="line">                sb.append(name).append(<span class="string">"="</span>).append(java.net.URLEncoder.encode(parameters.get(name), <span class="string">"UTF-8"</span>)).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String temp_params = sb.toString();</span><br><span class="line">            params = temp_params.substring(<span class="number">0</span>, temp_params.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String full_url = url + <span class="string">"?"</span> + params;</span><br><span class="line">        System.out.println(<span class="string">"请求链接为:"</span>+full_url);</span><br><span class="line">        <span class="comment">// 创建URL对象</span></span><br><span class="line">        URL connURL = <span class="keyword">new</span> URL(full_url);</span><br><span class="line">        <span class="comment">// 打开URL连接</span></span><br><span class="line">        HttpURLConnection httpConn = (HttpURLConnection) connURL.openConnection();</span><br><span class="line">        <span class="comment">// 设置通用属性</span></span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"</span>);</span><br><span class="line">        <span class="comment">// 建立实际的连接</span></span><br><span class="line">        httpConn.connect();</span><br><span class="line">        <span class="comment">// 响应头部获取</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headers = httpConn.getHeaderFields();</span><br><span class="line">        <span class="comment">// 遍历所有的响应头字段</span></span><br><span class="line">        <span class="keyword">for</span> (String key : headers.keySet()) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">"\t：\t"</span> + headers.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义BufferedReader输入流来读取URL的响应,并设置编码方式</span></span><br><span class="line">        in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpConn.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// 读取返回的内容</span></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result += line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123; in.close(); &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @auther: Ragty</span></span><br><span class="line"><span class="comment"> * @describe: Post请求远程接口</span></span><br><span class="line"><span class="comment"> * @param: [url, parameters]</span></span><br><span class="line"><span class="comment"> * @return: java.lang.String</span></span><br><span class="line"><span class="comment"> * @date: 2019/1/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendPost</span><span class="params">(String url, Map&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String result = <span class="string">""</span>;<span class="comment">// 返回的结果</span></span><br><span class="line">    BufferedReader in = <span class="keyword">null</span>;<span class="comment">// 读取响应输入流</span></span><br><span class="line">    PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">// 处理请求参数</span></span><br><span class="line">    String params = <span class="string">""</span>;<span class="comment">// 编码之后的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 编码请求参数</span></span><br><span class="line">        <span class="keyword">if</span> (parameters.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : parameters.keySet()) &#123;</span><br><span class="line">                sb.append(name).append(<span class="string">"="</span>).append(java.net.URLEncoder.encode(parameters.get(name), <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            params = sb.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name : parameters.keySet()) &#123;</span><br><span class="line">                sb.append(name).append(<span class="string">"="</span>).append(java.net.URLEncoder.encode(parameters.get(name), <span class="string">"UTF-8"</span>)).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String temp_params = sb.toString();</span><br><span class="line">            params = temp_params.substring(<span class="number">0</span>, temp_params.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建URL对象</span></span><br><span class="line">        URL connURL = <span class="keyword">new</span> URL(url);</span><br><span class="line">        <span class="comment">// 打开URL连接</span></span><br><span class="line">        HttpURLConnection httpConn = (HttpURLConnection) connURL.openConnection();</span><br><span class="line">        <span class="comment">// 设置通用属性</span></span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"Accept"</span>, <span class="string">"*/*"</span>);</span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">        httpConn.setRequestProperty(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)"</span>);</span><br><span class="line">        <span class="comment">// 设置POST方式</span></span><br><span class="line">        httpConn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">        httpConn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取HttpURLConnection对象对应的输出流</span></span><br><span class="line">        out = <span class="keyword">new</span> PrintWriter(httpConn.getOutputStream());</span><br><span class="line">        <span class="comment">// 发送请求参数</span></span><br><span class="line">        out.write(params);</span><br><span class="line">        <span class="comment">// flush输出流的缓冲</span></span><br><span class="line">        out.flush();</span><br><span class="line">        <span class="comment">// 定义BufferedReader输入流来读取URL的响应，设置编码方式</span></span><br><span class="line">        in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpConn.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// 读取返回的内容</span></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result += line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123; out.close(); &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123; in.close(); &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 生成OpenId</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>   2019/11/14 18:17</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Exception</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createOpenId</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    String val = <span class="string">""</span>;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        String charOrNum = random.nextInt(<span class="number">2</span>) % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">"char"</span> : <span class="string">"num"</span>; <span class="comment">// 输出字母还是数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"char"</span>.equalsIgnoreCase(charOrNum)) <span class="comment">// 字符串</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> choice = random.nextInt(<span class="number">2</span>) % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">65</span> : <span class="number">97</span>; <span class="comment">// 取得大写字母还是小写字母</span></span><br><span class="line">            val += (<span class="keyword">char</span>) (choice + random.nextInt(<span class="number">26</span>));</span><br><span class="line">            val += (<span class="keyword">char</span>) (choice + random.nextInt(<span class="number">26</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"num"</span>.equalsIgnoreCase(charOrNum)) <span class="comment">// 数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            val += String.valueOf(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>  进行一次投票</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>   2019/11/14 18:24</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Exception</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">voteOnce</span><span class="params">(String voteid, String voteUrl)</span> </span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; request = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">    String openId = createOpenId(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里放请求参数</span></span><br><span class="line">    request.put(<span class="string">"name"</span>,<span class="string">"ragty"</span>);</span><br><span class="line">    request.put(<span class="string">"openid"</span>,openId);</span><br><span class="line">    String result = sendPost(voteUrl,request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>  莫得感情的投票机器(这里加个随机模拟)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>   2019/11/14 18:26</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Exception</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">voteMachine</span><span class="params">(String voteId, <span class="keyword">int</span> voteNumber, String voteUrl)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    Random random =  <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=voteNumber; i++) &#123;</span><br><span class="line">        voteOnce(voteId,voteUrl);</span><br><span class="line">        System.out.println(<span class="string">"进行第"</span>+i+<span class="string">"次投票,投票成功 "</span>);</span><br><span class="line">        <span class="keyword">int</span> randomTime = random.nextInt(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"下次投票时间间隔为:"</span>+randomTime/<span class="number">1000</span>);</span><br><span class="line">        Thread.sleep(randomTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"投票结束，本次共投"</span>+voteNumber+<span class="string">"票"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">   voteMachine(<span class="string">"11"</span>,<span class="number">10</span>,<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 移动端抓包 </tag>
            
            <tag> 朋友圈刷票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Charles对移动设备抓包</title>
      <link href="/blog/2019/11/16/%E4%BD%BF%E7%94%A8Charles%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%8A%93%E5%8C%85/"/>
      <url>/blog/2019/11/16/%E4%BD%BF%E7%94%A8Charles%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-Charles简介"><a href="#1-Charles简介" class="headerlink" title="1.Charles简介"></a>1.Charles简介</h4><p><code>Charles</code>是一款代理服务器，通过成为电脑或者浏览器的代理，然后截取请求和请求结果达到分析抓包的目的。该软件是用Java写的，能够在Windows，Mac，Linux上使用，<strong>安装Charles的时候要先装好Java环境</strong>。这里是破解版的<a href="https://pan.baidu.com/s/1Ii9bn8FBHE1Ho6aCDH_5zg" target="_blank" rel="noopener">下载链接</a>，提取码是：<strong>fjoo</strong><br><br><br></p><h4 id="2-Charles主要功能"><a href="#2-Charles主要功能" class="headerlink" title="2.Charles主要功能"></a>2.Charles主要功能</h4><ul><li>支持SSL代理。可以截取分析SSL的请求。</li><li>支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求</li><li>支持AJAX调试。可以自动将json或xml数据格式化，方便查看</li><li>支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看</li><li>支持重发网络请求，方便后端调试</li><li>支持修改网络请求参数</li><li>支持网络请求的截获并动态修改</li><li>检查HTML，CSS和RSS内容是否符合W3C标准<br></li></ul><h4 id="3-Charles使用"><a href="#3-Charles使用" class="headerlink" title="3.Charles使用"></a>3.Charles使用</h4><ul><li><strong>证书安装</strong><img src="https://img-blog.csdnimg.cn/20191116152917101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>抓电脑的包选择 <code>install Charles Root Certificate</code><br>抓移动端的包选择<code>install Charles Root Certificate on mobile Device or Remote Browser</code></li></ul><p><strong>这里记得安装证书时，需要将证书添加到受信任的证书列表</strong><br><br></p><ul><li><strong>设置Https抓包</strong><br>默认没开启https抓包，需要设置 SSL 代理：通过主菜单打开 <strong>Proxy | SSL Proxy Settings</strong> 弹窗，勾选 <code>Enable SSL proxying</code>，点击<code>Add</code>按钮，可以过滤出允许https访问的网址，如果没有特殊需求，可将这里设置为*，意为全部匹配<br><img src="https://img-blog.csdnimg.cn/2019111615304067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br></li></ul><ul><li><strong>浏览器的选择(划重点)</strong><br>需要注意的是，<code>Chrome</code>和 <code>Firefox</code>浏览器默认并不使用系统的代理服务器设置，而 Charles是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 <code>Chrome</code> 和 <code>Firefox</code>浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成<code>127.0.0.1:8888</code> 也可达到相同效果。<br></li></ul><ul><li><strong>找不到<code>request</code>和<code>response</code></strong><br>新版本的Charles默认没打开<code>request</code>和<code>response</code>，打开Edit-&gt;prefrence，选择Viewers，将默认的<code>Combine request and response</code>勾去掉即可<img src="https://img-blog.csdnimg.cn/201911161531376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br></li></ul><h4 id="4-对PC端抓包"><a href="#4-对PC端抓包" class="headerlink" title="4.对PC端抓包"></a>4.对PC端抓包</h4><p>现在的配置就可以对PC端进行抓包了，我这里在浏览器中访问百度，搜索关键词<code>123456</code>,得到以下结果，可以在<code>Request</code>中找到我的搜索项<br><img src="https://img-blog.csdnimg.cn/20191116153250321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>抓取到的响应数据</strong><br><img src="https://img-blog.csdnimg.cn/2019111615333233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><br><h4 id="4-在移动端抓包"><a href="#4-在移动端抓包" class="headerlink" title="4.在移动端抓包"></a>4.在移动端抓包</h4><ul><li><p><strong>在移动端和PC端安装证书</strong></p><p>PC端安装证书在前边讲过了，不予赘述</p><p>移动端安装证书需要访问移动端浏览器，在网址输入栏键入<code>chls.pro/ssl</code>，下载好证书后，需要安装证书，我这里用的是ipad，需要在设置-&gt;通用-&gt;描述文件-&gt;选择证书，信任，然后还有亿点小插曲</p><p>我的设备是ios10.3，按照上述证书信任后，还不能正确抓包，因为这个还没有正确信任，它提示你<code>Client SSL handshake failed: An unknown issue occurrenotepadd processing the certificate (certificate_unknown)</code></p><p><strong>解决方案</strong>：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy CA然后信任该证书即可.<br><img src="https://img-blog.csdnimg.cn/20191116153417585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><br><ul><li><p><strong>配置代理</strong></p><p>确认当前移动设备与安装charles的电脑在同一局域网下，选择<strong>配置代理</strong>一项，选择手动</p><p><strong>配置IP地址</strong>：在服务器一栏键入安装Charles电脑的IP地址(可通过cmd的ipconfig查看或者通过Charles的Help一栏查看)</p><p><strong>配置端口</strong>：在Charles中寻找Proxy-&gt;proxy Settings查看端口，默认为8888</p><p><strong>然后你的PC端会发送一个请求，允许代理</strong> </p></li></ul><br><ul><li><p><strong>代理后移动端无网络的解决方案</strong></p><p>需要将系统的防火墙关闭，即可正常访问网络</p><p><strong>最后抓完包记得将代理关闭(敲黑板)</strong></p></li></ul><br><ul><li><p><strong>试着抓个包</strong></p><p>打开<code>Bilibili</code>，搜索一下我女朋友的名字<code>新垣结衣</code>，出现以下界面<br><img src="https://img-blog.csdnimg.cn/20191116153642956.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我们看一下Charles中我的请求<code>keyword：新垣结衣</code><br><img src="https://img-blog.csdnimg.cn/20191116153738608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后是抓取到的关于我老婆的一点信息：<img src="https://img-blog.csdnimg.cn/20191116154019813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h4 id="5-总结一下"><a href="#5-总结一下" class="headerlink" title="5.总结一下"></a>5.总结一下</h4><p>其实，抓包什么的不太重要，我只是来秀我老婆的</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Charles </tag>
            
            <tag> 抓包 </tag>
            
            <tag> 移动端抓包 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法（三）堆排序及有界堆排序Java实现及分析</title>
      <link href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9C%89%E7%95%8C%E5%A0%86%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%9C%89%E7%95%8C%E5%A0%86%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><br><h6 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h6><p>基数排序适用于大小有界的东西，除了他之外，还有一种你可能遇到的其它专用排序算法：有界堆排序。如果你在处理非常大的数据集，你想要得到前 10 个或者前<code>k</code>个元素，其中<code>k</code>远小于<code>n</code>，它是很有用的。</p><p>例如，假设你正在监视一 个Web 服务，它每天处理十亿次事务。在每一天结束时，你要汇报最大的<code>k</code>个事务（或最慢的，或者其它最 xx 的）。一个选项是存储所有事务，在一天结束时对它们进行排序，然后选择最大的<code>k</code>个。需要的时间与<code>nlogn</code>成正比，这非常慢，因为我们可能无法将十亿次交易记录在单个程序的内存中。我们必须使用“外部”排序算法。</p><p>我们首先了解一下堆，这是一个类似于二叉搜索树（BST）的数据结构。有一些区别：</p><ul><li>在 BST 中，每个节点<code>x</code>都有“BST 特性”：<code>x</code>左子树中的所有节点都小于<code>x</code>，右子树中的所有节点都大于<code>x</code>。</li><li>在堆中，每个节点<code>x</code>都有“堆特性”：两个子树中的所有节点都大于<code>x</code>。</li><li>堆就像平衡的 BST；当你添加或删除元素时，他们会做一些额外的工作来重新使树平衡。因此，可以使用元素的数组来有效地实现它们。</li></ul><blockquote><p>现在讨论的是小根堆。如果子树中的节点都小于根节点，则为大根堆。</p></blockquote><p>堆中最小的元素总是在根节点，所以我们可以在常数时间内找到它。在堆中添加和删除元素需要的时间与树的高度<code>h</code>成正比。而且由于堆总是平衡的，所以<code>h</code>与<code>log n</code>成正比。</p><p>Java<code>PriorityQueue</code>使用堆实现。<code>PriorityQueue</code>提供<code>Queue</code>接口中指定的方法，包括<code>offer</code>和<code>poll</code>：</p><ul><li><code>offer</code>：将一个元素添加到队列中，更新堆，使每个节点都具有“堆特性”。需要<code>logn</code>的时间。</li><li><code>poll</code>：从根节点中删除队列中的最小元素，并更新堆。需要<code>logn</code>的时间。</li></ul><p>给定一个<code>PriorityQueue</code>，你可以像这样轻松地排序的<code>n</code>个元素的集合 ：</p><ul><li>使用<code>offer</code>，将集合的所有元素添加到<code>PriorityQueue</code>。</li><li>使用<code>poll</code>从队列中删除元素并将其添加到<code>List</code>。</li></ul><p>因为<code>poll</code>返回队列中剩余的最小元素，所以元素按升序添加到<code>List</code>。这种排序方式称为堆排序 。</p><p>向队列中添加<code>n</code>个元素需要<code>nlogn</code>的时间。删除<code>n</code>个元素也是如此。所以堆排序的运行时间是<code>O(n logn)</code>。</p><p><br><br></p><h6 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2.代码实现："></a>2.代码实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 堆排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 19:15 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       PriorityQueue&lt;T&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;T&gt;(list.size(),comparator);</span><br><span class="line">       heap.addAll(list);</span><br><span class="line">       list.clear();</span><br><span class="line">       <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">           list.add(heap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">sorter.heapSort(list, comparator);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p><br><br></p><h6 id="3-有界堆排序"><a href="#3-有界堆排序" class="headerlink" title="3.有界堆排序"></a>3.有界堆排序</h6><p>有界堆是一个限制为最多包含<code>k</code>个元素的堆。如果你有<code>n</code>个元素，你可以跟踪这个最大的<code>k</code>个元素：</p><p>最初堆是空的。对于每个元素<code>x</code>：</p><ul><li>分支 1：如果堆不满，请添加<code>x</code>到堆中。</li><li>分支 2：如果堆满了，请与堆中<code>x</code>的最小元素进行比较。如果<code>x</code>较小，它不能是最大的<code>k</code>个元素之一，所以你可以丢弃它。</li><li>分支 3：如果堆满了，并且<code>x</code>大于堆中的最小元素，请从堆中删除最小的元素并添加<code>x</code>。</li></ul><p>使用顶部为最小元素的堆，我们可以跟踪最大的<code>k</code>个元素。我们来分析这个算法的性能。对于每个元素，我们执行以下操作之一：</p><ul><li>分支 1：将元素添加到堆是<code>O(log k)</code>。</li><li>分支 2：找到堆中最小的元素是<code>O(1)</code>。</li><li>分支 3：删除最小元素是<code>O(log k)</code>。添加<code>x</code>也是<code>O(log k)</code>。</li></ul><p>在最坏的情况下，如果元素按升序出现，我们总是执行分支 3。在这种情况下，处理<code>n</code>个元素的总时间是<code>O(n log k)</code>，对于<code>n</code>是线性的。</p><p><br><b></p><h6 id="4-代码实现："><a href="#4-代码实现：" class="headerlink" title="4.代码实现："></a>4.代码实现：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 有界堆排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 19:49 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">topK</span><span class="params">(<span class="keyword">int</span> k,List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       PriorityQueue&lt;T&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;T&gt;(list.size(),comparator);</span><br><span class="line">       <span class="keyword">for</span> (T element : list) &#123;</span><br><span class="line">           <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">               heap.offer(element);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> cmp = comparator.compare(element,heap.peek());</span><br><span class="line">           <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>) &#123;</span><br><span class="line">               heap.poll();</span><br><span class="line">               heap.offer(element);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;T&gt; res = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">           res.add(heap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">List&lt;Integer&gt; queue = sorter.topK(<span class="number">4</span>, list, comparator);</span><br><span class="line">System.out.println(queue);</span><br></pre></td></tr></table></figure><p><br><br></p><h6 id="5-空间复杂性"><a href="#5-空间复杂性" class="headerlink" title="5.空间复杂性"></a>5.空间复杂性</h6><p>到目前为止，我们已经谈到了很多运行时间的分析，但是对于许多算法，我们也关心空间。例如，归并排序的一个缺点是它会复制数据。在我们的实现中，它分配的空间总量是<code>O(n log n)</code>。通过优化，可以将空间降至<code>O(n)</code>。</p><p>相比之下，插入排序不会复制数据，因为它会原地排序元素。它使用临时变量来一次性比较两个元素，并使用一些其它局部变量。但它的空间使用不取决于<code>n</code>。</p><p>我们的堆排序实现创建了新<code>PriorityQueue</code>，来存储元素，所以空间是<code>O(n)</code>; 但是如果你能够原地对列表排序，则可以使用<code>O(1)</code>的空间执行堆排序 。</p><p>刚刚实现的有界堆栈算法的一个好处是，它只需要与<code>k</code>成正比的空间（我们要保留的元素的数量），而<code>k</code>通常比<code>n</code>小得多 。</p><p>软件开发人员往往比空间更加注重运行时间，对于许多应用程序来说，这是适当的。但是对于大型数据集，空间可能同等或更加重要。例如：</p><ul><li>如果一个数据集不能放入一个程序的内存，那么运行时间通常会大大增加，或者根本不能运行。如果你选择一个需要较少空间的算法，并且这样可以将计算放入内存中，则可能会运行得更快。同样，使用较少空间的程序，可能会更好地利用 CPU 缓存并运行速度更快。</li><li>在同时运行多个程序的服务器上，如果可以减少每个程序所需的空间，则可以在同一台服务器上运行更多程序，从而降低硬件和能源成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构-排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
            <tag> 有界堆排序 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法（二）归并排序Java实现及分析</title>
      <link href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FJava%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><br><h6 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h6><blockquote><p>归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</p><p>如　设有数列{6，202，100，301，38，8，1}</p><p>初始状态：6,202,100,301,38,8,1</p><p>第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；</p><p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p><p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p><p>总的比较次数为：3+4+4=11；逆序数为14；</p></blockquote><p><img src="https://images2015.cnblogs.com/blog/1023577/201610/1023577-20161011232321687-190186195.png" alt=""></p><p><br><br></p><h6 id="2-归并排序分析"><a href="#2-归并排序分析" class="headerlink" title="2.归并排序分析"></a>2.归并排序分析</h6><p>为了对归并排序的运行时间进行划分，对递归层级和每个层级上完成多少工作方面进行思考，是很有帮助的。假设我们从包含<code>n</code>个元素的列表开始。以下是算法的步骤：</p><ul><li>生成两个新数组，并将一半元素复制到每个数组中。</li><li>排序两个数组。</li><li>合并两个数组。</li></ul><p>流程图如下：</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/17-1.jpg" alt=""></p><p>第一步复制每个元素一次，因此它是线性的。第三步也复制每个元素一次，因此它也是线性的。现在我们需要弄清楚步骤<code>2</code>的复杂性。为了做到这一点，查看不同的计算图片会有帮助，它展示了递归的层数，如下图所示。</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/17-2.jpg" alt=""></p><blockquote><p>上图为<strong>归并排序的展示</strong>，它展示了递归的所有层级。</p></blockquote><p>在顶层，我们有<code>1</code>个列表，其中包含<code>n</code>个元素。为了简单起见，我们假设<code>n</code>是<code>2</code>的幂。在下一层，有<code>2</code>个列表包含<code>n/2</code>个元素。然后是<code>4</code>个列表与<code>n/4</code>元素，以此类推，直到我们得到<code>n</code>个列表与<code>1</code>元素。</p><p>在每一层，我们共有<code>n</code>个元素。在下降的过程中，我们必须将数组分成两半，这在每一层上都需要与<code>n</code>成正比的时间。在回来的路上，我们必须合并<code>n</code>个元素，这也是线性的。</p><p>如果层数为<code>h</code>，算法的总工作量为<code>O(nh)</code>。那么有多少层呢？有两种方法可以考虑：</p><ul><li>我们用多少步，可以将<code>n</code>减半直到<code>1</code>？</li><li>或者，我们用多少步，可以将<code>1</code>加倍直到<code>n</code>？</li></ul><p>第二个问题的另一种形式是“<code>2</code>的多少次方是<code>n</code>”？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^h &#x3D; n</span><br></pre></td></tr></table></figure><p>对两边取以<code>2</code>为底的对数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &#x3D; log2(n)</span><br></pre></td></tr></table></figure><p>所以总时间是<code>O(nlogn)</code>。我没有纠结于对数的底，因为底不同的对数差别在于一个常数，所以所有的对数都是相同的增长级别。</p><p><code>O(nlogn)</code>中的算法有时被称为“线性对数”的，但大多数人只是说<code>n log n</code>。</p><p>事实证明，<code>O(nlogn)</code>是通过元素比较的排序算法的理论下限。这意味着没有任何“比较排序”的增长级别比<code>n log n</code>好。</p><p><br><br></p><h6 id="3-归并排序实现"><a href="#3-归并排序实现" class="headerlink" title="3.归并排序实现"></a>3.归并排序实现</h6><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 归并排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:02 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSortInplace</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; sorted = mergeSort(list,comparator);</span><br><span class="line">       list.clear();</span><br><span class="line">       list.addAll(sorted);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 分割list并排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:10 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">mergeSort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size = list.size();</span><br><span class="line">       <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>  list;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每次让list中的元素减半(递归)</span></span><br><span class="line">       List&lt;T&gt; first = mergeSort(<span class="keyword">new</span> LinkedList&lt;T&gt;(list.subList(<span class="number">0</span>,size/<span class="number">2</span>)),comparator);</span><br><span class="line">       List&lt;T&gt; second = mergeSort(<span class="keyword">new</span> LinkedList&lt;T&gt;(list.subList(size/<span class="number">2</span>,size)),comparator);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> merge(first,second,comparator);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 将两个排序好的list,合并为一个排序好的List(常数时间)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:19 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">merge</span><span class="params">(List&lt;T&gt; first,List&lt;T&gt; second, Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       List&lt;T&gt; result = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">       <span class="keyword">int</span> total = first.size()+second.size();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;total; i++) &#123;</span><br><span class="line">           List&lt;T&gt; winner = pickWinner(first,second,comparator);</span><br><span class="line">           result.add(winner.remove(<span class="number">0</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 返回第一个元素较小的list,任意列表为空，返回另一个list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 10:52 2019/6/12</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">pickWinner</span><span class="params">(List&lt;T&gt; first,List&lt;T&gt; second,Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (first.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> second;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (second.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> first;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> res = comparator.compare(first.get(<span class="number">0</span>),second.get(<span class="number">0</span>));</span><br><span class="line">       <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> first;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> second;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  first;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">sorter.mergeSortInplace(list, comparator);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构-排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 归并排序Java实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法（一） 插入排序及Java实现</title>
      <link href="/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2019/06/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><br><blockquote><p>插入排序是一种简单的排序算法，从头遍历数组，依此比较排序</p></blockquote><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;T&gt; comparator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">           T elt_i = list.get(i);</span><br><span class="line">           <span class="keyword">int</span> j = i;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">               T elt_j = list.get(j-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span> (comparator.compare(elt_i,elt_j)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               list.set(j,elt_j);</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           list.set(j,elt_i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer elt1, Integer elt2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> elt1.compareTo(elt2);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     ListSorter&lt;Integer&gt; sorter = <span class="keyword">new</span> ListSorter&lt;Integer&gt;();</span><br><span class="line">     sorter.insertionSort(list, comparator);</span><br><span class="line">     System.out.println(list);</span><br></pre></td></tr></table></figure><p><code>insertionSort</code>有两个嵌套循环，所以你可能会猜到，它的运行时间是二次的。在这种情况下，一般是正确的，但你做出这个结论之前，你必须检查，每个循环的运行次数与<code>n</code>，数组的大小成正比。</p><p>外部循环从<code>1</code>迭代到<code>list.size()</code>，因此对于列表的大小<code>n</code>是线性的。内循环从<code>i</code>迭代到<code>0</code>，所以在<code>n</code>中也是线性的。因此，两个循环运行的总次数是二次的。</p><p>如果你不确定，这里是证明：</p><p>第一次循环中，<code>i = 1</code>，内循环最多运行一次。 第二次，<code>i = 2</code>，内循环最多运行两次。 最后一次，<code>i = n - 1</code>，内循环最多运行<code>n</code>次。</p><p>因此，内循环运行的总次数是序列<code>1, 2, ..., n - 1</code>的和，即<code>n(n - 1)/2</code>。该表达式的主项（拥有最高指数）为<code>n^2</code>。</p><p>在最坏的情况下，插入排序是二次的。然而：</p><ul><li>如果这些元素已经有序，或者几乎这样，插入排序是线性的。具体来说，如果每个元素距离它的有序位置不超过<code>k</code>个元素，则内部循环不会运行超过<code>k</code>次，并且总运行时间是<code>O(kn)</code>。</li><li>由于实现简单，开销较低；也就是，尽管运行时间是<code>an^2</code>，主项的系数<code>a</code>，也可能是小的。</li></ul><p>所以如果我们知道数组几乎是有序的，或者不是很大，插入排序可能是一个不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构-排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎优化-TF_IDF之Java实现</title>
      <link href="/blog/2019/06/07/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%20%20%20%20TF_IDF%E4%B9%8BJava%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2019/06/07/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%20%20%20%20TF_IDF%E4%B9%8BJava%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>实现之前，我们要事先说明一些问题：</p><p>我们用Redis对数据进行持久化，存两种形式的MAP:</p><ul><li>key值为term，value值为含有该term的url</li><li>key值为url，value值为map，记录term及在文章中出现的次数</li></ul><p>总的计算公式如下：</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/10109d0e60cc9d50a1ea2f189bac0ac29a030a00" alt=""></p><br><h4 id="1-计算词频TF"><a href="#1-计算词频TF" class="headerlink" title="1.计算词频TF"></a>1.计算词频<strong>TF</strong></h4><blockquote><p>这里通过给出url地址，获取搜索词<strong>term</strong>在此url中的数量，计算出TF</p></blockquote><br><p><strong>获取url中的词汇总数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取url中的词汇总数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 11:18 2019/6/4</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getWordCount</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">       String redisKey = urlSetKey(url);</span><br><span class="line">       Map&lt;String,String&gt; map = jedis.hgetAll(redisKey);</span><br><span class="line">       Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123;</span><br><span class="line">           count += Integer.valueOf(entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><p><strong>返回搜索项在url中出现的次数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span> 返回搜索项在url中出现的次数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span> 22:12 2019/5/14</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getTermCount</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">      String redisKey = urlSetKey(url);</span><br><span class="line">      String count = jedis.hget(redisKey,term);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(count);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br><p><strong>获取搜索词的词频</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取搜索词的词频(Term Frequency)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 11:25 2019/6/4</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getTermFrequency</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isIndexed(url)) &#123;</span><br><span class="line">           System.out.println(<span class="string">"Doesn't indexed."</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Integer documentCount = getWordCount(url);</span><br><span class="line">       Integer termCount = getTermCount(url,term);</span><br><span class="line">       <span class="keyword">return</span> documentCount==<span class="number">0</span> ? <span class="keyword">new</span> BigDecimal(<span class="number">0</span>) :  <span class="keyword">new</span> BigDecimal(termCount).divide(<span class="keyword">new</span> BigDecimal(documentCount),<span class="number">6</span>,BigDecimal.ROUND_HALF_UP);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h4 id="2-计算逆文档频率"><a href="#2-计算逆文档频率" class="headerlink" title="2.计算逆文档频率"></a>2.计算逆文档频率</h4><blockquote><p>计算逆文档频率，需要计算文档总数，以及包含该搜索词的文章数</p></blockquote><br><p><strong>获取redis索引文章的总数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取redis索引文章的总数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 19:46 2019/6/5</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getUrlCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer count = <span class="number">0</span>;</span><br><span class="line">    count = urlSetKeys().size();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>获取含有搜索词的文章数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取含有搜索词的文章数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 22:42 2019/6/5</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">getUrlTermCount</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">       Integer count = <span class="number">0</span>;</span><br><span class="line">       count = getUrls(term).size();</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><p><strong>计算逆文档频率IDF(InverseDocumnetFrequency)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 计算逆文档频率IDF(InverseDocumnetFrequency)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:32 2019/6/5</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getInverseDocumentFrequency</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">       Integer totalUrl = getUrlCount();</span><br><span class="line">       Integer urlTermCount = getUrlTermCount(term);</span><br><span class="line">       Double xx = <span class="keyword">new</span> BigDecimal(totalUrl).divide(<span class="keyword">new</span> BigDecimal(urlTermCount),<span class="number">6</span>,BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">       BigDecimal idf = <span class="keyword">new</span> BigDecimal(Math.log10(xx));</span><br><span class="line">       <span class="keyword">return</span> idf;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h4 id="3-获取TF-IDF"><a href="#3-获取TF-IDF" class="headerlink" title="3.获取TF-IDF"></a>3.获取TF-IDF</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span> 获取tf-idf值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Date</span> 23:34 2019/6/5</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getTFIDF</span><span class="params">(String url,String term)</span> </span>&#123;</span><br><span class="line">      BigDecimal tf = getTermFrequency(url, term);</span><br><span class="line">      BigDecimal idf = getInverseDocumentFrequency(term);</span><br><span class="line">      BigDecimal tfidf  =tf.multiply(idf);</span><br><span class="line">      <span class="keyword">return</span> tfidf;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h4 id="4-数据测试"><a href="#4-数据测试" class="headerlink" title="4.数据测试"></a>4.数据测试</h4><blockquote><p>这里我采用我自己爬取的部分数据，进行一下简单的测试(可能因为数据集的原因导致部分结果不准确)</p></blockquote><p><strong>测试类方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 获取tfidf下的相关性</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 8:47 2019/6/6</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title">getRelevance</span><span class="params">(String url,String term,JedisIndex index)</span> </span>&#123;</span><br><span class="line">       BigDecimal tfidf = index.getTFIDF(url,term);</span><br><span class="line">       <span class="keyword">return</span> tfidf;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 执行搜索</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 23:49 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WikiSearch <span class="title">search</span><span class="params">(String term,JedisIndex index)</span> </span>&#123;</span><br><span class="line">       Map&lt;String,BigDecimal&gt; map = <span class="keyword">new</span> HashMap&lt;String, BigDecimal&gt;();</span><br><span class="line">       Set&lt;String&gt; urls = index.getUrls(term);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">           BigDecimal tfidf = getRelevance(url,term,index).setScale(<span class="number">6</span>,BigDecimal.ROUND_HALF_UP);</span><br><span class="line">           map.put(url,tfidf);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(map);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 按搜索项频率顺序打印内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 13:46 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Entry&lt;String,BigDecimal&gt;&gt; entries = sort();</span><br><span class="line">       <span class="keyword">for</span>(Entry&lt;String,BigDecimal&gt; entry: entries) &#123;</span><br><span class="line">           System.out.println(entry.getKey()+<span class="string">"         "</span>+entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 根据相关性对数据排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 13:54 2019/5/30</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Entry&lt;String,BigDecimal&gt;&gt; sort()&#123;</span><br><span class="line">       List&lt;Entry&lt;String,BigDecimal&gt;&gt;  entries = <span class="keyword">new</span> LinkedList&lt;Entry&lt;String, BigDecimal&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">       Comparator&lt;Entry&lt;String,BigDecimal&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Entry&lt;String, BigDecimal&gt;&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, BigDecimal&gt; o1, Entry&lt;String, BigDecimal&gt; o2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Collections.sort(entries,comparator);</span><br><span class="line">       <span class="keyword">return</span> entries;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><p><strong>测试代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Jedis jedis = JedisMaker.make();</span><br><span class="line">       JedisIndex index = <span class="keyword">new</span> JedisIndex(jedis);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// search for the first term</span></span><br><span class="line">       String term1 = <span class="string">"java"</span>;</span><br><span class="line">       System.out.println(<span class="string">"Query: "</span> + term1);</span><br><span class="line">       WikiSearch search1 = search(term1, index);</span><br><span class="line">       search1.print();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// search for the second term</span></span><br><span class="line">       String term2 = <span class="string">"programming"</span>;</span><br><span class="line">       System.out.println(<span class="string">"Query: "</span> + term2);</span><br><span class="line">       WikiSearch search2 = search(term2, index);</span><br><span class="line">       search2.print();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><p><strong>测试结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Query: java</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/LiveScript         0.029956</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Java/85979         0.019986</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Brendan%20Eich         0.017188</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87/471435         0.013163</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Sun/69463         0.005504</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Rhino         0.004401</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E         0.003452</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/javascript         0.002212</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/js/10687961         0.002212</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%BA%90%E7%A0%81         0.002205</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%BA%90%E7%A0%81/344212         0.002205</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         0.001989</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/SQL         0.001779</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/PHP/9337         0.001503</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/iOS/45705         0.001499</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Netscape         0.000863</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F         0.000835</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Mac%20OS%20X         0.000521</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         0.000318</span></span><br><span class="line"></span><br><span class="line">Query: programming</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         0.004854</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         0.002529</span></span><br></pre></td></tr></table></figure><p>以上只提供部分代码及思路，完整的搜索引擎代码及tf_idf实现，请参照Github</p><p>代码地址：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure/SearchEngine" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure/SearchEngine</a></p>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TF-IDF </tag>
            
            <tag> 搜索引擎优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TF-IDF算法概述及模型构建</title>
      <link href="/blog/2019/06/01/TF-IDF%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/"/>
      <url>/blog/2019/06/01/TF-IDF%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%8F%8A%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h4><p>我在构建搜索引擎的时候，需要构建一个排名算法。我最初版本的做法为，根据一篇文章中词汇出现的频率，对各个网页进行排序。这样会有一个很明显的缺点，当我们页面中出现很多<strong>中止词（例如，the,1,2）</strong>时，这样不能客观反映搜索词对文档的重要程度。</p><p><strong>我们需要调整某些单词在一般情况下更频繁出现的事实（过滤中止词）</strong>。TF-IDF值（搜索词的重要性），随着单词在文件中出现的次数成正比增加，但同时会随着它在包含该单词的所有文档中出现的频率成反比下降(从这里可以推出TF-IDF的公式)，<strong>从而获取该文章关于搜索词重要性的权值。</strong></p><blockquote><p>TF-IDF是当今最受欢迎的术语加权方案之一，旨在反映搜索词对集合中文档的重要程度。</p><p>它的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p></blockquote><p>应用方面：</p><ul><li><strong>搜索引擎</strong>经常使用tf-idf加权方案，作为在给定用户查询的情况下对文档的相关性进行评分和排序的核心工具。tf-idf可以成功地用于各种主题领域的停止词过滤，包括文本摘要的分类。</li><li>通过对每个查询项的tf-idf求和来计算最简单的<strong>排名函数之一</strong> ; 许多更复杂的排名函数是这个简单模型的变体。</li></ul><br><h4 id="2-TF-IDF解释"><a href="#2-TF-IDF解释" class="headerlink" title="2.TF-IDF解释"></a>2.TF-IDF解释</h4><p><strong>TF(Term Frequency)</strong>：表示词汇频率。</p><p>假设我们有一套英文文本文档，并希望对与查询最相关的文档进行排名，搜索词为<code>The Brown cow</code>.我们最简单的方法是，删除不包含<code>the</code>，<code>brown</code>，<code>cow</code>所有这些词的文档，但如此操作后，仍剩余许多文档。为了进一步区分它们，需要计算这些搜索词在文档中出现的次数，<strong>我们将搜索词在文档中出现的频率称作词频(TF)</strong>，这个数字是对<strong>词数（Term Count）</strong>的归一化，以防止它偏向长的文件(<strong>同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否</strong>)。</p><p>如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。这种搜索词加权可归纳为：</p><blockquote><p>文档中出现的搜索词的权重与搜索词频率成正比</p></blockquote><p>TF的不足之处：</p><blockquote><p>它不能有效的过滤<code>中止词</code>，例如上述提到的<code>the</code></p></blockquote><p><strong>IDF(Inverse document frequency)</strong>：表示逆向文档频率。</p><blockquote><p>IDF是一个词语普遍重要性的度量(过滤中止词)</p></blockquote><p>接着上面的例子讲，因为搜索词<code>the</code>很常见，<strong>TF(Term Frequency)</strong>倾向于错误地强调更频繁地使用“the”一词的文档（这里可以将<code>the</code>看作为中止词），<strong>而没有给予更有意义的术语“brown”和“cow”足够的权重</strong>。与不常见的单词“brown”和“cow”不同，术语“the”不是区分相关和非相关文档和术语的好关键词。因此，结合了<strong>逆文档频率因子</strong>，其减少了在文档集中频繁出现的术语的权重（<strong>降低中止词权重</strong>），并且增加了很少出现的词语的权重。这种加权可以归纳为：</p><blockquote><p>词语的特异性可以量化为其<strong>出现的文档数量的反函数</strong></p></blockquote><br><h4 id="3-模型解释"><a href="#3-模型解释" class="headerlink" title="3.模型解释"></a>3.模型解释</h4><blockquote><p><code>TF-IDF</code>是两个统计量的乘积。有多种方法可以确定统计量的具体值。</p></blockquote><p><strong>词频(TF)</strong></p><p>在<strong>术语频率</strong> tf（<em>t</em>，<em>d</em>）的情况下，最简单的选择是使用文档中单词的原始计数，f(t,d)即单词<strong>t</strong>在文档<strong>d</strong>中出现的次数，即(t/d)。最简单的tf方案是tf（<em>t</em>，<em>d</em>）= <em>f</em> (t,d)。其他可能性包括：</p><ul><li>布尔“频率”：TF（t,d）= 1，如果d中出现t为1，否则为0;</li><li>根据文件长度调整的词频： f(t,d)/ (d中的总词数);</li><li>对数缩放频率：TF（t,d）= log（1 +  f(t,d) ） ; </li><li>增加频率，以防止偏向更长的文档，例如原始频率除以文档中最常出现的单词的原始频率：</li></ul><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/da4be29a89f4c67ff5a8ad0c7355df1aff67a65b" alt=""></p><p><code>词频（tf）权重的变体</code></p><table><thead><tr><th align="left">加权计划</th><th align="left">权重</th></tr></thead><tbody><tr><td align="left">二进制</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a019735e07635e5a74673d6e1a34919027e645f5" alt="{0,1}"></td></tr><tr><td align="left">原始计数</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/69faba5875c1ba7d6a3820c813ba22fba35185f5" alt=""></td></tr><tr><td align="left">期限频率(使用最频繁)</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/91699003abf4fe8bdf861bbce08e73e71acf5fd4" alt=""></td></tr><tr><td align="left">日志规范化</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c173382612c58c00325c4e9f593739ab3afc324" alt=""></td></tr><tr><td align="left">双标准化K.</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/65b776d7a3f8e42f15c880fb7582282b987684fe" alt=""></td></tr><tr><td align="left">双归一化0.5</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45badc1c70ec2caa00ed8c21ed75bd9f8d3e650c" alt=""></td></tr></tbody></table><p><strong>IDF（逆向文档频率）</strong></p><blockquote><p><strong>对文档中的罕见词进行加权</strong>(通过将文档总数除以包含该项的文档数，然后取该商的对数得到).</p></blockquote><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ac67bc0f76b5b8e31e842d6b7d28f8949dab7937" alt=""></p><p>N表示语料库中的文档总数</p><p>tf(t,d)表示包含搜索词的文档数，搜索词不在语料库中时为0。则这将导致除零。因此，通常将分母调整为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/104921c6994a66054acc909a6bb811a47f983a53" alt=""></p><p>利用  <strong>lg1=0</strong>  解决0的问题</p><p><code>IDF（逆向文档频率）权重的变体</code></p><table><thead><tr><th align="left">加权计划</th><th align="center">（IDF权重）    <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e5d6fca54b5ec3fa4680ead41736fc1c16a58ca1" alt=""></th></tr></thead><tbody><tr><td align="left">一元</td><td align="center">1</td></tr><tr><td align="left">逆文档频率</td><td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/864fcfdc0c16344c11509f724f1aa7081cf9f657" alt="{\ displaystyle \ log {\ frac {N} {n_ {t}}} =  -  \ log {\ frac {n_ {t}} {N}}}"></td></tr><tr><td align="left">逆文档频率平滑</td><td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/23e5ae785c1ddc6bd95d404ea3fac2477fff5eff" alt=""></td></tr><tr><td align="left">逆文档频率最大值</td><td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f15c125a1d7f1327afeecc4e2b89272a9a094338" alt=""></td></tr><tr><td align="left">概率逆文档频率</td><td align="center"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1868194cba8431aa2d556dd1aac90d78833eaaf3" alt=""></td></tr></tbody></table><p><strong>TF-IDF</strong></p><p>下面给出<code>TF-IDF</code>的计算公式</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/10109d0e60cc9d50a1ea2f189bac0ac29a030a00" alt=""></p><p><code>TF-DIF模型原理解释</code></p><blockquote><p>通过高频词汇(在给定文件中）达到tf-idf的高权重，并且在整个文档集合中该搜索词的文档频率低; 因此，权重倾向于过滤掉常用术语。<strong>由于idf的log函数内的比率始终大于或等于1(比率为1时，idf值为0)</strong>，因此idf（和tf-idf）的值大于或等于0.当一个术语出现在更多文档中时，对数内的比率接近1 ，使idf和tf-idf更接近0。</p></blockquote><p><strong>nt越大(中止词越多)，比率越接近于1，idf的值越接近于0.</strong></p><p><code>推荐的加权组合方案</code></p><table><thead><tr><th align="center">加权计划</th><th align="left">文档搜索词权重</th><th align="left">查询搜索词权重</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74db3d91105b74e8450a78fadbf7ea7f241bc737" alt=""></td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fe1629098093a97eb293bd5085009c51c3cdd77b" alt=""></td></tr><tr><td align="center">2</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dc85c57525999f9f224ac5623e606bea2160d171" alt=""></td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29f34f3a19a3fec371d5ab2756896a4c3cfc0d96" alt=""></td></tr><tr><td align="center">3</td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c271425fa07254a10379f1379e02d0fd034f4f21" alt=""></td><td align="left"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cb8cdf7f351b63973cee045cc98c9efcde04203a" alt=""></td></tr></tbody></table><br><h4 id="4-实例展示"><a href="#4-实例展示" class="headerlink" title="4.实例展示"></a>4.实例展示</h4><blockquote><p>在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用” 相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它们在一篇特定网页中的词频分别是: TF1, TF2, …, TFN.（TF: term frequency)。 那么，这个查询和该网页的相关性就是:TF1 + TF2 + … + TFN。<br>在上面的例子中，词“的”占了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“中止词”（Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删除词后，上述网页的相似度就变成了0.007，其中“原子能”贡献了 0.002，“应用”贡献了 0.005。细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词，而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p></blockquote><ul><li>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次，对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</li><li>应删除词的权重应该是零。</li></ul><blockquote><p>我们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们看到它仍然不是很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键词 w 在 Dw 个网页中出现过，那么 Dw 越大，w的权重越小，反之亦然。在信息检索中，使用最多的权重是“逆文本频率指数” （Inverse document frequency 缩写为IDF），它的公式为log（D/Dw）其中D是全部网页数。比如，我们假定中文网页数是D=10亿，应删除词“的”在所有的网页中都出现，即Dw=10亿，那么它的IDF=log(10亿/10亿）= log (1) = 0。假如专用词“原子能”在两百万个网页中出现，即Dw=200万，则它的权重IDF=log(500) =2.7。又假定通用词“应用”，出现在五亿个网页中，它的权重IDF = log(2)则只有 0.3。也就是说，在网页中找到一个“原子能”的匹配相当于找到九个“应用”的匹配。利用 IDF，上述相关性计算的公式就由词频的简单求和变成了加权求和，即 TF1<em>IDF1 +　TF2</em>IDF2 +… + TFN*IDFN。在上面的例子中，该网页和“原子能的应用”的相关性为 0.0069，其中“原子能”贡献了 0.0054，而“应用”只贡献了0.0015。这个比例和我们的直觉比较一致了。</p></blockquote><br><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>本质上IDF是一种试图抑制噪音的加权 ，并且<strong>单纯地认为文本频数小的单词就越重要</strong>，<strong>文本频数大的单词就越无用</strong>，显然这并不是完全正确的。IDF的简单结构并<strong>不能有效地反映单词的重要程度和特征词的分布情况</strong>，使其无法很好地完成对权值调整的功能，所以TFIDF法的精度并不是很高。</p><p>我们在构建搜索引擎时，特征词在不同的标记符中对文章内容的反映程度不同，其权重的计算方法也应不同。<strong>因此应该对于处于网页不同位置的特征词分别赋予不同的系数，然后乘以特征词的词频，以提高文本表示的效果</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 搜索引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TF-IDF </tag>
            
            <tag> TF </tag>
            
            <tag> IDF </tag>
            
            <tag> 模型构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十七） 布尔搜索</title>
      <link href="/blog/2019/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%20%E5%B8%83%E5%B0%94%E6%90%9C%E7%B4%A2/"/>
      <url>/blog/2019/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%20%E5%B8%83%E5%B0%94%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>接着上一节的内容，我们已经构建了一个爬取百度百科并持久化的爬虫。现在客户使用，我们需要构建一个搜索工具。</p><h6 id="1-信息检索"><a href="#1-信息检索" class="headerlink" title="1.信息检索"></a>1.信息检索</h6><p>这个项目的下一个阶段是实现一个搜索工具。我们需要的部分包括：</p><ul><li>一个界面，其中用户可以提供检索词并查看结果。</li><li>一种查找机制，它接收每个检索词并返回包含它的页面。</li><li><strong>用于组合来自多个检索词的搜索结果的机制</strong>。</li><li>对搜索结果<strong>打分和排序的算法</strong>。</li></ul><br><h6 id="2-布尔搜索"><a href="#2-布尔搜索" class="headerlink" title="2.布尔搜索"></a>2.布尔搜索</h6><p>大多数搜索引擎可以执行“布尔搜索”，这意味着你<strong>可以使用布尔逻辑来组合来自多个检索词的结果</strong>。例如：</p><ul><li>搜索“java + 编程”（加号可省略）可能只返回包含两个检索词：“java”和“编程”的页面。</li><li>“java OR 编程”可能会返回包含任一检索词但不一定同时出现的页面。</li><li>“java -印度尼西亚”可能返回包含“java”，不包含“印度尼西亚”的页面。</li></ul><p><strong>包含检索词和运算符的表达式称为“查询”。</strong></p><p>当应用给搜索结果时，布尔操作符<code>+</code>，<code>OR</code>和<code>-</code>对应于集合操作 交，并和差。例如，假设</p><ul><li><code>s1</code>是包含“java”的页面集，</li><li><code>s2</code>是包含“编程”的页面集，以及</li><li><code>s3</code>是包含“印度尼西亚”的页面集。</li></ul><p>在这种情况下：</p><ul><li><code>s1</code>和<code>s2</code>的交集是含有“java”和“编程”的页面集。</li><li><code>s1</code>和<code>s2</code>的并集是含有“java”或“编程”的页面集。</li><li><code>s1</code>与<code>s2</code>的差集是含有“java”而不含有“印度尼西亚”的页面集。</li></ul><p>布尔搜索实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算两个搜索结果的并集(更广了)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:13 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">or</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; union = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">     <span class="keyword">for</span>(String term: that.map.keySet()) &#123;</span><br><span class="line">         union.put(term,totalRelevence(<span class="keyword">this</span>.getRelevance(term),that.getRelevance(term)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(union);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算搜索项的交集</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:22 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">and</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; intersection = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">     <span class="keyword">for</span>(String term: that.map.keySet()) &#123;</span><br><span class="line">         <span class="keyword">if</span>(map.containsKey(term)) &#123;</span><br><span class="line">             intersection.put(term,totalRelevence(<span class="keyword">this</span>.getRelevance(term),that.getRelevance(term)));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> WikiSearch(intersection);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Description</span> 计算搜索项的差集</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@Date</span> 23:35 2019/5/30</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> WikiSearch <span class="title">minus</span><span class="params">(WikiSearch that)</span> </span>&#123;</span><br><span class="line">     Map&lt;String,Integer&gt; difference = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">     <span class="keyword">for</span> (String term: that.map.keySet()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (difference.containsKey(term)) &#123;</span><br><span class="line">             difference.remove(term);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> WikiSearch(difference);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><h6 id="3-打分排序"><a href="#3-打分排序" class="headerlink" title="3.打分排序"></a>3.打分排序</h6><p>现在需要根据检索词获取用户最需要的数据，<code>WikiSearch</code>对象包含 URL 到它们的相关性分数的映射。在信息检索的上下文中，<strong>“相关性分数”用于表示页面多么满足从查询推断出的用户需求</strong>。相关性分数的构建有很多种方法，但大部分都基于“检索词频率”，它是搜索词在页面上的显示次数。一种常见的相关性分数称为 TF-IDF，代表“<strong>检索词频率 - 逆向文档频率”</strong>。</p><p>下面是<code>WikiSearch</code>的初始构造:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map from URLs that contain the term(s) to relevance score</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiSearch</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRelevance</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        Integer relevance = map.get(url);</span><br><span class="line">        <span class="keyword">return</span> relevance==<span class="keyword">null</span> ? <span class="number">0</span>: relevance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WikiSearch</code>对象包含 URL 到它们的相关性分数的映射。在信息检索的上下文中，<strong>“相关性分数”用于表示页面多么满足从查询推断出的用户需求</strong>。相关性分数的构建有很多种方法，但大部分都基于“检索词频率”，它是搜索词在页面上的显示次数。一种常见的相关性分数称为 TF-IDF，代表“检索词频率 - 逆向文档频率”。</p><p>我们将从一些更简单的 TF 开始：</p><ul><li>如果查询包含单个检索词，页面的相关性就是其词频；也就是说该词在页面上出现的次数。</li><li>对于具有多个检索词的查询，页面的相关性是检索词频率的总和；也就是说，任何检索词出现的总次数。</li></ul><p>搜索结果排序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Entry&lt;String,Integer&gt;&gt; sort()&#123;</span><br><span class="line">     List&lt;Entry&lt;String,Integer&gt;&gt;  entries = <span class="keyword">new</span> LinkedList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Entry&lt;String,Integer&gt;&gt; comparator = <span class="keyword">new</span> Comparator&lt;Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     Collections.sort(entries,comparator);</span><br><span class="line">     <span class="keyword">return</span> entries;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有两个<code>sort</code>版本：</p><ul><li>单参数版本接受列表并使用它的<code>compareTo</code>方法对元素进行排序，因此元素必须是<code>Comparable</code>。</li><li>双参数版本接受任何对象类型的列表和一个<code>Comparator</code>，它是一个提供<code>compare</code>方法的对象，用于比较元素。</li></ul><br><h6 id="4-检索测试"><a href="#4-检索测试" class="headerlink" title="4.检索测试?"></a>4.检索测试?</h6><p>下面提供检索代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Jedis jedis = JedisMaker.make();</span><br><span class="line">        JedisIndex index = <span class="keyword">new</span> JedisIndex(jedis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search for the first term</span></span><br><span class="line">        String term1 = <span class="string">"java"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term1);</span><br><span class="line">        WikiSearch search1 = search(term1, index);</span><br><span class="line">        search1.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search for the second term</span></span><br><span class="line">        String term2 = <span class="string">"programming"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term2);</span><br><span class="line">        WikiSearch search2 = search(term2, index);</span><br><span class="line">        search2.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the intersection of the searches</span></span><br><span class="line">        System.out.println(<span class="string">"Query: "</span> + term1 + <span class="string">" AND "</span> + term2);</span><br><span class="line">        WikiSearch intersection = search1.and(search2);</span><br><span class="line">        intersection.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检索结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Query: java?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Java/85979         38</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E6%AC%A7%E6%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8         12</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E7%94%B2%E9%AA%A8%E6%96%87/471435         10</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/PHP/9337         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Brendan%20Eich         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Rhino         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/LiveScript         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/Sun/69463         4</span></span><br><span class="line"></span><br><span class="line">Query: programming?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         6</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         1</span></span><br><span class="line"></span><br><span class="line">Query: java AND programming?</span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/C%E8%AF%AD%E8%A8%80         7</span></span><br><span class="line">https:<span class="comment">//baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80         3</span></span><br></pre></td></tr></table></figure><br><h6 id="5-搜索优化"><a href="#5-搜索优化" class="headerlink" title="5.搜索优化"></a>5.搜索优化</h6><p>现存的问题：</p><blockquote><p>若同一主题的文章，A1万字，它的关键词出现的次数肯定会高，B100字，出现的次数肯定会少。对于具有多个检索词的查询，每个页面的总体相关性目前是每个检索词的相关性的总和。但实际上采用我们上述所用的方法不能客观的去选出内容最符合的文章。</p></blockquote><p>我们需要的解决方案：</p><blockquote><p>去掉网络<strong>中止词</strong>后，显示一个词在文本中所出现的频率，频率越高，则说明该搜索词与文章的相关性越大。</p><p>后期可用<code>TF-IDF</code>算法优化</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布尔搜索 </tag>
            
            <tag> 搜索优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十六）爬取百度百科</title>
      <link href="/blog/2019/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/"/>
      <url>/blog/2019/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-基于Redis的索引器"><a href="#1-基于Redis的索引器" class="headerlink" title="1.基于Redis的索引器"></a>1.基于Redis的索引器</h6><p>在我的解决方案中，我们在 Redis 中存储两种结构：</p><ul><li>对于每个检索词，我们有一个<code>URLSet</code>，它是一个 Redis 集合，包含检索词的 URL。</li><li>对于每个网址，我们有一个<code>TermCounter</code>，这是一个 Redis 哈希表，将每个检索词映射到它出现的次数。</li></ul><p>在<code>JedisIndex</code>中，我提供了一个方法，它可以接受一个检索词并返回 Redis 中它的<code>URLSet</code>的键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">urlSetKey</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"URLSet:"</span>+url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个方法，接受 URL 并返回 Redis 中它的<code>TermCounter</code>的键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">termCounterKey</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TermCounter:"</span>+term;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是<code>indexPage</code>的实现（索引化一个界面）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexPage</span><span class="params">(String url, Elements elements)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Indexing..."</span> + url);</span><br><span class="line"></span><br><span class="line">       TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">       tc.processElements(elements);</span><br><span class="line"></span><br><span class="line">       pushTermCounterToRedis(tc);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>为了索引页面，我们：</p><ul><li>为页面内容创建一个 Java 的<code>TermCounter</code>，使用上一个练习中的代码。</li><li>将<code>TermCounter</code>的内容推送到 Redis。</li></ul><p>以下是将<code>TermCounter</code>的内容推送到 Redis 的新代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">pushTermCounterToRedis</span><span class="params">(TermCounter tc)</span> </span>&#123;</span><br><span class="line">    Transaction t = jedis.multi();</span><br><span class="line"></span><br><span class="line">    String url = tc.getLabel();</span><br><span class="line">    String redisKey = urlSetKey(url);</span><br><span class="line">    t.del(redisKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String term: tc.keySet()) &#123;</span><br><span class="line">        Integer count = tc.get(term);</span><br><span class="line">        t.hset(redisKey, term, count.toString());</span><br><span class="line">        t.sadd(termCounterKey(term),url);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Object&gt; res = t.exec();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法使用<code>Transaction</code>来收集操作，<strong>并将它们一次性发送到服务器，这比发送一系列较小操作要快得多</strong>。</p><p>它遍历<code>TermCounter</code>中的检索词。对于每一个，它：</p><ul><li>在 Redis 上寻找或者创建<code>TermCounter</code>，然后为新的检索词添加字段。</li><li>在 Redis 上寻找或创建<code>URLSet</code>，然后添加当前的 URL。</li></ul><p>如果页面已被索引，则<code>TermCounter</code>在推送新内容之前删除旧页面 。</p><p>这里还需要<code>getCounts</code>，它需要一个检索词，并从该词出现的每个网址返回一个映射。这是我的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getCounts</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    Set&lt;String&gt; urls = getURLs(term);</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        Integer count = getCount(url, term);</span><br><span class="line">        map.put(url, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法使用两种辅助方法：</p><ul><li><code>getURLs</code>接受检索词并返回该字词出现的网址集合。</li><li><code>getCount</code>接受 URL 和检索词，并返回该检索词在给定 URL 处显示的次数。</li></ul><p>以下是实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getURLs</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = jedis.smembers(termCounterKey(term));</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">(String url, String term)</span> </span>&#123;</span><br><span class="line">    String redisKey = urlSetKey(url);</span><br><span class="line">    String count = jedis.hget(redisKey, term);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h6 id="2-查找的分析"><a href="#2-查找的分析" class="headerlink" title="2.查找的分析"></a>2.查找的分析</h6><p>假设我们索引了<code>N</code>个页面，并发现了<code>M</code>个唯一的检索词。检索词的查询需要多长时间？在继续之前，先考虑一下你的答案。</p><p>要查找一个检索词，我们调用<code>getCounts</code>，其中：</p><ul><li>创建映射。</li><li>调用<code>getURLs</code>来获取 URL 的集合。</li><li>对于集合中的每个 URL，调用<code>getCount</code>并将条目添加到<code>HashMap</code>。</li></ul><p><code>getURLs</code><strong>所需时间与包含检索词的网址数成正比</strong>。对于罕见的检索词，这可能是一个很小的数字，但是对于常见检索词，它可能和<code>N</code>一样大。</p><p>在循环中，我们调用了<code>getCount</code>，它在 Redis 上寻找<code>TermCounter</code>，查找一个检索词，并向<code>HashMap</code>添加一个条目。那些都是常数时间的操作，所以在最坏的情况下，<code>getCounts</code>的整体复杂度是<code>O(N)</code>。然而实际上，运行时间正比于包含检索词的页面数量，通常比<code>N</code>小得多。</p><p>这个算法根据复杂性是有效的，但是它非常慢，因为它向 <strong>Redis 发送了许多较小的操作</strong>。</p><p>解决办法：利用事务，解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Integer&gt; <span class="title">getCountsFaster</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将set集合转换为list,以便每次都有相同的遍历顺序</span></span><br><span class="line">    List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    urls.addAll(getUrls(term));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个事务执行所有查询</span></span><br><span class="line">    Transaction t = jedis.multi();</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        String redisKey = urlSetKey(url);</span><br><span class="line">        t.hget(redisKey,term);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Object&gt; res = t.exec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历结果，制造出map</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String url: urls) &#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        Integer count = <span class="keyword">new</span> Integer((String)res.get(i++));</span><br><span class="line">        map.put(url,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h6 id="3-索引的分析"><a href="#3-索引的分析" class="headerlink" title="3.索引的分析"></a>3.索引的分析</h6><p>使用我们设计的数据结构，页面的索引需要多长时间？再次考虑你的答案，然后再继续。</p><p>为了索引页面，我们遍历其 DOM 树，找到所有<code>TextNode</code>对象，并将字符串拆分成检索词。这一切都与页面上的单词数成<strong>正比</strong>。</p><p>对于每个检索词，我们在<code>HashMap</code>中增加一个计数器，这是一个常数时间的操作。所以创建<code>TermCounter</code>的所需时间与页面上的单词数成正比。</p><p>将<code>TermCounter</code>推送到 Redis ，需要删除<code>TermCounter</code>，对于唯一检索词的数量是线性的。那么对于每个检索词，我们必须：</p><ul><li>向<code>URLSet</code>添加元素，并且</li><li>向 Redis<code>TermCounter</code>添加元素。</li></ul><p>这两个都是常数时间的操作，所以推送<code>TermCounter</code>的总时间对于唯一检索词的数量是线性的。</p><p>总之，<code>TermCounter</code>的创建与页面上的单词数成正比。向 Redis 推送<code>TermCounter</code>与唯一检索词的数量成正比。</p><p>由于页面上的单词数量通常超过唯一检索词的数量，因此整体复杂度与页面上的单词数成正比。理论上，一个页面可能包含索引中的所有检索词，因此最坏的情况是<code>O(M)</code>，但实际上我们并不期待看到更糟糕的情况。</p><p>这个分析提出了一种提高效率的方法：<strong>我们应该避免索引很常见的词语（停止词）</strong>。首先，他们占用了大量的时间和空间，因为它们出现在几乎每一个<code>URLSet</code>和<code>TermCounter</code>中。此外，它们不是很有用，因为它们不能帮助识别相关页面。</p><br><h6 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4.图的遍历"></a>4.图的遍历</h6><p>如果你在第七章中完成了“到达哲学”练习，你已经有了一个程序，它读取页面，找到第一个链接，使用链接加载下一页，然后重复。这个程序是一种专用的爬虫，但是当人们说“网络爬虫”时，他们通常意味着一个程序：</p><p><strong>加载起始页面并对内容进行索引， 查找页面上的所有链接</strong>，并将链接的 URL 添加到集合中 通过收集，加载和索引页面，以及添加新的 URL，来按照它的方式工作。 如果它找到已经被索引的 URL，会跳过它。</p><p>你可以将 Web 视为图，其中每个页面都是一个节点，每个链接都是从一个节点到另一个节点的有向边。</p><p><strong>从源节点开始，爬虫程序遍历该图，访问每个可达节点一次。</strong></p><p>我们用于存储 URL 的集合决定了爬虫程序执行哪种遍历：</p><ul><li>如果它是先进先出（FIFO）的队列，则爬虫程序将执行广度优先遍历。</li><li>如果它是后进先出（LIFO）的栈，则爬虫程序将执行深度优先遍历。</li><li>更通常来说，集合中的条目可能具有优先级。例如，我们可能希望对尚未编入索引的页面给予较高的优先级。</li></ul><br><h6 id="5-构建WikiCrawler"><a href="#5-构建WikiCrawler" class="headerlink" title="5.构建WikiCrawler"></a>5.构建WikiCrawler</h6><blockquote><p>构建这个类的主要目的为爬取百度百科，并将爬取过的数据持久化，方便日后查询</p></blockquote><p>需要使用到的类：</p><ul><li><code>JedisMaker.java</code></li><li><code>WikiFetcher.java</code></li><li><code>TermCounter.java</code></li><li><code>WikiNodeIterable.java</code></li></ul><p>这里提供<code>WikiCrawler</code>的起始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiCrawler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String source;</span><br><span class="line">    <span class="keyword">private</span> JedisIndex index;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> WikiFetcher wf = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiCrawler</span><span class="params">(String source, JedisIndex index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        queue.offer(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里边的变量代表为：</p><ul><li><code>source</code>是我们开始抓取的网址。</li><li><code>index</code>是<code>JedisIndex</code>，连接Redis做数据持久化，结果应该放进这里。</li><li><code>queue</code>是<code>LinkedList</code>，这里面我们跟踪已发现但尚未编入索引的网址。</li><li><code>wf</code>是<code>WikiFetcher</code>，我们用来读取和解析网页。</li></ul><p>下面是<code>crawl()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">crawl</span><span class="params">(<span class="keyword">boolean</span> testing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String url = queue.poll();</span><br><span class="line">     System.out.println(<span class="string">"Crawling..."</span>+ url);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (testing==<span class="keyword">false</span> &amp;&amp; index.isIndexed(url)) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Already indexed."</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Elements para;</span><br><span class="line">     <span class="keyword">if</span> (testing) &#123;</span><br><span class="line">         para = wf.readWikiPedia(url);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         para = wf.fetchWikiPedia(url);</span><br><span class="line">     &#125;</span><br><span class="line">     index.indexPage(url,para);</span><br><span class="line">     queueInternalLinks(para);</span><br><span class="line">     <span class="keyword">return</span> url;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法主要用来获取队列中的Url地址并索引化</p></blockquote><p>当传递参数 testing为true时:</p><ul><li>以 FIFO 的顺序从队列中选择并移除一个 URL。</li><li>使用<code>WikiFetcher.readWikipedia</code>读取页面的内容</li><li>它应该索引页面，而不管它们是否已经被编入索引。</li><li>它应该找到页面上的所有内部链接，并按他们出现的顺序将它们添加到队列中。</li><li>它应该返回其索引的页面的 URL</li></ul><p>当传递参数为<code>false</code>时</p><ul><li>以 FIFO 的顺序从队列中选择并移除一个 URL。</li><li>如果 URL 已经被编入索引，它不应该再次索引，并应该返回<code>null</code>。</li><li>否则它应该使用<code>WikiFetcher.fetchWikipedia</code>读取页面内容，从 Web 中读取当前内容。</li><li>然后，它应该对页面进行索引，将链接添加到队列，并返回其索引的页面的 URL。</li></ul><p>下面提供一下其中用到的<code>queueInternalLinks()</code></p><blockquote><p>该方法的主要作用为<strong>解析para,并将内部链接添加到队列</strong></p></blockquote><p>下面是该方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 解析para,并将内部链接添加到队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 11:38 2019/5/22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queueInternalLinks</span><span class="params">(Elements paras)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element para: paras) &#123;</span><br><span class="line">        queueInternalLinks(para);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 单个段落解析并添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 11:39 2019/5/22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueInternalLinks</span><span class="params">(Element para)</span> </span>&#123;</span><br><span class="line">    Elements elts = para.select(<span class="string">"a[href]"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Element element: elts) &#123;</span><br><span class="line">        String relURL = element.attr(<span class="string">"href"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to fix</span></span><br><span class="line">        <span class="keyword">if</span> (relURL.startsWith(<span class="string">"/item/"</span>)) &#123;</span><br><span class="line">            String absURL = <span class="string">"https://baike.baidu.com"</span> + relURL;</span><br><span class="line">            queue.offer(absURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要确定链接是否为“内部”链接，我们检查 URL 是否以<code>/item/</code>开头。这可能包括我们不想索引的一些页面，如有关百度百科的元页面。它可能会排除我们想要的一些页面，例如非英语语言页面的链接。但是，这个简单的测试足以起步了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十五）持久化</title>
      <link href="/blog/2019/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/blog/2019/05/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="第十五章-持久化"><a href="#第十五章-持久化" class="headerlink" title="第十五章 持久化"></a>第十五章 持久化</h3><p>现在我们回顾一下搜索引擎的构建:</p><ul><li>抓取：我们需要一个程序，可以下载一个网页，解析它，并提取文本和任何其他页面的链接。</li><li>索引：我们需要一个索引，可以查找检索项并找到包含它的页面。</li><li>检索：我们需要一种方法，从索引中收集结果，并识别与检索项最相关的页面。</li></ul><p>抓取和索引我们之前都处理过，但是还不够好，我们现在先处理索引，存在Redis里持久化并排序，最后再处理检索功能。</p><br><h6 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1.Redis"></a>1.Redis</h6><p>索引器的之前版本，将索引存储在两个数据结构中：<code>TermCounter</code>将检索词映射为网页上显示的次数，以及<code>Index</code>将检索词映射为出现的页面集合。</p><p>这些数据结构存储在正在运行的 Java 程序的内存中，这意味着当程序停止运行时，索引会丢失。仅在运行程序的内存中存储的数据称为“易失的”，因为程序结束时会消失。</p><p>但这个解决方案有几个问题：</p><ul><li>读取和写入大型数据结构（如 Web 索引）会很慢。</li><li>整个数据结构可能不适合单个运行程序的内存。</li><li>如果程序意外结束（例如，由于断电），则自程序上次启动以来所做的任何更改都将丢失。</li></ul><p>现在我们用Redis解决这个问题。</p><br><h6 id="2-制作基于Redis的索引"><a href="#2-制作基于Redis的索引" class="headerlink" title="2.制作基于Redis的索引"></a>2.制作基于Redis的索引</h6><p>此时，梳理一下思路：</p><ul><li><code>JedisMaker.java</code>包含连接到 Redis 服务器并运行几个 Jedis 方法的示例代码。</li><li><code>JedisIndex.java</code>包含此练习的起始代码。</li><li><code>JedisIndexTest.java</code>包含<code>JedisIndex</code>的测试代码。</li><li><code>WikiFetcher.java</code>包含我们在以前的练习中看到的代码，用于阅读网页并使用<code>jsoup</code>进行解析。</li></ul><p>你还将需要这些文件，你在以前的练习中碰到过：</p><p><code>Index.java</code>使用 Java 数据结构实现索引。 <code>TermCounter.java</code>表示从检索项到其频率的映射。<code>WikiNodeIterable.java</code>迭代<code>jsoup</code>生成的 DOM 树中的节点。</p><p>现在，我们需要做的事是连接Redis服务器:</p><p>这里用的方法是，本地安装redis,java客户端推荐用Jedis</p><p>下面是具体创建连接及测试的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 创建Redis连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:52 2019/5/10</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">return</span> jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Jedis jedis = make();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String</span></span><br><span class="line">        jedis.set(<span class="string">"mykey"</span>, <span class="string">"myvalue"</span>);</span><br><span class="line">        String value = jedis.get(<span class="string">"mykey"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Got value: "</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set</span></span><br><span class="line">        jedis.sadd(<span class="string">"myset"</span>, <span class="string">"element1"</span>, <span class="string">"element2"</span>, <span class="string">"element3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"element2 is member: "</span> + jedis.sismember(<span class="string">"myset"</span>, <span class="string">"element2"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List</span></span><br><span class="line">        jedis.rpush(<span class="string">"mylist"</span>, <span class="string">"element1"</span>, <span class="string">"element2"</span>, <span class="string">"element3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"element at index 1: "</span> + jedis.lindex(<span class="string">"mylist"</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash</span></span><br><span class="line">        jedis.hset(<span class="string">"myhash"</span>, <span class="string">"word1"</span>, Integer.toString(<span class="number">2</span>));</span><br><span class="line">        jedis.hincrBy(<span class="string">"myhash"</span>, <span class="string">"word2"</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"frequency of word1: "</span> + jedis.hget(<span class="string">"myhash"</span>, <span class="string">"word1"</span>));</span><br><span class="line">        System.out.println(<span class="string">"frequency of word2: "</span> + jedis.hget(<span class="string">"myhash"</span>, <span class="string">"word2"</span>));</span><br><span class="line"></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久化 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS分布式文件系统搭建（三）SpringBoot集成FastDFS</title>
      <link href="/blog/2019/05/08/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89SpringBoot%E9%9B%86%E6%88%90FastDFS/"/>
      <url>/blog/2019/05/08/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89SpringBoot%E9%9B%86%E6%88%90FastDFS/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h5 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1 添加依赖"></a>3.3.1 添加依赖</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.bestwu&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.27&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br><h5 id="3-3-2-工具类编写"><a href="#3-3-2-工具类编写" class="headerlink" title="3.3.2 工具类编写"></a>3.3.2 工具类编写</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juanji.download.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.csource.common.MyException;</span><br><span class="line"><span class="keyword">import</span> org.csource.common.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.csource.fastdfs.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastDFSClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  TrackerClient trackerClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  TrackerServer trackerServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  StorageServer storageServer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  StorageClient1 storageClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  初始化FastDFS</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:35 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastDFSClient</span><span class="params">(String conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conf.contains(<span class="string">"classpath:"</span>)) &#123;</span><br><span class="line">            String path = URLDecoder.decode(getClass().getProtectionDomain().getCodeSource().getLocation().toString(),<span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(path);</span><br><span class="line">            path=path.substring(<span class="number">6</span>);</span><br><span class="line">            conf = conf.replace(<span class="string">"classpath:"</span>,URLDecoder.decode(path,<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ClientGlobal.init(conf);</span><br><span class="line">        trackerClient = <span class="keyword">new</span> TrackerClient();</span><br><span class="line">        trackerServer = trackerClient.getConnection();</span><br><span class="line">        storageServer = <span class="keyword">null</span>;</span><br><span class="line">        storageClient = <span class="keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 上传文件方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:35 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extName 文件扩展名，不包含（.）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metas 文件扩展信息</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(String fileName, String extName, NameValuePair[] metas)</span> </span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.upload_file1(fileName, extName, metas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 上传文件,传fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:37 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">uploadFile</span><span class="params">(String fileName, String extName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileName, extName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent, String extName, NameValuePair[] metas)</span> </span>&#123;</span><br><span class="line">        String result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.upload_file1(fileContent, extName, metas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileContent, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadFile</span><span class="params">(<span class="keyword">byte</span>[] fileContent, String extName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFile(fileContent, extName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 文件下载到磁盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:37 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output 输出流 中包含要输出到磁盘的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1失败,0成功</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">download_file</span><span class="params">(String path,BufferedOutputStream output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = storageClient.download_file1(path);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(b != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    output.write(b);</span><br><span class="line">                    result=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125; <span class="comment">//用户可能取消了下载</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (output != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        output.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> 2019.05.08</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 文件的路径 如group1/M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] download_bytes(String path) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b = storageClient.download_file1(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:39 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group 组名 如：group1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> storagePath 不带组名的路径名称 如：M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1失败,0成功</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">delete_file</span><span class="params">(String group ,String storagePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.delete_file(group, storagePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 删除文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:40 2019/5/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">delete_file</span><span class="params">(String storagePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = storageClient.delete_file1(storagePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取远程服务器文件资源信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:40 2019/5/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName   文件组名 如：group1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteFileName M00/00/00/wKgRsVjtwpSAXGwkAAAweEAzRjw471.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileInfo <span class="title">getFile</span><span class="params">(String groupName,String remoteFileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storageClient.get_file_info(groupName, remoteFileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="3-3-3-单元测试"><a href="#3-3-3-单元测试" class="headerlink" title="3.3.3 单元测试"></a>3.3.3 单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juanji.app.liveserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.juanji.app.util.FastDFSClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FastDFSTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fdfsUpload</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String confUrl=<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"fdfs_client.properties"</span>).getPath();</span><br><span class="line">        FastDFSClient fastDFSClient = <span class="keyword">new</span> FastDFSClient(confUrl);</span><br><span class="line">        String filePath = fastDFSClient.uploadFile(<span class="string">"C:\\upload\\xx\\20190306\\183118.png"</span>);</span><br><span class="line">        System.out.println(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String confUrl=<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">"fdfs_client.properties"</span>).getPath();</span><br><span class="line">        FastDFSClient fastDFSClient = <span class="keyword">new</span> FastDFSClient(confUrl);</span><br><span class="line">        <span class="keyword">int</span> i = fastDFSClient.delete_file(<span class="string">"group1/M00/00/00/CmVkLVzSTt-AVds1AAWuezrCZFM986.png"</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h5 id="3-3-4-上传测试效果展示"><a href="#3-3-4-上传测试效果展示" class="headerlink" title="3.3.4 上传测试效果展示"></a>3.3.4 上传测试效果展示</h5><p><img src="https://img-blog.csdnimg.cn/20190508121002605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
            <tag> 分布式文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS分布式文件系统搭建（二）FastDFS+Nginx实现分布式文件系统</title>
      <link href="/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89FastDFS+Nginx%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89FastDFS+Nginx%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h5 id="1-FastDFS安装环境"><a href="#1-FastDFS安装环境" class="headerlink" title="1 FastDFS安装环境"></a>1 <code>FastDFS</code>安装环境</h5><p><code>FastDFS</code>是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。</p><p>首先安装<code>gcc</code>编译环境</p><blockquote><p>yum install gcc-c++</p></blockquote><br><h5 id="2-安装libevent"><a href="#2-安装libevent" class="headerlink" title="2 安装libevent"></a>2 安装<code>libevent</code></h5><p>FastDFS依赖<code>libevent</code>库，需要安装：</p><blockquote><p>yum -y install libevent</p></blockquote><br><h5 id="3-安装libfastcommon"><a href="#3-安装libfastcommon" class="headerlink" title="3 安装libfastcommon"></a>3 安装<code>libfastcommon</code></h5><p>这里强调一下，此包 包含了FastDFS运行所需要的一些基础库，可从Github下载<a href="https://github.com/happyfish100/libfastcommon" target="_blank" rel="noopener">master</a>这个版本，和后边的<code>FastDFS</code>版本有关系.</p><p>将该文件拷贝到/usr/local/下</p><blockquote><p>cd /usr/local</p><p>unzip libfastcommon-master.zip</p><p>cd libfastcommon-master</p><p>./make.sh</p><p>./make.sh install</p></blockquote><p><code>libfastcommon</code>默认安装到了</p><ul><li>/usr/lib64/libfastcommon.so</li><li>/usr/lib64/libfdfsclient.so</li></ul><p>因为FastDFS主程序设置的lib目录是/usr/local/lib，所以需要<strong>创建软链接</strong>.</p><blockquote><p>ln -s /usr/lib64/libfastcommon.so  /usr/local/lib/libfastcommon.so</p><p>ln -s /usr/lib64/libfastcommon.so  /usr/lib/libfastcommon.so</p><p>ln -s /usr/lib64/libfdfsclient.so  /usr/local/lib/libfdfsclient.so</p><p>ln -s /usr/lib64/libfdfsclient.so  /usr/lib/libfdfsclient.so</p></blockquote><p>这里需要注意一下，创建软连接时<strong>不可直接复制文件</strong>到别的地方，会导致文件无可用权限而影响后边的安装.</p><br><h6 id="2-2-3-安装FastDFS"><a href="#2-2-3-安装FastDFS" class="headerlink" title="2.2.3 安装FastDFS"></a>2.2.3 安装<code>FastDFS</code></h6><p>首先下载文件，这里需要和之前的版本保持对应，<code>libfastcommon-master(200k)</code>对应这里的<a href="https://sourceforge.net/projects/fastdfs/" target="_blank" rel="noopener">5.08</a>版本.</p><blockquote><p>tar -zxvf FastDFS_v5.08.tar.gz</p><p>cd FastDFS</p><p>./make.sh</p><p>./make.sh install</p></blockquote><p>安装成功后进入到FastDFS文件，将<code>conf</code>中的的所有文件拷贝到/etc/fdfs/下.</p><p>进入/etc/fdfs/目录下，修改配置文件:</p><blockquote><p>cp tracker.conf      # 拷贝</p><p>vi tracker.conf       # 修改</p><p>将 base_path=/home/yuqing/FastDFS </p><p>改为</p><p>base_path=/home/FastDFS</p></blockquote><p>这时，可以尝试启动项目了：</p><blockquote><p>/usr/bin/fdfs_trackerd/etc/fdfs/tracker.conf restart</p></blockquote><p>设置开机自动启动</p><blockquote><p>vim /etc/rc.d/rc.local</p><p>/usr/bin/fdfs_trackerd/etc/fdfs/tracker.conf restart</p></blockquote><br><h6 id="2-2-4-Storage安装"><a href="#2-2-4-Storage安装" class="headerlink" title="2.2.4 Storage安装"></a>2.2.4 <code>Storage</code>安装</h6><p>如果时在不同的服务器安装，重复以上的步骤即可</p><p>之后是配置<code>Storage</code>服务</p><p>修改<code>/etc/fdfs/storage.conf</code>文件</p><p><img src="https://img-blog.csdn.net/20180626140318180?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180626140300245?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180626140244516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>启动<code>Storage</code>服务</p><blockquote><p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</code> </p><p>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart    # 重启命令</p></blockquote><br><h6 id="2-2-5-检测Storage服务是否正常"><a href="#2-2-5-检测Storage服务是否正常" class="headerlink" title="2.2.5 检测Storage服务是否正常"></a>2.2.5 检测<code>Storage</code>服务是否正常</h6><p>1.修改配置文件<code>/etc/fdfs/client.conf</code></p><p><img src="https://img-blog.csdn.net/20180626140230202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>2.测试</p><p><img src="https://img-blog.csdn.net/20180626140209646?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><blockquote><p>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg</p></blockquote><p>3.测试结果</p><p><img src="https://img-blog.csdn.net/20180626140627785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>至此，FastDFS配置成功.</p><br><h6 id="2-2-5-Nginx安装"><a href="#2-2-5-Nginx安装" class="headerlink" title="2.2.5 Nginx安装"></a>2.2.5 Nginx安装</h6><p>现在安装好了FastDFS，可以实现上传图片功能，但是它并没有提供HTTP服务，所以无法通过HTTP来访问文件，这时就需要整合Nginx，让Nginx来实现这个功能。</p><p>这里我们先安装<code>fastdfs-nginx-module</code>，<a href="https://github.com/happyfish100/fastdfs-nginx-module" target="_blank" rel="noopener">下载地址</a></p><ul><li>解压</li></ul><blockquote><p>unzip  fastdfs-nginx-module.zip</p></blockquote><ul><li>修改压缩包下<code>/usr/local/fastdfs-nginx-module/src/config</code>文件，把其中的<code>local</code>去掉 </li></ul><p><img src="https://img-blog.csdn.net/20180626163055392?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><ul><li>对nginx重新配置(这里主要是将以上的<code>fastdfs-nginx-module</code>编译)</li></ul><blockquote><p>./configure –add-module=/usr/local/fastdfs-nginx-module/src</p><p>chmod +x *</p><p>make</p><p>make install</p></blockquote><p>如果你没有Nignx的话，先安一个:</p><blockquote><p>cd /usr/local/src<br>wget   <a href="http://nginx.org/download/nginx-1.10.3.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.10.3.tar.gz</a><br>tar -zxvf nginx-1.10.3.tar.gz<br>cd nginx-1.10.3<br>./configure –add-module=/usr/local/fastdfs-nginx-module/src<br>make<br>make install</p></blockquote><p>把<code>/usr/local/fastdfs-nginx-module/src/mod_fastdfs.conf</code>文件复制到<code>/etc/fdfs</code>目录下。编辑：</p><blockquote><p>vi mod_fastdfs.conf       # 修改</p><p>url_have_group_name = true     #否则浏览器无法查看图片</p></blockquote><p><img src="https://img-blog.csdn.net/20180626163653336?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180626163659848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180626163708533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><br><h6 id="2-2-6-配置Nginx"><a href="#2-2-6-配置Nginx" class="headerlink" title="2.2.6 配置Nginx"></a>2.2.6 配置Nginx</h6><h6 id="在-nginx的配置文件nginx-conf中添加一个Server"><a href="#在-nginx的配置文件nginx-conf中添加一个Server" class="headerlink" title="在 nginx的配置文件nginx.conf中添加一个Server"></a>在 nginx的配置文件<code>nginx.conf</code>中添加一个Server</h6><blockquote><p>vim /usr/local/nginx/conf/nginx.conf</p></blockquote><p>添加的server</p><blockquote><p>server {<br>       listen       8888;  # 监听的端口<br>       server_name  10.101.100.45;  #配置的Stroge服务器地址</p><p>​        location /group1/M00{<br>​                     root /usr/coallocal/test;   #配置的文件上传地址(同之前的配置保持一致)<br>​                     ngx_fastdfs_module;        #插件名称<br>  ​                 }<br>​    }</p></blockquote><br><h6 id="2-2-7-启动Nignx"><a href="#2-2-7-启动Nignx" class="headerlink" title="2.2.7 启动Nignx"></a>2.2.7 启动Nignx</h6><blockquote><p>cd nginx</p><p>sbin/nginx</p></blockquote><p><img src="https://img-blog.csdn.net/20180626164336870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>测试图片上传:</p><blockquote><p>cd /etc/fdfs<br>/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg</p></blockquote><p><img src="https://img-blog.csdn.net/20180626165150607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>浏览器中访问网址</p><p><img src="https://img-blog.csdn.net/20180626165251260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvZGVfc2hhZG93/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
            <tag> 分布式文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS分布式文件系统搭建（一）基础原理</title>
      <link href="/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2019/05/07/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-1-什么是FastDFS"><a href="#1-1-什么是FastDFS" class="headerlink" title="1.1   什么是FastDFS"></a>1.1   什么是FastDFS</h3><p>​        FastDFS是用c语言编写的一款开源的<strong>分布式文件系统</strong>。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易<strong>搭建一套高性能的文件服务器集群提供文件上传、下载等服务</strong>。</p><br><h3 id="1-2-FastDFS架构"><a href="#1-2-FastDFS架构" class="headerlink" title="1.2  FastDFS架构"></a>1.2  FastDFS架构</h3><p>  <code>FastDFS</code>架构包括 <code>Tracker server</code>和<code>Storage server</code>。客户端请求<code>Tracker server</code>进行文件上传、下载，通过<code>Trackerserver</code>调度最终由Storage server完成文件上传和下载。</p><p>​        <code>Trackerserver</code>作用是<strong>负载均衡和调度</strong>，通过<code>Trackerserver</code>在文件上传时可以根据一些策略找到<code>Storageserver</code>提供文件上传服务。可以将tracker称为<strong>追踪服务器或调度服务器</strong>。</p><p>​        <code>Storageserver</code>作用是<strong>文件存储</strong>，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong>。</p><p><img src="https://img-blog.csdn.net/20180516113227670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><br><h5 id="1-2-1-Tracker-集群"><a href="#1-2-1-Tracker-集群" class="headerlink" title="1.2.1  Tracker 集群"></a>1.2.1  Tracker 集群</h5><p><code>FastDFS</code>集群中的<code>Tracker server</code>可以有多台，<code>Trackerserver</code>之间是<strong>相互平等关系同时提供服务</strong>，<code>Trackerserver</code>不存在单点故障。客户端请求<code>Trackerserver</code>采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。<br><br></p><h5 id="1-2-2-Storage集群"><a href="#1-2-2-Storage集群" class="headerlink" title="1.2.2  Storage集群"></a>1.2.2  Storage集群</h5><p>​        <code>Storage</code>集群采用了<strong>分组存储方式</strong>。<code>storage</code>集群<strong>由一个或多个组构成，集群存储总容量为集群中所有组的存储容量之和</strong>。一个组由一台或多台存储服务器组成，组内的<code>Storage server</code>之间是平等关系，不同组的<code>Storageserver</code>之间不会相互通信，同组内的<code>Storageserver</code>之间会相互连接进行文件同步，从而保证同组内每个<code>storage</code>上的文件完全一致的。一个组的存储容量为该组内存储服务器容量最小的那个，由此可见组内存储服务器的软硬件配置最好是一致的。</p><p>​        采用分组存储方式的好处是<strong>灵活、可控性较强</strong>。比如上传文件时，可以由客户端直接指定上传到的组也可以由tracker进行调度选择。一个分组的存储服务器访问压力较大时，可以在该组增加存储服务器来扩充服务能力（纵向扩容）。当系统容量不足时，可以增加组来扩充存储容量（横向扩容）。<br><br></p><h5 id="1-2-3-Storage状态收集"><a href="#1-2-3-Storage状态收集" class="headerlink" title="1.2.3  Storage状态收集"></a>1.2.3  Storage状态收集</h5><p><code>Storage server</code>会连接集群中所有的<code>Tracker server</code>，<strong>定时向他们报告自己的状态</strong>，包括磁盘剩余空间、文件同步状况、文件上传下载次数等统计信息。<br><br></p><h5 id="1-2-4-文件上传流程"><a href="#1-2-4-文件上传流程" class="headerlink" title="1.2.4  文件上传流程"></a>1.2.4  文件上传流程</h5><p><img src="https://img-blog.csdn.net/20180516113258902?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。</p><p><img src="https://img-blog.csdn.net/20180516113315796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。</p><p>虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。</p><p>数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。</p><p>文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。<br><br></p><h5 id="1-2-5-文件下载流程"><a href="#1-2-5-文件下载流程" class="headerlink" title="1.2.5  文件下载流程"></a>1.2.5  文件下载流程</h5><p><img src="https://img-blog.csdn.net/20180516113332205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0thbVJvc2VMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastDFS </tag>
            
            <tag> 分布式文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十四）二叉搜索树</title>
      <link href="/blog/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/blog/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>本章继续承接上章的内容，具体实现<code>TreeMap</code>中的方<br><br></p><h6 id="1-简单的TreeMap"><a href="#1-简单的TreeMap" class="headerlink" title="1.简单的TreeMap"></a>1.简单的<code>TreeMap</code></h6><p>这里比较核心的一个方法是<code>findNode</code>，用来寻找与键值相当的节点，下面是它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">findNode</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Comparable&lt;?<span class="keyword">super</span> K&gt; k = (Comparable&lt;?<span class="keyword">super</span> K&gt;)target;</span><br><span class="line"></span><br><span class="line">      Node node = root;</span><br><span class="line">      <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> cmp = k.compareTo(node.key);</span><br><span class="line">          <span class="keyword">if</span> (cmp &lt;<span class="number">0</span>)</span><br><span class="line">              node = node.left;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)</span><br><span class="line">              node = node.right;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>在这个实现中，<code>null</code>不是键的合法值。</li><li>在我们可以在<code>target</code>上调用<code>compareTo</code>之前，我们必须把它强制转换为某种形式的<code>Comparable</code>。这里使用的“<strong>类型通配符</strong>”会尽可能允许；也就是说，它适用于任何实现<code>Comparable</code>类型，并且它的<code>compareTo</code>接受<code>K</code>或者任和<code>K</code>的超类（<strong>可以同任何类型做比较</strong>）。</li></ul><p>之后，实际搜索比较简单。我们初始化一个循环变量<code>node</code>来引用根节点。每次循环中，我们将目标与<code>node.key</code>比较。<strong>如果目标小于当前键，我们移动到左子树。如果它更大，我们移动到右子树。如果相等，我们返回当前节点(这里用的是迭代，不断赋值)。</strong></p><br><h6 id="2-搜索值"><a href="#2-搜索值" class="headerlink" title="2.搜索值"></a>2.搜索值</h6><p><strong><code>findNode</code>运行时间与树的高度成正比</strong>，而不是节点的数量，因为我们不必搜索整个树。<strong>但是对于<code>containsValue</code>，我们必须搜索值，而不是键</strong>；BST 的特性不适用于值，因此我们必须搜索整个树。</p><p>下面是<code>containsValue</code>方法，这里用<strong>递归</strong>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> containsValueHelper(root, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsValueHelper</span><span class="params">(Node node, Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (equals(target, node.value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containsValueHelper(node.left, target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containsValueHelper(node.right, target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>containsValueHelper</code>的工作原理：</p><ul><li>第一个<code>if</code>语句检查递归的边界情况。如果<code>node</code>是<code>null</code>，那意味着我们已经递归到树的底部，没有找到<code>target</code>，所以我们应该返回<code>false</code>。请注意，<strong>这只意味着目标没有出现在树的一条路径上；它仍然可能会在另一条路径上被发现。</strong></li><li>第二种情况检查我们是否找到了我们正在寻找的东西。如果是这样，我们返回<code>true</code>。否则，我们必须继续。</li><li>第三种情况是执行递归调用，在左子树中搜索<code>target</code>。如果我们找到它，我们可以立即返回<code>true</code>，而不搜索右子树。否则我们继续。</li><li>第四种情况是搜索右子树。同样，如果我们找到我们正在寻找的东西，我们返回<code>true</code>。否则，我们搜索完了整棵树，返回<code>false</code>。</li></ul><p>该方法“访问”了树中的每个节点，<strong>所以它的所需时间与节点数成正比</strong>。</p><br><h6 id="3-实现put"><a href="#3-实现put" class="headerlink" title="3.实现put"></a>3.实现<code>put</code></h6><p><code>put</code>方法比起<code>get</code>要复杂一些，因为要处理两种情况：</p><ol><li><strong>如果给定的键已经在树中，则替换并返回旧值</strong>；</li><li><strong>否则必须在树中添加一个新的节点，在正确的地方</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> putHelper(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putHelper</span><span class="params">(Node node, K key, V value)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">int</span> cmp = k.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> putHelper(node.left, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> putHelper(node.right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = node.value;</span><br><span class="line">    node.value = value;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数<code>node</code>最初是树的根，但是每次我们执行递归调用，它指向了不同的子树。就像<code>get</code>一样，我们用<code>compareTo</code>方法来弄清楚，跟随哪一条树的路径。如果<code>cmp &lt; 0</code>，我们添加的键小于<code>node.key</code>，那么我们要走左子树。有两种情况：</p><ul><li>如果左子树为空，那就是，如果<code>node.left</code>是<code>null</code>，我们已经到达树的底部而没有找到<code>key</code>。这个时候，我们知道<code>key</code>不在树上，我们知道它应该放在哪里。所以我们创建一个新节点，并将它添加为<code>node</code>的左子树。</li><li>否则我们进行递归调用来搜索左子树。</li></ul><p>如果<code>cmp &gt; 0</code>，我们添加的键大于<code>node.key</code>，那么我们要走右子树。我们处理的两个案例与上一个分支相同。最后，如果<code>cmp == 0</code>，我们在树中找到了键，那么我们更改它并返回旧的值。</p><br><h6 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4.中序遍历"></a>4.中序遍历</h6><p>这里我们还剩最后一个方法<code>KeySet</code>，它返回一个<code>Set</code>，按升序包含树中的键。在其他<code>Map</code>实现中，<code>keySet</code>返回的键没有特定的顺序，但是树形实现的一个功能是，<strong>对键进行简单而有效的排序</strong>。下面是如何实现它的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;K&gt;();</span><br><span class="line">    addInOrder(root, set);</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addInOrder</span><span class="params">(Node node, Set&lt;K&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    addInOrder(node.left, set);</span><br><span class="line">    set.add(node.key);</span><br><span class="line">    addInOrder(node.right, set);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>keySet</code>中，我们创建一个<code>LinkedHashSet</code>，这是一个<code>Set</code>实现，使元素保持有序,第一个参数<code>node</code>最初是树的根，但正如你的期望，我们用它来递归地遍历树。<code>addInOrder</code>对树执行经典的“中序遍历”。</p><ol><li>按顺序遍历左子树。</li><li>添加<code>node.key</code>。</li><li>按顺序遍历右子树。</li></ol><br><h6 id="5-二叉搜索树的问题"><a href="#5-二叉搜索树的问题" class="headerlink" title="5.二叉搜索树的问题"></a>5.二叉搜索树的问题</h6><p>我们获取最有查询效率时，<strong>一般是O(log(n))</strong>，这种情况会在所搜索的树为平衡二叉树时出现，若不是平衡二叉树，搜索效率则会很低。</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/13-1.jpg" alt=""></p><p>如果你思考<code>put</code>如何工作，你可以弄清楚发生了什么。每次添加一个新的键时，它都大于树中的所有键，所以我们总是选择右子树，并且总是将新节点添加为，最右边的节点的右子节点。结果是一个“不平衡”的树，只包含右子节点。</p><p><strong>这种树的高度正比于<code>n</code>，不是<code>logn</code>，所以<code>get</code>和<code>put</code>的性能是线性的，不是对数的</strong></p><br><h6 id="6-自平衡树"><a href="#6-自平衡树" class="headerlink" title="6.自平衡树"></a>6.自平衡树</h6><p>这个问题有两种可能的解决方案：</p><ul><li><strong>你可以避免向<code>Map</code>按顺序添加键</strong>。但这并不总是可能的。 你可以制作一棵树，如果碰巧按顺序处理键，那么它会更好地处理键。(<strong>按顺序添加会导致这是一个极不平衡的树</strong>)</li><li>第二个解决方案是更好的，有几种方法可以做到。最常见的是修改<code>put</code>，以便它检测树何时开始变得不平衡，如果是，则重新排列节点。具有这种能力的树被称为“自平衡树”。普通的自平衡树包括 AVL 树（“AVL”是发明者的缩写），以及红黑树，这是 Java<code>TreeMap</code>所使用的。</li></ul><p>总而言之，二叉搜索树可以以对数时间实现<code>get</code>和<code>put</code>，但是只能按照使得树足够平衡的顺序添加键。<strong>自平衡树通过每次添加新键时，进行一些额外的工作来避免这个问题</strong>。<br><br></p><h6 id="7-二叉搜索树的删除"><a href="#7-二叉搜索树的删除" class="headerlink" title="7.二叉搜索树的删除"></a>7.二叉搜索树的删除</h6><p><strong>实现思路：</strong></p><blockquote><ol><li>删除叶子节点</li><li>删除只有左孩子的节点</li><li>删除只有右孩子的节点</li><li>删除左右孩子都有的节点，这里我们需要找出待删除节点的右子树中的最小节点，并放到待删除位置上</li></ol></blockquote><p>下面是实现的具体方案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一会儿我来填这个坑</span></span><br><span class="line">        Comparable&lt;?<span class="keyword">super</span> K&gt; key = (Comparable&lt;?<span class="keyword">super</span> K&gt;)k;</span><br><span class="line">        Node currentNode = <span class="keyword">this</span>.root; <span class="comment">//用来保存待删除节点</span></span><br><span class="line">        Node parentNode = <span class="keyword">this</span>.root;  <span class="comment">//保存待删除节点的父节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isLeftNode = <span class="keyword">true</span>;   <span class="comment">//左右节点判断</span></span><br><span class="line">        V oldValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找需要的节点(同时记录它的位置)</span></span><br><span class="line">        <span class="keyword">while</span> ( (currentNode != <span class="keyword">null</span>) &amp;&amp; (currentNode.key != key) ) &#123;</span><br><span class="line">            parentNode = currentNode;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(currentNode.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                currentNode = currentNode.left;</span><br><span class="line">                isLeftNode = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currentNode = currentNode.right;</span><br><span class="line">                isLeftNode = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空树</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除的节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (currentNode.left == <span class="keyword">null</span>) &amp;&amp; (currentNode.right == <span class="keyword">null</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = parentNode.left.value;</span><br><span class="line">                parentNode.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = parentNode.right.value;</span><br><span class="line">                parentNode.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (currentNode.right == <span class="keyword">null</span>) &amp;&amp; (currentNode.left != <span class="keyword">null</span>) ) &#123;   <span class="comment">//删除节点只有左孩子(分情况看它挂到哪)</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == <span class="keyword">this</span>.root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = currentNode.left.value;</span><br><span class="line">                parentNode.left = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = currentNode.right.value;</span><br><span class="line">                parentNode.right = currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (currentNode.right != <span class="keyword">null</span>) &amp;&amp; (currentNode.left == <span class="keyword">null</span>) ) &#123;   <span class="comment">//删除节点只有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode == root) &#123;</span><br><span class="line">                oldValue = root.value;</span><br><span class="line">                root = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftNode) &#123;</span><br><span class="line">                oldValue = parentNode.left.value;</span><br><span class="line">                parentNode.left = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                oldValue = parentNode.right.value;</span><br><span class="line">                parentNode.right = currentNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//待删除节点既有左子树，又有右子树(思路:将待删除节点右子树的最小节点赋值给待删除节点)</span></span><br><span class="line">            Node directPostNode = getDirectPostNode(currentNode);</span><br><span class="line">            oldValue = directPostNode.value;</span><br><span class="line">            currentNode.key = directPostNode.key;</span><br><span class="line">            currentNode.value = directPostNode.value;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>得到待删除节点的直接后继节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getDirectPostNode</span><span class="params">(Node delNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Node parentNode = delNode;  <span class="comment">//用来保存待删除节点的（直接后继节点的父亲节点）</span></span><br><span class="line">     Node directNode = delNode;  <span class="comment">//用来保存待删除节点的（直接后继节点）</span></span><br><span class="line">     Node currentNode = delNode.right;   <span class="comment">// 待删除节点右子树</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">         parentNode = directNode;</span><br><span class="line">         directNode = currentNode;</span><br><span class="line">         currentNode = currentNode.left;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 直接删除此后继节点(因为不是直接相连的,最小的肯定是叶子节点或者没有左子树)</span></span><br><span class="line">     <span class="keyword">if</span> (directNode != delNode.right) &#123;</span><br><span class="line">         parentNode.left = directNode.right;</span><br><span class="line">         directNode.right = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> directNode;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>具体的可以看图：</strong></p><p><img src="http://images2015.cnblogs.com/blog/938494/201702/938494-20170209210350729-446211360.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十三）TreeMap</title>
      <link href="/blog/2019/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89TreeMap/"/>
      <url>/blog/2019/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89TreeMap/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>这一章展示了<strong>二叉搜索树</strong>，它是个<code>Map</code>接口的高效实现。如果我们想让元素<strong>有序</strong>，它非常实用。</p></blockquote><br><h6 id="1-哈希的不足"><a href="#1-哈希的不足" class="headerlink" title="1.哈希的不足"></a>1.哈希的不足</h6><p><code>HashMap</code>被广泛使用，但并不是唯一的<code>Map</code>实现。有几个原因可能需要另一个实现：</p><ul><li><strong>哈希可能很慢</strong>，所以即使<code>HashMap</code>操作是常数时间，“常数”可能很大。 如果哈希函数将键均匀分配给子映射，效果很好。但设计良好的散列函数并不容易，如果太多的键在相同的子映射上，那么<code>HashMap</code>的性能可能会很差。</li><li><strong>哈希表中的键不以任何特定顺序存储</strong>；实际上，当表增长并且键被重新排列时，顺序可能会改变。对于某些应用程序，必须或至少保持键的顺序，这很有用。</li></ul><p>很难同时解决所有这些问题，但是 Java 提供了一个称为<code>TreeMap</code>的实现：</p><ul><li><strong>它不使用哈希函数</strong>，所以它避免了哈希的开销和选择哈希函数的困难。</li><li>在<code>TreeMap</code>之中，<strong>键被存储在二叉搜索树中</strong>，这使我们可以以线性时间顺序遍历键。</li><li>核心方法的<strong>运行时间与<code>log(n)</code>成正比</strong>，并不像常数时间那样好，但仍然非常好。</li></ul><p>下一节中，我将解释二进制搜索树如何工作，然后你将使用它来实现<code>Map</code>。</p><br><h6 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2.二叉搜索树"></a>2.二叉搜索树</h6><p>二叉搜索树（BST）是一个树，其中每个<code>node</code>（节点）包含一个键，并且每个都具有“BST 属性”：</p><ul><li>如果<code>node</code>有一个左子树，左子树中的所有键都必须小于<code>node</code>的键。</li><li>如果<code>node</code>有一个右子树，右子树中的所有键都必须大于<code>node</code>的键。</li></ul><p>二叉搜索树示例：</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/12-1.jpg" alt=""></p><p>在二叉搜索树中查找一个键是很快的，因为我们不必搜索整个树。从根节点开始，我们可以使用以下算法：</p><ul><li>将你要查找的键<code>target</code>，与当前节点的键进行比较。如果他们相等，你就完成了。</li><li>如果<code>target</code>小于当前键，搜索左子树。如果没有，<code>target</code>不在树上。</li><li>如果<code>target</code>大于当前键，搜索右子树。如果没有，<code>target</code>不在树上。</li></ul><p>在树的每一层，你只需要搜索一个子树。例如，如果你在上图中查找<code>target = 4</code>，则从根节点开始，它包含键<code>8</code>。因为<code>target</code>小于<code>8</code>，你走了左边。因为<code>target</code>大于<code>3</code>，你走了右边。因为<code>target</code>小于<code>6</code>，你走了左边。然后你找到你要找的键</p><p>现在你可能会看到这个规律。如果我们将树的层数从<code>1</code>数到<code>n</code>，第<code>i</code>层可以拥有多达<code>2^(n-1)</code>个节点。<code>h</code>层的树共有<code>2^h-1</code>个节点。如果我们有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span>^h - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们可以对两边取以<code>2</code>为底的对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log2(n) ≈ h</span><br></pre></td></tr></table></figure><p>意思是树的高度正比于<code>logn</code>，<strong>如果它是满的(每一层包含最大数量的节点)</strong>，满二叉树。</p><br><h6 id="3-TreeMap结构"><a href="#3-TreeMap结构" class="headerlink" title="3.TreeMap结构"></a>3.TreeMap结构</h6><p>这里将要使用<strong>二叉搜索树</strong>编写<code>Map</code>接口的一个实现，这是开头结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTreeMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><code>size</code>追踪键的数量，<code>root</code>为根节点，下面是<code>Node</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Node right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，我们可以实现一些相对简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">       root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TreeMap </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十二）HashMap</title>
      <link href="/blog/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89HashMap/"/>
      <url>/blog/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89HashMap/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>上一章中，我们写了一个使用哈希的<code>Map</code>接口的实现。我们期望这个版本更快，<strong>因为它搜索的列表较短，但增长顺序仍然是线性的（k太小，而且是固定的）</strong>。</p></blockquote><p>如果存在<code>n</code>个条目和<code>k</code>个子映射，则子映射的大小平均为<code>n/k</code>，这仍然与<code>n</code>成正比。但是，如果我们<strong>与<code>n</code>一起增加<code>k</code>，我们可以限制<code>n/k</code>的大小</strong>。<br>例如，<strong>假设每次<code>n</code>超过<code>k</code>的时候，我们都使<code>k</code>加倍；在这种情况下，每个映射的条目的平均数量将小于<code>1</code>，</strong>并且几乎总是小于<code>10</code>，只要<strong>散列函数能够很好地展开键</strong>。<br>如果<strong>每个子映射的条目数是不变的，我们可以在常数时间内搜索一个子映射</strong>。并且计算散列函数通常是常数时间（它可能取决于键的大小，但不取决于键的数量）。这使得<code>Map</code>的核心方法， <code>put</code>和<code>get</code>时间不变。</p><br><h6 id="1-MyHashMap"><a href="#1-MyHashMap" class="headerlink" title="1.MyHashMap"></a>1.MyHashMap</h6><p>在<code>MyHashMap.java</code>中，我提供了哈希表的大纲，它会按需增长。这里是定义的起始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">MyBetterMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常数FACTOR（称为负载因子）确定每个子映射的平均最大条目数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> FACTOR = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">super</span>.put(key,value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size()&gt; maps.size() * FACTOR) &#123;</span><br><span class="line">            rehash();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>MyHashMap</code>扩展了<code>MyBetterMap</code>，所以它继承了那里定义的方法。<strong>它覆盖的唯一方法是<code>put</code>，</strong>它调用了超类中的<code>put</code> – 也就是说，它调用了<code>MyBetterMap</code>中的<code>put</code>版本 – <strong>然后它检查它是否必须<code>rehash</code>。</strong>调用<code>size</code>返回总数量<code>n</code>。调用<code>maps.size</code>返回内嵌映射的数量<code>k</code>。</p><p><strong>常数<code>FACTOR</code>（称为负载因子）确定每个子映射的平均最大条目数。如果<code>n &gt; k * FACTOR</code>，这意味着<code>n/k &gt; FACTOR</code>，意味着每个子映射的条目数超过阈值，所以我们调用<code>rehash</code>。</strong></p><p>下面是给出的<code>rehash</code>方法（<strong>收集表中的条目，调整表的大小，然后重新放入条目</strong>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    List&lt;MyLinearMap&lt;K,V&gt;&gt; oldMaps = maps;</span><br><span class="line">    makeMaps(maps.size()*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将旧的map放进去</span></span><br><span class="line">    <span class="keyword">for</span> (MyLinearMap&lt;K,V&gt; map: oldMaps) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.getEntries()) &#123;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h6 id="2-分析HashMap"><a href="#2-分析HashMap" class="headerlink" title="2.分析HashMap"></a>2.分析HashMap</h6><p>如果<strong>最大子映射中的条目数</strong>(FACTOR)<strong>与<code>n/k</code>成正比</strong>，并且<code>k</code>与<code>n</code>成正比，那么多个核心方法就是常数时间的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> containsKey（Object target）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（target）; </span><br><span class="line">    <span class="keyword">return</span> map.containsKey（target）; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V get（Object key）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（key）; <span class="keyword">return</span> map.get（key）; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> V remove（Object key）&#123; </span><br><span class="line">    MyLinearMap &lt;K，V&gt; map = chooseMap（key）; </span><br><span class="line">    <span class="keyword">return</span> map.remove（key）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法都计算键的哈希，这是常数时间，然后在一个子映射上调用一个方法，这个方法是常数时间的。<strong>（这些发方法总体上都是常数的）</strong></p><p>但另一个核心方法，<code>put</code>有点难分析。当我们<strong>不需要<code>rehash</code>时，它是常数时间</strong>，反之，它是线性的。这样同之前的<strong>摊销分析</strong>类似。</p><p>假设子映射的初始数量<code>k</code>为<code>2</code>，负载因子为<code>1</code>。<strong>现在我们来看看<code>put</code>一系列的键需要多少工作量</strong>。作为基本的“工作单位”，我们<strong>将计算对密钥哈希，并将其添加到子映射中的次数</strong>。</p><p>我们第一次调用<code>put</code>时，它需要<code>1</code>个工作单位。第二次也需要<code>1</code>个单位。第三次我们需要<code>rehash</code>，所以需要<code>2</code>个单位重新填充现有的键，和<code>1</code>个单位来对新键哈希。</p><p>现在哈希表的大小是<code>4</code>，所以下次调用<code>put</code>时 ，需要<code>1</code>个工作单位。但是下一次我们必须<code>rehash</code>，需要<code>4</code>个单位来<code>rehash</code>现有的键，和<code>1</code>个单位来对新键哈希。</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/11-1.jpg" alt=""></p><p>如图所示，<strong>对新键哈希的正常工作量在底部展示（计算哈希），额外工作量展示为塔楼</strong>(扩容部分)。</p><p>如箭头所示，如果我们把塔楼推倒，每个积木都会在下一个塔楼之前填满空间。结果似乎<code>2</code>个单位的均匀高度，这表明<code>put</code>的平均工作量约为<code>2</code>个单位。<strong>这意味着<code>put</code>平均是常数时间</strong>。</p><p>这个图还显示了，当我们<code>rehash</code>的时候，为什么加倍子映射数量<code>k</code>很重要。<strong>如果我们只是加上<code>k</code>而不是加倍，那么这些塔楼会靠的太近，他们会开始堆积。这样就不会是常数时间了</strong>。</p><br><h6 id="3-权衡"><a href="#3-权衡" class="headerlink" title="3.权衡"></a>3.权衡</h6><p>我们已经表明，<code>containsKey</code>，<code>get</code>和<code>remove</code>是常数时间，<code>put</code>平均为常数时间。我们应该花一点时间来欣赏它有多么出色。<strong>无论哈希表有多大，这些操作的性能几乎相同</strong>。</p><p>记住，我们的分析基于一个简单的计算模型，其中每个“工作单位”花费相同的时间量。真正的电脑比这更复杂。特别是，当处理足够小，适应高速缓存的数据结构时，它们通常最快；如果结构不适合高速缓存但仍适合内存，则稍慢一点；如果结构不适合在内存中，则非常慢。</p><p>这个实现的<strong>另一个限制是</strong>，<strong>如果我们得到了一个值而不是一个键时，那么散列是不会有帮助的</strong>：<code>containsValue</code>是线性的，因为它必须搜索所有的子映射。查找一个值并找到相应的键（或可能的键），没有特别有效的方式。</p><p>还有一个限制：<code>MyLinearMap</code>的<strong>一些常数时间的方法变成了线性的</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maps.size(); i++) &#123;</span><br><span class="line">        maps.get(i).clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clear</code>必须清除所有的子映射，子映射的数量与<code>n</code>成正比，所以它是线性的。幸运的是，这个操作并不常用，所以在大多数应用中，这种权衡是可以接受的。</p><br><h6 id="4-检查MyHashMap"><a href="#4-检查MyHashMap" class="headerlink" title="4.检查MyHashMap"></a>4.检查MyHashMap</h6><p>在我们继续之前，我们应该检查一下，<code>MyHashMap.put</code>是否真的是常数时间。</p><p>下面是测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileMyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> MyHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                map.put(String.format(<span class="string">"%10d"</span>,i),i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMillis = <span class="number">5000</span>;</span><br><span class="line">    runProfiler(<span class="string">"MyHashMap put"</span>, timeable, startN, endMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>, <span class="number">131</span></span><br><span class="line"><span class="number">2000</span>, <span class="number">366</span></span><br><span class="line"><span class="number">4000</span>, <span class="number">974</span></span><br><span class="line"><span class="number">8000</span>, <span class="number">3088</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">11760</span></span><br><span class="line">Estimated slope= <span class="number">1.6053112075356588</span></span><br></pre></td></tr></table></figure><p>可以发现，<strong>它的斜率为1.6左右，这表明这个实现不是一直都是常数的</strong>，检查一下问题出在哪里.</p><br><h6 id="5-修复MyHashMap"><a href="#5-修复MyHashMap" class="headerlink" title="5.修复MyHashMap"></a>5.修复MyHashMap</h6><p><code>MyHashMap</code>的问题是<code>size</code>，它继承自<code>MyBetterMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (MyLinearMap&lt;K, V&gt; map: maps) &#123;</span><br><span class="line">        total += map.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了累计整个大小，它必须迭代子映射。<strong>由于我们增加了子映射的数量<code>k</code>，随着条目数<code>n</code>增加，所以<code>k</code>与<code>n</code>成正比，所以<code>size</code>是线性的。</strong></p><p><strong><code>put</code>也是线性的</strong>，因为它使用<code>size</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    V oldValue = <span class="keyword">super</span>.put(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; maps.size() * FACTOR) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>size</code>是线性的，我们做的一切都浪费了。幸运的是，有一个简单的解决方案，我们以前看过：我们必须维护实例变量中的条目数，并且每当我们调用一个改变它的方法时更新它。（<strong>实时更新size</strong>）</p><p>下面是它的初始结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFixedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们不修改<code>MyHashMap</code>，我定义一个扩展它的新类。它添加一个新的实例变量<code>size</code>，它被初始化为零。</p><p>更新<code>remove</code>和<code>put</code>有点困难，因为当我们调用超类的该方法，我们不能得知子映射的大小是否改变。这是我的解决方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    size -= map.size();</span><br><span class="line">    V oldValue = map.remove(key);</span><br><span class="line">    size += map.size();</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove</code>使用<code>chooseMap</code>找到正确的子映射，然后减去子映射的大小。它会在子映射上调用<code>remove</code>，根据是否找到了键，它可以改变子映射的大小，也可能不会改变它的大小。但是无论哪种方式，<strong>我们将子映射的新大小加到<code>size</code>，所以最终的<code>size</code>值是正确的。</strong></p><p>新版的<code>put</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    size -= map.size();</span><br><span class="line">    V oldValue = map.put(key, value);</span><br><span class="line">    size += map.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; maps.size() * FACTOR) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我测量这个解决方案时，我发现放入<code>n</code>个键的总时间正比于<code>n</code>，也就是说，<strong>每个<code>put</code>是常数时间的</strong>，符合预期。</p><p>我们正常的去走下流程，<code>chooseMap</code>为常数时间，子映射的<code>push</code>为常数时间，<code>rehash</code>为常数时间，<strong>现在的<code>put</code>方法是常数时间，</strong>同之前对比，我们所作的改变主要体现在两个方面：</p><ul><li><strong>摊销分析</strong>，通过摊销分析，随着map变大，扩充哈希表，添加子映射摊销时间复杂度，通过加载因子控制每个子映射的数量</li><li><strong>实时更新Size</strong>，由于之前的摊销分析，增加了多个子映射，size()由原来的常数级变为线性级方法，我们实时维护更新它，使得它也变为常数级方法</li></ul><p>下面给出性能测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileMyFixedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            map = <span class="keyword">new</span> MyFixedHashMap&lt;String, Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                map.put(String.format(<span class="string">"%10d"</span>,i),i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMillis = <span class="number">1000</span>;</span><br><span class="line">    runProfiler(<span class="string">"MyHashMap put"</span>, timeable, startN, endMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试图：<br><img src="https://img-blog.csdnimg.cn/20190424102817217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8000</span>, <span class="number">243</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">288</span></span><br><span class="line"><span class="number">32000</span>, <span class="number">428</span></span><br><span class="line"><span class="number">64000</span>, <span class="number">615</span></span><br><span class="line"><span class="number">128000</span>, <span class="number">1281</span></span><br><span class="line">Estimated slope= <span class="number">0.5891002112256021</span></span><br></pre></td></tr></table></figure><br><h6 id="6-UML类图"><a href="#6-UML类图" class="headerlink" title="6.UML类图"></a>6.UML类图</h6><p>这里用 <a href="http://yuml.me/" target="_blank" rel="noopener">yUML</a> 生成<strong>UML类图</strong>，帮助我们梳理本章中的类</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/11-2.jpg" alt=""></p><p>不同的关系由不同的箭头表示：</p><ul><li>实心箭头表示 HAS-A 关系。例如，每个<code>MyBetterMap</code>实例包含多个<code>MyLinearMap</code>实例，因此它们通过实线箭头连接。</li><li>空心和实线箭头表示 IS-A 关系。例如，<code>MyHashMap</code>扩展 了<code>MyBetterMap</code>，因此它们通过 IS-A 箭头连接。</li><li>空心和虚线箭头表示一个类实现了一个接口;在这个图中，每个类都实现 <code>Map</code>。</li></ul><p><strong>UML 类图提供了一种简洁的方式，来表示大量类集合的信息。</strong>在设计阶段中，它们用于交流备选设计，在实施阶段中，用于维护项目的共享思维导图，并在部署过程中记录设计。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 摊销分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十一）哈希</title>
      <link href="/blog/2019/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%93%88%E5%B8%8C/"/>
      <url>/blog/2019/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>在本章中，我定义了一个比<code>MyLinearMap</code>更好的<code>Map</code>接口实现，<code>MyBetterMap</code>，并引入哈希，这使得<code>MyBetterMap</code>效率更高。</p></blockquote><br><h6 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h6><p>为了提高<code>MyLinearMap</code>的性能，我们将编写一个新的类，它被称为<code>MyBetterMap</code>，它包含<code>MyLinearMap</code>对象的集合。<strong>它在内嵌的映射之间划分键，因此每个映射中的条目数量更小</strong>，这加快了<code>findEntry</code>，以及依赖于它的方法的速度。</p><p>类定义的开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBetterMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBetterMap</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        makeMaps(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k值关系到hashCode的分配</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">makeMaps</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        maps = <span class="keyword">new</span> ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            maps.add(<span class="keyword">new</span> MyLinearMap&lt;K, V&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量<code>maps</code>是一组<code>MyLinearMap</code>对象。构造函数接受一个参数<code>k</code>，<strong>决定至少最开始，要使用多少个映射</strong>。然后<code>makeMaps</code>创建内嵌的映射并将其存储在一个<code>ArrayList</code>中。</p><p>现在，完成这项工作的关键是，<strong>我们需要一些方法来查看一个键，并决定应该进入哪个映射(首先要放进去，放到哪里用HashCode算法决定)</strong>。当我们<code>put</code>一个新的键时，我们选择一个映射；当我们<code>get</code>同样的键时，我们必须记住我们把它放在哪里(<strong>重点是要确定如何跟踪</strong>)。</p><p>一种可能性是<strong>随机选择一个子映射</strong>，并跟踪我们把每个键放在哪里(<strong>无法跟踪</strong>)。</p><p>一个更好的方法是<strong>使用一个哈希函数</strong>，它接受一个<code>Object</code>，一个任意的<code>Object</code>，并返回一个称为哈希码的整数。重要的是，<strong>如果它不止一次看到相同的<code>Object</code>，它总是返回相同的哈希码</strong>。这样，如果我们使用哈希码来存储键，当我们查找时，我们将得到相同的哈希码。</p><p>在Java中，每个<code>Object</code>都提供了<code>hashCode</code>，一种计算哈希函数的方法。<strong>这种方法的实现对于不同的对象是不同的</strong>；我们会很快看到一个例子。</p><p>选择到正确的子映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> 为一个给定的键选择正确的子映射（同makeMaps的初始化数量有关）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 10:53 2019/4/23</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MyLinearMap&lt;K, V&gt; <span class="title">chooseMap</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123; </span><br><span class="line">        index = Math.abs(key.hashCode()) % maps.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maps.get(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>key</code>是<code>null</code>，我们选择索引为<code>0</code>的子映射。否则，我们使用<code>hashCode</code>获取一个整数，调用<code>Math.abs</code>来确保它是非负数，然后使用余数运算符<code>%</code>，<strong>这保证结果在<code>0</code>和<code>maps.size()-1</code>之间</strong>。<strong>所以<code>index</code>总是一个有效的<code>maps</code>索引</strong>。然后<code>chooseMap</code>返回为其所选的映射的引用。</p><p>我们使用<code>chooseMap</code>的<code>put</code>和<code>get</code>，所以<strong>当我们查询键的时候，我们得到添加时所选的相同映射，我们选择了相同的映射</strong>。至少应该是 - 稍后我会解释为什么这<strong>可能不起作用</strong>。</p><p><code>put</code>和<code>get</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    MyLinearMap&lt;K, V&gt; map = chooseMap(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>chooseMap</code>来找到正确的子映射，然后在子映射上调用一个方法，我们考虑一下性能.</p><p><strong>如果在<code>k</code>个子映射中分配了<code>n</code>个条目，则平均每个映射将有<code>n/k</code>个条目。当我们查找一个键时，我们必须计算其哈希码，这需要一些时间，然后我们搜索相应的子映射。</strong></p><p>因为<code>MyBetterMap</code>中的条目列表，比<code>MyLinearMap</code>中的短<code>k</code>倍，我们的预期是<code>ķ</code>倍的搜索速度。<strong>但运行时间仍然与<code>n</code>成正比(n/k)，所以<code>MyBetterMap</code>仍然是线性的</strong>。在下一个练习中，你将看到如何解决这个问题。</p><p>关于此问题的思考，现在考虑一种比较极端的情况，如果恰好所有数据都集中在一个子映射中，那么效率将跟线性方法一样.<br></p><br><h6 id="2-哈希如何工作"><a href="#2-哈希如何工作" class="headerlink" title="2.哈希如何工作"></a>2.哈希如何工作</h6><p>哈希函数的基本要求是，<strong>每次相同的对象应该产生相同的哈希码</strong>。对于不变的对象，这是比较容易的。对于具有可变状态的对象，我们必须花费更多精力。</p><p>作为一个不可变对象的例子，我将定义一个<code>SillyString</code>类，它包含一个<code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyString</span><span class="params">(String innerString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.innerString = innerString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用它来展示，一个类如何定义它自己的哈希函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;innerString.length(); i++) &#123;</span><br><span class="line">        total += innerString.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>SillyString</code>重写了<code>equals</code>和<code>hashCode</code>。这个很重要。为了正常工作，<code>equals</code>必须和<code>hashCode</code>一致，这意味着如果两个对象被认为是相等的 - 也就是说，<code>equals</code>返回<code>true</code> - 它们应该有相同的哈希码。<strong>但这个要求只是单向的；如果两个对象具有相同的哈希码，则它们不一定必须相等。</strong>（不可逆）</p><p><code>hashCode</code>的原理是，<strong>迭代<code>String</code>中的字符并将它们相加</strong>。当你向<code>int</code>添加一个字符时，Java 将使用其 Unicode 代码点，将字符转换为整数。</p><p>该哈希函数满足要求：<strong>如果两个<code>SillyString</code>对象包含相等的内嵌字符串，则它们将获得相同的哈希码。</strong></p><p>这可以正常工作，<strong>但它可能不会产生良好的性能，因为它为许多不同的字符串返回相同的哈希码</strong>。如果两个字符串以任何顺序包含相同的字母，它们将具有相同的哈希码。即使它们不包含相同的字母，它们可能会产生相同的总量，例如<code>&quot;ac&quot;</code>和<code>&quot;bb&quot;</code>。或者<code>abc</code>同<code>cab</code>的哈希码也是一致的</p><p><strong>如果许多对象具有相同的哈希码，它们将在同一个子映射中。如果一些子映射比其他映射有更多的条目，那么当我们有<code>k</code>个映射时，加速比可能远远小于<code>k</code>。</strong>所以哈希函数的<strong>目的之一是统一</strong>；也就是说，以相等的可能性，在这个范围内产生任何值。(<strong>等概率的在子映射中分配条目，这正是之前我们所担心的</strong>)</p><br><h6 id="3-哈希和可变性"><a href="#3-哈希和可变性" class="headerlink" title="3.哈希和可变性"></a>3.哈希和可变性</h6><p><code>String</code>是不可变的，<code>SillyString</code>也是不可变的，因为<code>innerString</code>定义为<code>final</code>。一旦你创建了一个<code>SillyString</code>，你不能使<code>innerString</code>引用不同的<code>String</code>，你不能修改所指向的<code>String</code>。因此，它将始终具有相同的哈希码。</p><p>我们现在用一个Array，和以上的一样，改变的是之前是String,现在是数组(<strong>可变</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SillyArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SillyArray</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().equals(other.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">            total += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>SillyArray</code>也提供<code>setChar</code>，它能够修改修改数组内的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.array[i] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我们创建了一个<code>SillyArray</code>，并将其添加到<code>map</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SillyArray array1 = <span class="keyword">new</span> SillyArray(<span class="string">"Word1"</span>.toCharArray());</span><br><span class="line">map.put(array1, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这个数组的哈希码是<code>461</code>。现在如果我们修改了数组内容，之后尝试查询它，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1.setChar(<span class="number">0</span>, <span class="string">'C'</span>);</span><br><span class="line">Integer value = map.get(array1);</span><br></pre></td></tr></table></figure><p>修改之后的哈希码是<code>441</code>。<strong>使用不同的哈希码，我们就很可能进入了错误的子映射</strong>。这就很糟糕了。</p><p><strong>一般来说，使用可变对象作为散列数据结构中的键是很危险的</strong>，这包括<code>MyBetterMap</code>和<code>HashMap</code>。如果你可以<strong>保证映射中的键不被修改，或者任何更改都不会影响哈希码</strong>，那么这可能是正确的。但是避免这样做可能是一个好主意。（个人认为还是直接避免这种不安全的操作比较好）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（十）Map接口</title>
      <link href="/blog/2019/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89Map%E6%8E%A5%E5%8F%A3/"/>
      <url>/blog/2019/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89Map%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>在接下来的几个练习中，我介绍了<code>Map</code>接口的几个实现。其中一个基于哈希表，这可以说是所发明的最神奇的数据结构。另一个是类似的<code>TreeMap</code>，不是很神奇，但它有附加功能，它可以按顺序迭代元素。</p><p>我们从一个<code>Map</code>开始，它使用键值对的<code>List</code>实现。</p></blockquote><br><h6 id="1-实现MyLinearMap"><a href="#1-实现MyLinearMap" class="headerlink" title="1.实现MyLinearMap"></a>1.实现MyLinearMap</h6><p>简单来说，就是继承Map,放入List中,来看下初始结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinearMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Entry&gt; entries = <span class="keyword">new</span> ArrayList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><p><code>MyLinearMap</code>对象具有单个实例变量，<code>entries</code>，这是一个<code>Entry</code>的<code>ArrayList</code>对象。每个<code>Entry</code>都包含一个键值对。这里是定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><h6 id="2-分析MyLinearMap"><a href="#2-分析MyLinearMap" class="headerlink" title="2.分析MyLinearMap"></a>2.分析MyLinearMap</h6><p>两个私有方法<code>FindEntry</code>用于根据key值，找到对应的实体，<code>equal</code>用于比较，下边是实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">findEntry</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry entry: entries) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equals(target, entry.getKey())) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object target, Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.equals(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals</code>运行时间取决于值的大小，跟数目无关，<strong>是常数时间O(1)</strong>.</p><p><code>findEntry</code>运行时间取决于数目，最好的情况下，可以一开始就找到，但是平均下来的话，仍要遍历整个map,是线性时间，<strong>时间复杂度为O(n)</strong>.</p><p>大部分的<code>MyLinearMap</code>核心方法使用<code>findEntry</code>，包括<code>put</code>，<code>get</code>，和<code>remove</code>。这就是他们的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entries.add(<span class="keyword">new</span> Entry(key, value));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V oldValue = entry.getValue();</span><br><span class="line">        entry.setValue(value);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry entry = findEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V value = entry.getValue();</span><br><span class="line">        entries.remove(entry);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个方法中，调用<code>findEntry</code>是线性时间，其余操作都为常数时间，<strong>所以总的时间复杂度为线性时间</strong>。</p><p>总而言之，核心方法都是线性的，这就是为什么我们将这个实现称为<code>MyLinearMap</code></p><p><strong>如果我们知道输入的数量很少，这个实现可能会很好（很好的原因就是，数目少了有更大机率查找为常数时间）</strong>，但是我们可以做得更好。<strong>实际上，<code>Map</code>所有的核心方法都是常数时间的实现</strong>。当你第一次听到这个消息时，可能似乎觉得不可能。实际上我们所说的是，你可以在常数时间内大海捞针，不管海有多大。这是魔法。</p><p>我们不是将条目存储在一个大的<code>List</code>中，<strong>而是把它们分解成许多短的列表（这样查找时就为常数时间）</strong>。对于每个键，我们将使用哈希码（在下一节中进行说明）来确定要使用的列表。 使用大量的简短列表比仅仅使用一个更快，但正如我将解释的，它不会改变增长级别；核心功能仍然是线性的。但还有一个技巧：<strong>如果我们增加列表的数量来限制每个列表的条目数，就会得到一个恒定时间的映射</strong>。你会在下一个练习中看到细节，但是首先要了解哈希！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性Map </tag>
            
            <tag> Map接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（九）索引器</title>
      <link href="/blog/2019/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
      <url>/blog/2019/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E7%B4%A2%E5%BC%95%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>目前，我们构建了一个基本的 Web 爬虫；我们下一步将是索引。在网页搜索的上下文中，<strong>索引是一种数据结构，可以查找检索词并找到该词出现的页面</strong>。此外，我们想知道每个页面上显示检索词的次数，这将有助于确定与该词最相关的页面。</p><p>例如，如果用户提交检索词“Java”和“编程”，我们将查找两个检索词并获得两组页面。带有“Java”的页面将包括 Java 岛屿，咖啡昵称以及编程语言的网页。具有“编程”一词的页面将包括不同编程语言的页面，以及该单词的其他用途。通过选择具有两个检索词的页面，我们希望消除不相关的页面，并找到 Java 编程的页面。现在我们了解索引是什么，它执行什么操作，我们可以设计一个数据结构来表示它</p></blockquote><h6 id="1-数据结构选取"><a href="#1-数据结构选取" class="headerlink" title="1.数据结构选取"></a>1.数据结构选取</h6><p>索引的基本操作是查找；具体来说，我们需要能够查找检索词并找到包含它的所有页面。最简单的实现将是页面的集合。给定一个检索词，我们可以遍历页面的内容，并选择包含检索词的内容。但运行时间与所有页面上的总字数成正比，这太慢了(最简单的思路就这样)。</p><p>一个更好的选择是一个映射（<code>字典</code>），它是一个数据结构，表示键值对的集合，并提供了一种方法，快速查找键以及相应值。例如，我们将要构建的第一个映射是<code>TermCounter</code>，<strong>它将每个检索词映射为页面中出现的次数。键是检索词，值是计数（也称为“频率”）</strong>。</p><p>Java 提供了<code>Map</code>的调用接口，它指定映射应该提供的方法；最重要的是：</p><ul><li><code>get(key)</code>：此方法查找一个键并返回相应的值。</li><li><code>put(key, value)</code>：该方法向<code>Map</code>添加一个新的键值对，或者如果该键已经在映射中，它将替换与<code>key</code>关联的值。</li></ul><p>除了检索词到计数的映射<code>TermCounter</code>之外，我们将定义一个被称为<code>Index</code>的类，<strong>它将检索词映射为出现的页面的集合</strong>。而这又引发了下一个问题，即如何表示页面集合。同样，如果我们考虑我们想要执行的操作，它们就指导了我们的决定。</p><p><strong>在这种情况下，我们需要组合两个或多个集合，并找到所有这些集合中显示的页面</strong>（敲黑板，也就是需要找到包含并集的页面）。你可以将此操作看做集合的交集：两个集合的交集是出现在两者中的一组元素。</p><p>你可能猜到了，Java 提供了一个<code>Set</code>接口，来定义集合应该执行的操作。它实际上并不提供设置交集，但它提供了方法，使我们能够有效地实现交集和其他结合操作。核心的<code>Set</code>方法是：</p><ul><li><code>add(element)</code>：该方法将一个元素添加到集合中；如果元素已经在集合中，则它不起作用。</li><li><code>contains(element)</code>：该方法检查给定元素是否在集合中。</li></ul><p>现在我们自顶向下设计了我们的数据结构，我们将从内到外实现它们，从<code>TermCounter</code>开始。<br><br></p><h6 id="2-TermCounter"><a href="#2-TermCounter" class="headerlink" title="2.TermCounter"></a>2.<code>TermCounter</code></h6><p><code>TermCounter</code>是一个类，表示检索词到页面中出现次数的映射。这是类定义的第一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TermCounter</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量<code>map</code>包含检索词到计数的映射（这里使用HashMap），并且<code>label</code>标识检索词的来源文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String term, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    map.put(term, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    Integer count = map.get(term);</span><br><span class="line">    <span class="keyword">return</span> count == <span class="keyword">null</span> ? <span class="number">0</span> : count;   <span class="comment">//没有就返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTermCount</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">    put(term, get(term) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>帮助索引网页的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElements</span><span class="params">(Elements paragraphs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node node: paragraphs) &#123;</span><br><span class="line">           processTree(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Node node: <span class="keyword">new</span> WikiNodeIterable(root)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">               processText(((TextNode) node).text());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 用空格替换标点符号，转换为小写，并以空格为分隔符</span></span><br><span class="line">       String[] array = text.replaceAll(<span class="string">"\\pP|\\pS"</span>,<span class="string">" "</span>)</span><br><span class="line">                           .toLowerCase()</span><br><span class="line">                           .split(<span class="string">"\\s+"</span>);</span><br><span class="line">       <span class="keyword">for</span> (String term : array) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!term.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">               incrementTermCount(term);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>特别强调，这里还要去除””,否则结果会显示计数</strong></p><p><code>测试用例</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line">WikiFetcher wf = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line">Elements para = wf.fetchWikiPedia(url);</span><br><span class="line"></span><br><span class="line">TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">tc.processElements(para);</span><br><span class="line">tc.printCounts();</span><br></pre></td></tr></table></figure><p><code>部分测试结果(截取底部数据)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command,<span class="number">2</span></span><br><span class="line">performance,<span class="number">4</span></span><br><span class="line"><span class="keyword">boolean</span>,<span class="number">1</span></span><br><span class="line">currently,<span class="number">1</span></span><br><span class="line">compliance,<span class="number">1</span></span><br><span class="line">response,<span class="number">1</span></span><br><span class="line">variable,<span class="number">2</span></span><br><span class="line">arguments,<span class="number">3</span></span><br><span class="line">Total of counts:<span class="number">4020</span></span><br></pre></td></tr></table></figure><br><h6 id="3-Index类的实现"><a href="#3-Index类的实现" class="headerlink" title="3.Index类的实现"></a>3.Index类的实现</h6><p>这个类的主要目的是实现：<strong>实例变量<code>index</code>是每个检索词到一组<code>TermCounter</code>对象的映射。每个<code>TermCounter</code>表示检索词出现的页面。</strong></p><p>这是它的基础结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Set&lt;TermCounter&gt;&gt; index = </span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String term, TermCounter tc)</span> </span>&#123;</span><br><span class="line">        Set&lt;TermCounter&gt; set = get(term);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we're seeing a term for the first time, make a new Set</span></span><br><span class="line">        <span class="keyword">if</span> (set == <span class="keyword">null</span>) &#123;</span><br><span class="line">            set = <span class="keyword">new</span> HashSet&lt;TermCounter&gt;();</span><br><span class="line">            index.put(term, set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise we can modify an existing Set</span></span><br><span class="line">        set.add(tc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;TermCounter&gt; <span class="title">get</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index.get(term);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>add</code>方法向集合添加新的<code>TermCounter</code>，它与检索词关联。当我们索引一个尚未出现的检索词时，我们必须创建一个新的集合。否则我们可以添加一个新的元素到一个现有的集合。在这种情况下，<code>set.add</code>修改位于<code>index</code>里面的集合，但不会修改<code>index</code>本身。  <strong>我们唯一修改<code>index</code>的时候是添加一个新的检索词</strong></p><p>这种数据结构比较复杂。回顾一下，<code>Index</code>包含<code>Map</code>，将每个检索词映射到<code>TermCounter</code>对象的<code>Set</code>，每个<code>TermCounter</code>包含一个<code>Map</code>，<strong>将检索词映射到计数</strong>（这是值得一提的部分）。</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/8-1.jpg" alt=""></p><p><code>printIndex</code>方法展示了如何解压缩此数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String term: index.keySet()) &#123;</span><br><span class="line">            System.out.println(term);</span><br><span class="line"></span><br><span class="line">            Set&lt;TermCounter&gt; tcs = get(term);</span><br><span class="line">            <span class="keyword">for</span> (TermCounter tc: tcs) &#123;</span><br><span class="line">                Integer count = tc.get(term);</span><br><span class="line">                System.out.println(tc.getLabel()+ <span class="string">"   "</span>+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>外层循环遍历检索词。内层循环迭代<code>TermCounter</code>对象。</strong></p><p><code>indexPage</code>统计页面中的检索词:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexPage</span><span class="params">(String url, Elements paragraphs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  生成一个 TermCounter 并统计段落中的检索词</span></span><br><span class="line">       TermCounter tc = <span class="keyword">new</span> TermCounter(url);</span><br><span class="line">       tc.processElements(paragraphs);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 对于 TermCounter 中的每个检索词，将 TermCounter 添加到索引</span></span><br><span class="line">       <span class="keyword">for</span> (String term: tc.keySet()) &#123;</span><br><span class="line">           add(term,tc);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>测试</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WikiFetcher wikiFetcher = <span class="keyword">new</span> WikiFetcher();</span><br><span class="line">Index indexer = <span class="keyword">new</span> Index();</span><br><span class="line"></span><br><span class="line">String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line">Elements paragraphs = wikiFetcher.fetchWikiPedia(url);</span><br><span class="line">indexer.indexPage(url,paragraphs);</span><br><span class="line"></span><br><span class="line">String url1 = <span class="string">"https://en.wikipedia.org/wiki/Programming_language"</span>;</span><br><span class="line">Elements paragraphs1 = wikiFetcher.fetchWikiPedia(url);</span><br><span class="line">indexer.indexPage(url1,paragraphs1);</span><br><span class="line"></span><br><span class="line">indexer.printIndex();</span><br></pre></td></tr></table></figure><p><code>部分测试结果</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   1</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   1</span></span><br><span class="line">variable</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   2</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   2</span></span><br><span class="line">arguments</span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Java_(programming_language)   3</span></span><br><span class="line">https:<span class="comment">//en.wikipedia.org/wiki/Programming_language   3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 索引器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（八）到达哲学</title>
      <link href="/blog/2019/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%B0%E8%BE%BE%E5%93%B2%E5%AD%A6/"/>
      <url>/blog/2019/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%B0%E8%BE%BE%E5%93%B2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本章的目标是开发一个Web爬虫，同时验证之前提到的 <code>到达哲学</code> </p></blockquote><h6 id="1-起步"><a href="#1-起步" class="headerlink" title="1.起步"></a>1.起步</h6><p>首先介绍本章中帮你起步的代码：</p><ul><li><code>WikiNodeExample.java</code>包含前一章的代码，展示了 DOM 树中深度优先搜索（DFS）的递归和迭代实现。</li><li><code>WikiNodeIterable.java</code>包含<code>Iterable</code>类，用于遍历 DOM 树。我将在下一节中解释这段代码。</li><li><code>WikiFetcher.java</code>包含一个工具类，使用<code>jsoup</code>从维基百科下载页面。为了帮助你遵守维基百科的服务条款，此类限制了你下载页面的速度；如果你每秒请求许多页，在下载下一页之前会休眠一段时间。</li><li><code>WikiPhilosophy.java</code>包含你为此练习编写的代码的大纲。我们将在下面进行说明。</li></ul><br><h6 id="2-可迭代对象和迭代器"><a href="#2-可迭代对象和迭代器" class="headerlink" title="2.可迭代对象和迭代器"></a>2.可迭代对象和迭代器</h6><p>在前一章中，我展示了迭代式深度优先搜索（DFS），并且认为与递归版本相比， <strong>迭代版本的优点</strong>在于， <strong>它更容易包装在<code>Iterator</code>对象中（Iterable是一种数据结构，Iterator是用来迭代的迭代器）</strong>。在本节中，我们将看到如何实现它。</p><p><strong>外层的类<code>WikiNodeIterable</code>实现<code>Iterable&lt;Node&gt;</code>接口，所以我们可以在一个<code>for</code>循环中使用它：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node root = ...</span><br><span class="line">Iterable&lt;Node&gt; iter = <span class="keyword">new</span> WikiNodeIterable(root);</span><br><span class="line"><span class="keyword">for</span> (Node node: iter) &#123;</span><br><span class="line">    visit(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 root为树的根节点，visit() 是到Node节点时，你想做的任意的事.</p><p><code>WikiNodeIterable</code>的实现遵循以下惯例：</p><ul><li>构造函数接受并存储根<code>Node</code>的引用。</li><li><code>iterator</code>方法创建一个返回一个<code>Iterator</code>对象。</li></ul><p>下边是它的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiNodeIterable</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从给定的节点开始创造一个迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiNodeIterable</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Node&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WikiNodeIterator(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类  <code>WikiNodeIterator</code>，<strong>执行所有实际工作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Iterator的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiNodeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个堆栈跟踪等待访问的节点</span></span><br><span class="line">    Deque&lt;Node&gt;  stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用堆栈上的根节点初始化Iterator。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WikiNodeIterator</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        <span class="comment">// 反转后将child节点放入堆栈中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;(node.childNodes());</span><br><span class="line">        Collections.reverse(nodes);</span><br><span class="line">        <span class="keyword">for</span> (Node child : nodes) &#123;</span><br><span class="line">            stack.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码与 DFS 的迭代版本几乎相同(<strong>DFS是写在一块的</strong>)，但现在分为三个方法：</p><ul><li>构造函数初始化栈（使用一个<code>ArrayDeque</code>实现）并将根节点压入这个栈。</li><li><code>isEmpty</code>检查栈是否为空。</li><li><code>next</code>从<code>Node</code>栈中弹出下一个节点，按相反的顺序压入子节点，并返回弹出的<code>Node</code>。如果有人在空<code>Iterator</code>上调用<code>next</code>，则会抛出异常。</li></ul><p>可能不明显的是，值得使用两个类和五个方法，来重写一个完美的方法。但是现在我们已经完成了，在需要<code>Iterable</code>的任何地方，我们可以使用<code>WikiNodeIterable</code>，这使得它的语法整洁，易于将迭代逻辑（DFS）与我们对节点的处理分开。<br><br></p><h6 id="3-WikiFetcher"><a href="#3-WikiFetcher" class="headerlink" title="3.WikiFetcher"></a>3.<code>WikiFetcher</code></h6><p>编写 Web 爬虫时，很容易下载太多页面，这<strong>可能会违反你要下载的服务器的服务条款</strong>。为了帮助你避免这种情况，我提供了一个<code>WikiFetcher</code>类，它可以做两件事情:</p><ul><li>它封装了我们在上一章中介绍的代码，用于从维基百科下载页面，<strong>解析 HTML 以及选择内容文本</strong>。</li><li>它测量请求之间的时间，如果我们在请求之间没有足够的时间，它将休眠直到经过了合理的间隔。默认情况下，间隔为<code>1</code>秒（<strong>防止过度请求</strong>）。</li></ul><p>这里是<code>WikiFetcher</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiFetcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastRequestTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minIterval = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  找到并解析数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 10:15 2019/4/16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Elements <span class="title">fetchWikiPedia</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sleepIfNeed();</span><br><span class="line">        Connection connection = Jsoup.connect(url);</span><br><span class="line">        Document doc = connection.get();</span><br><span class="line">        Element content = doc.getElementById(<span class="string">"mw-content-text"</span>);</span><br><span class="line">        Elements para = content.select(<span class="string">"p"</span>);</span><br><span class="line">        <span class="keyword">return</span> para;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 通过最小访问时间来限制范围访问频率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 10:43 2019/4/16</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepIfNeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRequestTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> nextRequestTime = lastRequestTime + minIterval;</span><br><span class="line">            <span class="keyword">if</span> (currentTime &lt; lastRequestTime) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(nextRequestTime - currentTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Warning: sleep interrupted in fetchWikipedia."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastRequestTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的代码是<code>sleepIfNeeded</code>，它检查自上次请求以来的时间，如果经过的时间小于<code>minInterval</code>（毫秒），则休眠。<br><br></p><h6 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h6><p>在<code>WikiPhilosophy.java</code>中，你会发现一个简单的<code>main</code>方法，展示了如何使用这些部分。从这个代码开始，你的工作是写一个爬虫：</p><ol><li>获取维基百科页面的 URL，下载并分析。</li><li>它应该<strong>遍历所得到的 DOM 树来找到第一个 有效的链接</strong>。我会在下面解释“有效”的含义。</li><li>如果页面没有链接，或者如果第一个链接是我们已经看到的页面，程序应该指示失败并退出。</li><li>如果链接匹配维基百科页面上的哲学网址，程序应该提示成功并退出。</li><li>否则应该回到步骤<code>1</code>。</li></ol><p>该程序应该为它访问的 URL 构建<code>List</code>，<strong>并在结束时显示结果（无论成功还是失败）</strong>。</p><p><code>那么我们应该认为什么是“有效的”链接？</code></p><ul><li>这个链接<strong>应该在页面的内容文本中</strong>，而不是侧栏或弹出框。</li><li>它<strong>不应该是斜体或括号</strong>。</li><li>你应该<strong>跳过外部链接</strong>，当前页面的链接和红色链接。</li><li>在某些版本中，如果文本以大写字母开头，则应跳过链接。</li></ul><p><code>如果你有足够的信息来起步，请继续。或者你可能想要阅读这些提示：</code></p><ul><li>当你遍历树的时候，你将需要处理的两种<code>Node</code>是<code>TextNode</code>和<code>Element</code>。如果你找到一个<code>Element</code>，你可能需要转换它的类型，来访问标签和其他信息。</li><li>当你<strong>找到包含链接的<code>Element</code>时</strong>，<strong>通过向上跟踪父节点链，可以检查是否是斜体</strong>。如果父节点链中有一个<code>&lt;i&gt;</code>或<code>&lt;em&gt;</code>标签，链接为斜体。</li><li>为了检查链接是否在括号中，你必须在遍历树时扫描文本，并跟踪开启和闭合括号（理想情况下，你的解决方案应该能够处理嵌套括号（像这样））。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> 到达哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（七） 树的遍历</title>
      <link href="/blog/2019/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%20%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/blog/2019/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%20%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本章将介绍一个 Web 搜索引擎，我们将在本书其余部分开发它。我描述了搜索引擎的元素，并介绍了第一个应用程序，一个从<strong>维基百科下载和解析页面的 Web 爬行器</strong>。本章还介绍了<strong>深度优先搜索的递归实现</strong>，以及迭代实现，它使用 Java <code>Deque</code>实现“后入先出”的栈。</p></blockquote><h6 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1.搜索引擎"></a>1.搜索引擎</h6><p>网络搜索引擎，像谷歌搜索或 Bing，接受一组“检索项”，并返回一个网页列表，它们和这些项相关。</p><p><strong>搜索引擎的基本组成部分是</strong>：</p><ul><li><strong>抓取</strong>：我们需要一个程序，可以下载网页，解析它，并提取文本和任何其他页面的链接。 </li><li><strong>索引</strong>：我们需要一个数据结构，可以查找一个检索项，并找到包含它的页面。</li><li><strong>检索：</strong>我们需要一种方法，从索引中收集结果，并识别与检索项最相关的页面。</li></ul><p>我们以爬虫开始。<strong>爬虫的目标是查找和下载一组网页</strong>。对于像 Google 和 Bing 这样的搜索引擎，目标是查找所有网页，但爬虫通常仅限于较小的域。在我们的例子中，我们只会读取维基百科的页面。</p><p>作为第一步，我们将构建一个读取维基百科页面的爬虫，找到第一个链接，并跟着链接来到另一个页面，然后重复。我们将使用这个爬虫来测试“到达哲学”的猜想，它是：</p><blockquote><p>点击维基百科文章正文中的第一个小写的链接，然后对后续文章重复这个过程，通常最终会到达“哲学”的文章。</p></blockquote><p>在几个章节之内，我们将处理索引器，然后我们将到达检索器.<br><br></p><h6 id="2-解析HTML"><a href="#2-解析HTML" class="headerlink" title="2.解析HTML"></a>2.解析HTML</h6><p>下载网页时，内容使用HTML编写。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们的爬虫下载页面时，它需要解析 HTML，以便提取文本并找到链接。为此，我们将使用<code>jsoup</code>，<strong>它是一个下载和解析 HTML 的开源 Java 库</strong>。</p><p><strong>解析 HTML 的结果是文档对象模型（DOM）树</strong>，其中包含文档的元素，包括文本和标签。树是由节点组成的链接数据结构；节点表示文本，标签和其他文档元素.</p><p>节点之间的关系由文档的结构决定。在上面的例子中，第一个节点称为根，是<code>&lt;html&gt;</code>标签，它包含指向所包含两个节点的链接， <code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>；这些节点是根节点的子节点。</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/6-1.jpg" alt=""></p><h6 id="3-使用jsoup"><a href="#3-使用jsoup" class="headerlink" title="3.使用jsoup"></a>3.使用jsoup</h6><p><code>jsoup</code>非常易于下载，和解析 Web 页面，以及访问 DOM 树。这里是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String url = <span class="string">"https://en.wikipedia.org/wiki/Java_(programming_language)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下载并解析元素</span></span><br><span class="line">    Connection connection = Jsoup.connect(url);</span><br><span class="line">    Document doc = connection.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择内容，并解析初其中所有的段落</span></span><br><span class="line">    Element content = doc.getElementById(<span class="string">"mw-content-text"</span>);</span><br><span class="line">    Elements paragraphs = content.select(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Element xx : paragraphs) &#123;</span><br><span class="line">        System.out.println(xx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Jsoup.connect</code>接受<code>String</code>形式的<code>url</code>，并连接 Web 服务器。get<code>方法下载 HTML，解析，并返回</code>Document`对象，他表示 DOM。</p><p><code>Document</code>提供了导航树和选择节点的方法,这里主要展示了两种：</p><ul><li><code>getElementById</code>获取某个标签下的所有内容</li><li><code>select</code>可对获取的内容进行遍历，选择初想要的元素的集合(支持css选择器)</li></ul><p><code>Node</code>表示 DOM 树中的一个节点；有几个扩展<code>Node</code>的子类，其中包括 <code>Element</code>，<code>TextNode</code>，<code>DataNode</code>，和<code>Comment</code>。<code>Elements</code>是<code>Element</code>对象的<code>Collection</code></p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/6-3.jpg" alt=""></p><br><h6 id="4-遍历HTML"><a href="#4-遍历HTML" class="headerlink" title="4.遍历HTML"></a>4.遍历HTML</h6><p>为了使你变得更轻松，这里提供了一个<code>WikiNodeIterable</code>类，可以让你遍历 DOM 树中的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Elements paragraphs = content.select(<span class="string">"p"</span>);</span><br><span class="line">Element firstPara = paragraphs.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Iterable&lt;Node&gt; iter = <span class="keyword">new</span> WikiNodeIterable(firstPara);</span><br><span class="line"><span class="keyword">for</span> (Node node: iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">        System.out.print(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子紧接着上一个例子。它选择<code>paragraphs</code>中的第一个段落，然后创建一个<code>WikiNodeIterable</code>，它实现<code>Iterable&lt;Node&gt;</code>。<code>WikiNodeIterable</code>执行“<strong>深度优先搜索</strong>”，<strong>它按照它们将出现在页面上的顺序产生节点</strong>(这个是创造它的目的)。</p><p>在这个例子中，仅当<code>Node</code>是<code>TextNode</code>时，我们打印它，并忽略其他类型的<code>Node</code>，特别是代表标签的<code>Element</code>对象。结果是没有任何标记的 HTML 段落的纯文本。<br><br></p><h6 id="5-深度优先搜索"><a href="#5-深度优先搜索" class="headerlink" title="5.深度优先搜索"></a>5.深度优先搜索</h6><p>有几种方式可以合理地遍历一个树，每个都有不同的应用。我们从<strong>深度优先搜索（DFS</strong>）开始。DFS 从树的根节点开始，并选择第一个子节点。如果子节点有子节点，则再次选择第一个子节点。当它到达没有子节点的节点时，它回溯，沿树向上移动到父节点，在那里它选择下一个子节点，如果有的话；否则它会再次回溯。当它探索了根节点的最后一个子节点，就完成了(<strong>跟之前思维导图遍历节点一样</strong>)。</p><p>有两种常用的方式来实现 DFS，递归和迭代。</p><p>递归（代码简洁）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveDFS</span> <span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">           System.out.println(node);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Node child : node.childNodes()) &#123;</span><br><span class="line">           recursiveDFS(child);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法对树中的每一个<code>Node</code>调用，从根节点开始。如果<code>Node</code>是一个<code>TextNode</code>，它打印其内容。如果<code>Node</code>有任何子节点，它会按顺序在每一个子节点上调用<code>recursiveDFS</code>（<strong>前序遍历</strong>）。</p><p>通过进行递归调用，<code>recursiveDFS</code>使用<strong>调用栈来跟踪子节点并以正确的顺序处理它们</strong>。作为替代，我们可以使用栈数据结构自己跟踪节点；如果我们这样做，我们可以<strong>避免递归并迭代遍历树</strong>（非递归的好处）。<br><br></p><h6 id="6-Java中的栈"><a href="#6-Java中的栈" class="headerlink" title="6.Java中的栈"></a>6.Java中的栈</h6><p>在我解释 DFS 的迭代版本之前，我将解释栈数据结构。我们将从栈的一般概念开始，我将使用小写<code>s</code>指代“栈”。然后我们将讨论两个 Java<code>接口</code>，它们定义了栈的方法：<code>Stack</code>和<code>Deque</code>。</p><p>栈是与列表类似的数据结构：<strong>它是维护元素顺序的集合</strong>。栈和列表之间的主要区别是栈<strong>提供的方法较少</strong>。在通常的惯例中，它提供：</p><ul><li><p><code>push</code>：它将一个元素添加到栈顶。</p></li><li><p><code>pop</code>：它从栈中删除并返回最顶部的元素。</p></li><li><p><code>peek</code>：它返回最顶部的元素而不修改栈。 </p></li><li><p><code>isEmpty</code>：表示栈是否为空。</p><p>因为<code>pop</code>总是返回最顶部的元素，栈也称为 LIFO，代表“后入先出”。栈的替代品是“队列”，它返回的元素顺序和添加顺序相同；即“先入先出（FIFO）。</p></li></ul><p><strong>为什么栈和队列是有用的</strong>，可能不是很明显：它们不提供任何列表没有的功能；实际上它们提供的功能更少。那么为什么不使用列表的一切？有两个原因：</p><ul><li>如果你将自己限制于一小部分方法 - 也就是小型 API - <strong>你的代码将更加易读，更不容易出错</strong>。例如，如果使用列表来表示栈，则可能会以错误的顺序删除元素。使用栈 API，这种错误在字面上是不可能的。避免错误的最佳方法是使它们不可能(<strong>小型API可以给到很多限制，大型的兼容性强</strong>)。</li><li>如果一个数据结构提供了小型 API，那么它<strong>更容易实现</strong>。例如，实现栈的简单方法是单链表。当我们压入一个元素时，我们将它添加到列表的开头；当我们弹出一个元素时，我们在开头删除它。对于链表，在开头添加和删除是常数时间的操作，因此这个实现是高效的。相反，大型 API 更难实现高效。</li></ul><p>为了<strong>在 Java 中实现栈</strong>，你有三个选项：</p><ul><li>继续使用<code>ArrayList</code>或<code>LinkedList</code>。如果使用<code>ArrayList</code>，请务必从最后添加和删除，这是一个常数时间的操作。并且小心不要在错误的地方添加元素，或以错误的顺序删除它们。</li><li>Java 提供了一个<code>Stack</code>类，它提供了一组标准的栈方法。但是这个类是 Java 的一个旧部分：它与 Java 集合框架不兼容，后者之后才出现。</li><li>最<strong>好的选择可能是使用<code>Deque</code>接口的一个实现</strong>，如<code>ArrayDeque</code>。</li></ul><p><code>Deque</code>代表“<strong>双向队列</strong>”；在 Java 中， <code>Deque</code>接口提供<code>push</code>，<code>pop</code>，<code>peek</code>和<code>isEmpty</code>，因此你可以将<code>Deque</code>用作栈。<br><br></p><h6 id="7-迭代式DFS"><a href="#7-迭代式DFS" class="headerlink" title="7.迭代式DFS"></a>7.迭代式DFS</h6><p>这里是 DFS 的迭代版本，它使用<code>ArrayDeque</code>来表示<code>Node</code>对象的栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorDFS</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TextNode) &#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里必须反转，因为开始压栈时，顺序会反，所有需要反转，确保顺序正确</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;Node&gt;(node.childNodes());</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">for</span> (Node child : list) &#123;</span><br><span class="line">            stack.push(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>root</code>是我们想要遍历的树的根节点，所以我们首先创建栈并将根节点压入它。</p><p>循环持续到栈为空。每次迭代，它会从栈中弹出<code>Node</code>。如果它得到<code>TextNode</code>，它打印内容。然后它把子节点们压栈。<strong>为了以正确的顺序处理子节点，我们必须以相反的顺序将它们压栈;</strong> 我们通过将子节点复制成一个<code>ArrayList</code>，原地反转元素，然后遍历反转的<code>ArrayList</code>。</p><p>DFS 的迭代版本的一个优点是，<strong>更容易实现为 Java <code>Iterator</code></strong>；你会在下一章看到如何实现。<br><br><br><br><br>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/6.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/6.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的遍历 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（六）双链表</title>
      <link href="/blog/2019/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/blog/2019/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-双链表数据结构"><a href="#1-双链表数据结构" class="headerlink" title="1.双链表数据结构"></a>1.双链表数据结构</h6><blockquote><p><code>List</code>和<code>Deque</code>接口的双链表实现。[…] 所有的操作都能像双向列表那样执行。索引该列表中的操作将从头或者尾遍历列表，使用更接近指定索引的那个。</p></blockquote><ul><li>每个节点包含下一个节点的链接和上一个节点的链接。</li><li><code>LinkedList</code>对象包含指向列表的第一个和最后一个元素的链接。</li></ul><p>所以我们<strong>可以从列表的任意一端开始，并以任意方向遍历它</strong>。因此，我们可以在常数时间内，在列表的头部和末尾添加和删除元素！<br><br></p><h6 id="2-ArrayList-LinkedList和双链表的对比"><a href="#2-ArrayList-LinkedList和双链表的对比" class="headerlink" title="2.ArrayList,LinkedList和双链表的对比"></a>2.ArrayList,LinkedList和双链表的对比</h6><table><thead><tr><th></th><th align="center"><strong>MyArrayList</strong></th><th align="center"><strong>MyLinkedList</strong></th><th align="center">双链表</th></tr></thead><tbody><tr><td><code>add</code>（末尾）</td><td align="center">1</td><td align="center">n</td><td align="center">1</td></tr><tr><td><code>add</code>（开头）</td><td align="center">n(剩余的都往后)</td><td align="center">1</td><td align="center">1</td></tr><tr><td><code>add</code>（一般）</td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr><tr><td><code>get</code> / <code>set</code></td><td align="center">1</td><td align="center">n</td><td align="center">n</td></tr><tr><td><code>indexOf</code> / <code>lastIndexOf</code></td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr><tr><td><code>isEmpty</code> / <code>size</code></td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td><code>remove</code>（末尾）</td><td align="center">1</td><td align="center">n</td><td align="center">1</td></tr><tr><td><code>remove</code>（开头）</td><td align="center">n</td><td align="center">1</td><td align="center">1</td></tr><tr><td><code>remove</code>（一般）</td><td align="center">n</td><td align="center">n</td><td align="center">n</td></tr></tbody></table><br><h6 id="3-结构的选择"><a href="#3-结构的选择" class="headerlink" title="3.结构的选择"></a>3.结构的选择</h6><p>对于头部插入和删除，双链表的实现优于<code>ArrayList</code>。对于尾部插入和删除，都是一样好。所以，<code>ArrayList</code>唯一优势是<code>get</code>和<code>set</code>，链表中它需要线性时间，即使是双链表(<strong>根据实际需要解决的问题来看</strong>)。</p><p>如果你知道，你的应用程序的运行时间取决于<code>get</code>和<code>set</code>元素的所需时间，则<code>ArrayList</code>可能是更好的选择。如果运行时间取决于在开头或者末尾附加添加和删除元素，<code>LinkedList</code>可能会更好。</p><p>但请记住，这些建议是基于大型问题的增长级别。还有其他因素要考虑：</p><ul><li>如果这些操作不占用你应用的大部分运行时间 - 也就是说，如果你的应用程序花费大部分时间来执行其他操作 - 那么你对<code>List</code>实现的选择并不重要。</li><li>如果你正在处理的列表不是很大，你可能无法获得期望的性能。对于小型问题，二次算法可能比线性算法更快，或者线性可能比常数时间更快。而对于小型问题，差异可能并不重要。</li><li>另外，别忘了空间。到目前为止，我们专注于运行时间，但不同的实现需要不同的空间。在<code>ArrayList</code>中，这些元素并排存储在单个内存块中，所以浪费的空间很少，并且计算机硬件通常在连续的块上更快。在链表中，每个元素需要一个节点，带有一个或两个链接。链接占用空间（有时甚至超过数据！），并且节点分散在内存中，硬件效率可能不高。</li></ul><p>总而言之，算法分析为数据结构的选择提供了一些指南，但只有：</p><ul><li>你的应用的运行时间很重要，</li><li>你的应用的运行时间取决于你选择的数据结构，以及，</li><li>问题的规模足够大，增长级别实际上预测了哪个数据结构更好。</li></ul><p>作为一名软件工程师，在较长的职业生涯中，你几乎不必考虑这种情况。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（五）性能分析</title>
      <link href="/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>对于下一个练习，我提供了一个<code>Profiler</code>类，它包含代码，使用一系列<strong>问题规模运行方法</strong>，<strong>测量运行时间</strong>和<strong>绘制结果</strong>。</p><blockquote><p>你将使用<code>Profiler</code>，为 Java 的实现<code>ArrayList</code>和<code>LinkedList</code>，划分<code>add</code>方法的性能。</p></blockquote><ul><li><code>Profiler.java</code>包含上述<code>Profiler</code>类的实现。你会使用这个类，但你不必知道它如何工作。但可以随时阅读源码。</li><li><code>ProfileListAdd.java</code>包含此练习的起始代码，包括上面的示例，它测量了<code>ArrayList.add</code>。你将修改此文件来测量其他一些方法。<br><br></li></ul><h6 id="2-ArrayList的尾部添加"><a href="#2-ArrayList的尾部添加" class="headerlink" title="2.ArrayList的尾部添加"></a>2.ArrayList的尾部添加</h6><p>示例，展示如何使用分析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileArrayListAddEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">            List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//执行在启动计时之前所需的任何工作</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//执行我们试图测量的任何操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                    list.add(<span class="string">"anything"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Profiler profiler = <span class="keyword">new</span> Profiler(<span class="string">"ArrayListAddEnd"</span>,timeable);</span><br><span class="line">        <span class="keyword">int</span> startN = <span class="number">4000</span>;</span><br><span class="line">        <span class="keyword">int</span> endMils = <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//绘制图像(好像MATLAB)</span></span><br><span class="line">        XYSeries series = profiler.timingLoop(startN,endMils);</span><br><span class="line">        profiler.plotResults(series);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此方法测量在<code>ArrayList</code>上运行<code>add</code>所需的时间，它向末尾添加新元素</strong>。</p><blockquote><p>为了使用<code>Profiler</code>，我们需要创建一个<code>Timeable</code>，它提供两个方法：<code>setup</code>和<code>timeMe</code>。</p></blockquote><ul><li><code>setup</code>方法执行在<strong>启动计时之前所需的任何工作</strong>；这里它会创建一个空列表。</li><li>然后<code>timeMe</code><strong>执行我们试图测量的任何操作</strong>；这里它将<code>n</code>个元素添加到列表中。</li></ul><blockquote><p><code>Profiler</code>提供了<code>timingLoop</code>，它使用存储为实例变量的<code>Timeable</code>。它多次调用<code>Timeable</code>对象上的<code>timeMe</code>方法，使用一系列的<code>n</code>值。<code>timingLoop</code>接受两个参数：</p></blockquote><ul><li><code>startN</code>是<code>n</code>的值，计时循环应该从它开始。</li><li><code>endMillis</code>是以毫秒为单位的阈值。随着 <code>timingLoop</code>增加问题规模，运行时间增加；当运行时间超过此阈值时，<code>timingLoop</code>停止。</li></ul><p><strong>当你运行实验时，你可能需要调整这些参数。如果<code>startN</code>太低，运行时间可能太短，无法准确测量。如果<code>endMillis</code>太低，你可能无法获得足够的数据，来查看问题规模和运行时间之间的明确关系。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4000</span>, <span class="number">3</span></span><br><span class="line"><span class="number">8000</span>, <span class="number">0</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">1</span></span><br><span class="line"><span class="number">32000</span>, <span class="number">2</span></span><br><span class="line"><span class="number">64000</span>, <span class="number">3</span></span><br><span class="line"><span class="number">128000</span>, <span class="number">6</span></span><br><span class="line"><span class="number">256000</span>, <span class="number">18</span></span><br><span class="line"><span class="number">512000</span>, <span class="number">30</span></span><br><span class="line"><span class="number">1024000</span>, <span class="number">88</span></span><br><span class="line"><span class="number">2048000</span>, <span class="number">185</span></span><br><span class="line"><span class="number">4096000</span>, <span class="number">242</span></span><br><span class="line"><span class="number">8192000</span>, <span class="number">544</span></span><br><span class="line"><span class="number">16384000</span>, <span class="number">1325</span> （超过预定时间）</span><br></pre></td></tr></table></figure><p><strong>第一列是问题规模，<code>n</code>；第二列是以毫秒为单位的运行时间</strong>。前几个测量非常嘈杂；最好将<code>startN</code>设置在<code>64000</code>左右。（每次得出的结果不同，可具体分析，最后得出一张图，如图所示）</p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/4-1.jpg" alt=""><br><strong>结果分析：</strong></p><blockquote><p>基于我们对<code>ArrayList</code>工作方式的理解，我们期望，在添加元素到最后时，<code>add</code>方法需要常数时间。所以添加<code>n</code>个元素的<strong>总时间应该是线性</strong>的。</p><p>为了测试这个理论，我们可以绘制总运行时间和问题规模，我们应该看到一条直线，至少对于大到足以准确测量的问题规模。在数学上，我们可以为这条直线编写一个函数：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime = a + b * n</span><br></pre></td></tr></table></figure><p>其中<code>a</code>是线的截距，<code>b</code>是斜率。</p><p>另一方面，如果<code>add</code>是线性的，则<code>n</code>次添加的总时间将是平方。如果我们绘制运行时间与问题规模，我们预计会看到抛物线。或者在数学上，像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime = a + b * n + c * n^<span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于<code>n</code>的较大值，<strong>最大指数项是最重要的</strong>，因此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime ≈ c * n^k</span><br></pre></td></tr></table></figure><p>其中<code>≈</code>意思是“大致相等”。现在，如果我们对这个方程的两边取对数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(runtime) ≈ log(c) + k * log(n)</span><br></pre></td></tr></table></figure><p>这个方程式意味着，如果我们在重对数合度上绘制运行时间与<code>n</code>，我们预计看到一条直线，截距为<code>log(c)</code>，斜率为<code>k</code>。我们<strong>不太在意截距，但斜率表示增长级别</strong>：如果<code>k = 1</code>，算法是线性的；如果<code>k = 2</code>，则为平方的。</p><p>看上一节中的数字，你可以<strong>通过眼睛来估计斜率</strong>。但是当你调用<code>plotResults</code>它时，会计算数据的最小二乘拟合并打印估计的斜率。在这个例子中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Estimated slope &#x3D; 1.06194352346708(这个值是不一定的)</span><br></pre></td></tr></table></figure><p>它接近<code>1</code>；并且这表明<code>n</code>次添加的总时间是线性的，所以每个添加是常数时间，像预期的那样。</p><p>其中重要的一点：如果你在图形看到这样的直线，这并不意味着该算法是线性的。如果对于任何指数<code>k</code>，运行时间与<code>n ** k</code>成正比，我们预计看到斜率为<code>k</code>的直线。<strong>如果斜率接近<code>1</code>，则表明算法是线性的。如果接近<code>2</code>，它可能是平方的。</strong><br><br></p><h6 id="3-ArrayList的首部添加"><a href="#3-ArrayList的首部添加" class="headerlink" title="3.ArrayList的首部添加"></a>3.ArrayList的首部添加</h6><p><strong>预估：</strong></p><p>我们每次在ArrayList的首部进行添加，需要移动n个元素，执行n次，所以我们预估时间复杂度为O(n^2).斜率接近于2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileArrayListAddBeginning</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        List&lt;String&gt; list;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                list.add(<span class="number">0</span>,<span class="string">"anything"</span>);  <span class="comment">//使用双参方法，不断把最新的元素放到ArrayList首位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMillis = <span class="number">10000</span>;</span><br><span class="line">    runProfiler(<span class="string">"ArrayList add beginning"</span>, timeable, startN, endMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法几乎和<code>profileArrayListAddEnd</code>相同。<strong>唯一的区别在于<code>timeMe</code>，它使用<code>add</code>的双参数版本，将新元素置于下标<code>0</code>处</strong>。同样，我们增加了<code>endMillis</code>，来获取一个额外的数据点。</p><p>以下是时间结果（左侧是问题规模，右侧是运行时间，单位为毫秒）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4000</span>, <span class="number">14</span></span><br><span class="line"><span class="number">8000</span>, <span class="number">35</span></span><br><span class="line"><span class="number">16000</span>, <span class="number">150</span></span><br><span class="line"><span class="number">32000</span>, <span class="number">604</span></span><br><span class="line"><span class="number">64000</span>, <span class="number">2518</span></span><br><span class="line"><span class="number">128000</span>, <span class="number">11555</span></span><br></pre></td></tr></table></figure><p><strong>以下是运行时间和问题规模曲线:</strong></p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/5-1.jpg" alt=""></p><p><strong>分析结果：</strong></p><p>请记住，<strong>该图上的直线并不意味着该算法是线性的</strong>。相反，如果对于任何指数<code>k</code>，运行时间与<code>n ^ k</code>成正比，我们预计会看到斜率为<code>k</code>的直线。在这种情况下，我们预计，<code>n</code>次添加的总时间与<code>n ^ 2</code>成正比，所以我们预计会有一条斜率为<code>2</code>的直线。实际上，估计的斜率是<code>1.992</code>，非常接近。恐怕假数据才能做得这么好。(<strong>还是看斜率，与预期相符合</strong>)<br><br></p><h6 id="4-LInkedList的首部添加"><a href="#4-LInkedList的首部添加" class="headerlink" title="4.LInkedList的首部添加"></a>4.LInkedList的首部添加</h6><p><strong>预估：</strong></p><p>LinkedList首部添加不需要移动元素，操作时间复杂度为O(1),操作n次，预估时间复杂度为O(n^2)，预估他是线性的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileLinkedListAddBegining</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        List&lt;String&gt; list;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            list = <span class="keyword">new</span> LinkedList&lt;String&gt;(); <span class="comment">//这边初始化为LinkedList</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                list.add(<span class="number">0</span>,<span class="string">"lalalalala"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">128000</span>;  <span class="comment">//这些数值是慢慢测试出来的</span></span><br><span class="line">    <span class="keyword">int</span> endMils = <span class="number">2000</span>;</span><br><span class="line">    runProfiler(<span class="string">"LinkedList add beginning"</span>,timeable,startN,endMils);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果（有一点嘈杂这个结果）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">128000</span>, <span class="number">16</span></span><br><span class="line"><span class="number">256000</span>, <span class="number">19</span></span><br><span class="line"><span class="number">512000</span>, <span class="number">28</span></span><br><span class="line"><span class="number">1024000</span>, <span class="number">77</span></span><br><span class="line"><span class="number">2048000</span>, <span class="number">330</span></span><br><span class="line"><span class="number">4096000</span>, <span class="number">892</span></span><br><span class="line"><span class="number">8192000</span>, <span class="number">1047</span></span><br><span class="line"><span class="number">16384000</span>, <span class="number">4755</span></span><br></pre></td></tr></table></figure><p><strong>以下是运行时间和问题规模曲线:</strong></p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/5-2.jpg" alt=""></p><p><strong>结果分析：</strong></p><p>并不是一条很直的线，斜率也不是正好是<code>1</code>，最小二乘拟合的斜率是<code>1.23</code>。但是结果表示，<code>n</code>次添加的总时间至少近似于<code>O(n)</code>，所以<strong>每次添加都是常数时间</strong>。<br></p><h6 id="5-LinkedList的尾部添加"><a href="#5-LinkedList的尾部添加" class="headerlink" title="5.LinkedList的尾部添加"></a>5.LinkedList的尾部添加</h6><p><strong>预估：</strong></p><p>LinkedList的尾部添加，需要逐个便利，操作是线性的，为O(n)，操作n次,时间复杂度为O(n^2).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">profileLinkedListAddEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Profiler.Timeable timeable = <span class="keyword">new</span> Profiler.Timeable() &#123;</span><br><span class="line">        List&lt;String&gt; list;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeMe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">                list.add(<span class="string">"CN DOTA BEST DOTA"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> startN = <span class="number">64000</span>;</span><br><span class="line">    <span class="keyword">int</span> endMils = <span class="number">1000</span>;</span><br><span class="line">    runProfiler(<span class="string">"LinkedListAddEnd"</span>,timeable,startN,endMils);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64000</span>, <span class="number">9</span></span><br><span class="line"><span class="number">128000</span>, <span class="number">9</span></span><br><span class="line"><span class="number">256000</span>, <span class="number">21</span></span><br><span class="line"><span class="number">512000</span>, <span class="number">24</span></span><br><span class="line"><span class="number">1024000</span>, <span class="number">78</span></span><br><span class="line"><span class="number">2048000</span>, <span class="number">235</span></span><br><span class="line"><span class="number">4096000</span>, <span class="number">851</span></span><br><span class="line"><span class="number">8192000</span>, <span class="number">950</span></span><br><span class="line"><span class="number">16384000</span>, <span class="number">6160</span></span><br></pre></td></tr></table></figure><p><strong>以下是运行时间和问题规模曲线：</strong></p><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/5-3.jpg" alt=""></p><p><strong>结果分析：</strong></p><p>同样，测量值很嘈杂，线不完全是直的，但估计的斜率为<code>1.19</code>，接近于在头部添加元素，而并不非常接近<code>2</code>，这是我们根据分析的预期。事实上，它接近<code>1</code>，这表明在尾部添加元素是常数元素。(思考一个问题，它的问题规模为什么这么大，大概有0.2的偏差，经验证，问题规模在400w的时候会有一个明显的下降)<br><br><br></p><p>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/5.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/5.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> 性能分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（四）LinkedList</title>
      <link href="/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89LinkedList/"/>
      <url>/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89LinkedList/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-链式数据结构"><a href="#1-链式数据结构" class="headerlink" title="1.链式数据结构"></a>1.链式数据结构</h6><blockquote><p>在链表中，每个节点包含列表中下一个节点的引用. 其它的链表结构包括树和图，其中节点可以包含多个其它节点的引用。</p></blockquote><br><p>简单的节点Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object node;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init Node</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//usually use as the head</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(Object node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//normal node</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(Object node, ListNode next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ListNode&#123;"</span> + <span class="string">"node="</span> + node + <span class="string">", next="</span> + next + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ListNode</code>提供了几个构造函数，可以让你为<code>data</code>和<code>next</code>提供值，或将它们初始化为默认值，<code>null</code>.</p></blockquote><br><p>创造一个链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">ListNode node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.next = node3;</span><br><span class="line">node3.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ListNode node0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>,node1);</span><br></pre></td></tr></table></figure><p><img src="https://wizardforcel.gitbooks.io/think-dast/content/img/3-1.jpg" alt=""></p><br><h6 id="2-LinkedList初始化结构"><a href="#2-LinkedList初始化结构" class="headerlink" title="2.LinkedList初始化结构"></a>2.LinkedList初始化结构</h6><p>构造内嵌函数Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内嵌函数（Nested Function set the Node）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E data;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><p>初始化结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;            <span class="comment">// keeps track of the number of elements</span></span><br><span class="line">    <span class="keyword">private</span> Node head;           <span class="comment">// reference to the first node</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>存储元素数量不是必需的，并且一般来说，保留冗余信息是有风险的，因为如果没有正确更新，就有机会产生错误。它还需要一点点额外的空间。</p></blockquote><blockquote><p>但是如果我们显式存储<code>size</code>，我们可以实现常数时间的<code>size</code>方法；否则，我们必须遍历列表并对元素进行计数，这需要线性时间。</p></blockquote><blockquote><p>因为我们显式存储<code>size</code>明确地存储，每次添加或删除一个元素时，我们都要更新它，这样一来，这些方法就会减慢，但是它不会改变它们的增长级别，所以很值得。</p></blockquote><br><h6 id="3-LinkedList方法划分"><a href="#3-LinkedList方法划分" class="headerlink" title="3.LinkedList方法划分"></a>3.LinkedList方法划分</h6><p>Add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">( E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span> (; node.next != <span class="keyword">null</span>; node = node.next) &#123;&#125;      <span class="comment">//loop until the next one</span></span><br><span class="line">        node.next = <span class="keyword">new</span> Node(element);</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>indexOf方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       Node node = head;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> ( equals(target,node.data) ) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">           node = node.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么这种方法的增长级别是什么？</p><ul><li>每次在循环中，我们调用了<code>equals</code>，这是一个常数时间（它可能取决于<code>target</code>或<code>data</code>大小，但不取决于列表的大小）。循环中的其他操作也是常数时间。</li><li>循环可能运行<code>n</code>次，因为在更糟的情况下，我们可能必须遍历整个列表。</li></ul><p>所以这个方法的运行时间与列表的长度成正比(换言之，是线性的)。</p></blockquote><br><p>Add双参方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">           Node node = <span class="keyword">new</span> Node(element);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Node node = getNode(index-<span class="number">1</span>);</span><br><span class="line">           node.next = <span class="keyword">new</span> Node(element,node.next);</span><br><span class="line">       &#125;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index&gt;=size) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">       &#125;</span><br><span class="line">       Node node = head;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; i++) &#123;</span><br><span class="line">           node = node.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>getNode</code>类似<code>indexOf</code>，出于同样的原因也是线性的。</li><li>在<code>add</code>中，<code>getNode</code>前后的一切都是常数时间。</li></ul><p>所以放在一起，<code>add</code>是线性的。</p></blockquote><br><p>Remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       E element = get(index);</span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Node node = getNode(index-<span class="number">1</span>);</span><br><span class="line">           node.next = node.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       size--;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>remove</code>使用了<code>get</code>查找和存储<code>index</code>处的元素。然后它删除包含它的<code>Node</code>。</p><p>如果<code>index==0</code>，我们再次处理这个特殊情况。否则我们找到节点<code>index-1</code>(这个真的是心机，得防止它漏过)并进行修改，来跳过<code>node.next</code>并直接链接到<code>node.next.next</code>。这有效地从列表中删除<code>node.next</code>，它可以被垃圾回收。</p><p>当人们看到两个线性操作时，他们有时会认为结果是平方的，但是只有一个操作嵌套在另一个操作中才适用。如果你在一个操作之后调用另一个，运行时间会相加。如果它们都是<code>O(n)</code>的，则总和也是<code>O(n)</code>的。</p><p>所以Remove()是线性的</p></blockquote><br><h6 id="4-ArrayList和LinkedList的对比"><a href="#4-ArrayList和LinkedList的对比" class="headerlink" title="4.ArrayList和LinkedList的对比"></a>4.ArrayList和LinkedList的对比</h6><table><thead><tr><th></th><th align="center"><strong>MyArrayList</strong></th><th align="center"><strong>MyLinkedList</strong></th></tr></thead><tbody><tr><td><code>add</code>（末尾）</td><td align="center">1</td><td align="center">n</td></tr><tr><td><code>add</code>（开头）</td><td align="center">n(剩余的都往后)</td><td align="center">1</td></tr><tr><td><code>add</code>（一般）</td><td align="center">n</td><td align="center">n</td></tr><tr><td><code>get</code> / <code>set</code></td><td align="center">1</td><td align="center">n</td></tr><tr><td><code>indexOf</code> / <code>lastIndexOf</code></td><td align="center">n</td><td align="center">n</td></tr><tr><td><code>isEmpty</code> / <code>size</code></td><td align="center">1</td><td align="center">1</td></tr><tr><td><code>remove</code>（末尾）</td><td align="center">1</td><td align="center">n</td></tr><tr><td><code>remove</code>（开头）</td><td align="center">n</td><td align="center">1</td></tr><tr><td><code>remove</code>（一般）</td><td align="center">n</td><td align="center">n</td></tr></tbody></table><ul><li><code>MyArrayList</code>的优势操作是，<strong>插入末尾，移除末尾，获取和设置</strong>。</li><li><code>MyLinkedList</code>的优势操作是，插入开头，以及移动开头。（<strong>链式结构头容易获取</strong>）<br>要用哪种看具体的需求<br><br><br></li></ul><p>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/5.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/5.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（三）ArrayList</title>
      <link href="/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89ArrayList/"/>
      <url>/blog/2019/04/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89ArrayList/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-Add方法"><a href="#1-Add方法" class="headerlink" title="1.Add方法"></a>1.Add方法</h6><p>单参方法(分析它的时间复杂度)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean add(T element) &#123;</span><br><span class="line">        <span class="comment">//make a bigger array and copy over the elements</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">            T[] bigger = <span class="keyword">new</span> <span class="built_in">Object</span>[array.length * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(array,<span class="number">0</span>,bigger,<span class="number">0</span>,array.length);</span><br><span class="line">            array = bigger;</span><br><span class="line">        &#125;</span><br><span class="line">        array[size] = element;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>单参数版本很难分析。如果数组中存在<strong>未使用的空间，那么它是常数时间</strong>，但如果我们必须<strong>调整数组的大小，它是线性的</strong>，因为<code>System.arraycopy</code>所需的时间与数组的大小成正比.（既存在常数时间，又是线性的）</p></blockquote><blockquote><p>那么<code>add</code>是常数还是线性时间的？（先给结论，可以看作是常数的）</p></blockquote><ul><li>我们第一次调用<code>add</code>时，它会在数组中找到未使用的空间，所以它存储<code>1</code>个元素。</li><li>第二次，它在数组中找到未使用的空间，所以它存储<code>1</code>个元素。</li><li>第三次，我们必须调整数组的大小，复制<code>2</code>个元素，并存储<code>1</code>个元素。现在数组的大小是<code>4</code>。</li><li>第四次存储<code>1</code>个元素。</li><li>第五次调整数组的大小，复制<code>4</code>个元素，并存储<code>1</code>个元素。现在数组的大小是<code>8</code>。</li><li>接下来的<code>3</code>个添加储存<code>3</code>个元素。</li><li>下一个添加复制<code>8</code>个并存储<code>1</code>个。现在的大小是<code>16</code>。</li><li>接下来的<code>7</code>个添加复制了<code>7</code>个元素。</li></ul><blockquote><p>整理一下规律</p></blockquote><ul><li><code>4</code>次添加之后，我们储存了<code>4</code>个元素，并复制了两个。</li><li><code>8</code>次添加之后，我们储存了<code>8</code>个元素，并复制了<code>6</code>个。</li><li><code>16</code>次添加之后，我们储存了<code>16</code>个元素，并复制了<code>14</code>个。</li></ul><blockquote><p>现在你应该看到了规律：要执行<code>n</code>次添加，我们必须存储<code>n</code>个元素并复制<code>n-2</code>个。所以操作总数为<code>n + n - 2</code>，为<code>2 * n - 2</code></p><p>为了得到每个添加的平均操作次数，我们将总和除以<code>n</code>；结果是<code>2 - 2 / n</code>。随着<code>n</code>变大，第二项<code>2 / n</code>变小。参考我们只关心<code>n</code>的最大指数的原则，我们可以认为<code>add</code>是常数时间的</p></blockquote><blockquote><p>有时线性的算法平均可能是常数时间，这似乎是奇怪的。关键是我们每次调整大小时都加倍了数组的长度。这限制了每个元素被复制的次数。否则 - 如果我们向数组的长度添加一个固定的数量，而不是乘以一个固定的数量 - 分析就不起作用。</p></blockquote><blockquote><p>这种划分算法的方式，通过计算一系列调用中的平均时间，称为摊销分析。你可以在 <a href="http://thinkdast.com/amort" target="_blank" rel="noopener">http://thinkdast.com/amort</a> 上阅读更多信息。重要的想法是，<strong>复制数组的额外成本是通过一系列调用展开或“摊销”的。</strong><br></p></blockquote><br><p>双参方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public <span class="keyword">void</span> add(int index, T element) &#123;</span><br><span class="line">     <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index&gt;size) &#123;</span><br><span class="line">         <span class="keyword">throw</span> IndexOutOfBoundsException;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//new element（扩容之需）</span></span><br><span class="line">     add(element);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//shift the other element</span></span><br><span class="line">     <span class="keyword">for</span> (int i=size<span class="number">-1</span>; i&gt;index; i--) &#123;</span><br><span class="line">         array[i] = array[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//put the new one in the right place</span></span><br><span class="line">     array[index] = element;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个双参数的版本，叫做<code>add(int, E)</code>，它使用了单参数的版本，称为<code>add(E)</code>，它将新的元素放在最后。然后它将其他元素向右移动，并将新元素放在正确的位置</p></blockquote><blockquote><p>现在，如果<code>add(E)</code>是常数时间，那么<code>add(int, E)</code>呢？调用<code>add(E)</code>后，它遍历数组的一部分并移动元素。这个循环是线性的，除了在列表末尾添加的特殊情况中。<strong>因此， <code>add(int, E)</code>是线性的</strong>。<br></p></blockquote><h6 id="2-划分MyArrayList的方法"><a href="#2-划分MyArrayList的方法" class="headerlink" title="2.划分MyArrayList的方法"></a>2.划分MyArrayList的方法</h6><blockquote><p>对于许多方法，我们不能通过测试代码来确定增长级别<br></p></blockquote><p><strong>常数级别</strong></p><blockquote><p><code>get</code>中的每个东西都是常数时间的。所以<code>get</code>是常数时间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>set</code>中的一切，包括<code>get</code>的调用都是常数时间，所以<code>set</code>也是常数时间</p><p>set它不会显式检查数组的边界；它利用<code>get</code>，如果索引无效则引发异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    E old = get(index);</span><br><span class="line">    array[index] = element;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>线性级别</strong></p><blockquote><p>每次在循环中，<code>indexOf</code>调用<code>equals</code>，所以我们首先要划分<code>equals</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equals(target, array[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>equals方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object target, Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> element == <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target.equals(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们幸运，我们可能会立即找到目标对象，并在测试一个元素后返回。如果我们不幸，我们可能需要测试所有的元素。平均来说，我们预计测试一半的元素，所以这种方法被认为是<strong>线性</strong>的（除了在不太可能的情况下，我们知道目标元素在数组的开头）<br></p></blockquote><h6 id="3-问题规模"><a href="#3-问题规模" class="headerlink" title="3.问题规模"></a>3.问题规模</h6><p><strong>RemoveAll</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object obj: collection) &#123;</span><br><span class="line">        flag &amp;= remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每次循环中，<code>removeAll</code>都调用<code>remove</code>，这是线性的。所以认为<code>removeAll</code>是二次的很诱人。但事实并非如此。</p></blockquote><blockquote><p>在这种方法中，循环对于每个<code>collection</code>中的元素运行一次。如果<code>collection</code>包含<code>m</code>个元素，并且我们从包含<code>n</code>个元素的列表中删除，则此方法是<code>O(nm)</code>的。如果<code>collection</code>的大小可以认为是常数，<code>removeAll</code>相对于<code>n</code>是线性的。但是，如果集合的大小与<code>n</code>成正比，<code>removeAll</code>则是平方的。例如，如果<code>collection</code>总是包含<code>100</code>个或更少的元素， <code>removeAll</code>则是线性的。但是，如果<code>collection</code>通常包含的列表中的 1% 元素，<code>removeAll</code>则是平方的。</p></blockquote><blockquote><p><strong>当我们谈论问题规模时，我们必须小心我们正在讨论哪个大小</strong>。这个例子演示了算法分析的陷阱：对循环计数的诱人捷径。如果有一个循环，算法往往是 线性的。如果有两个循环（一个嵌套在另一个内），则该算法通常是平方的。不过要小心！<strong>你必须考虑每个循环运行多少次</strong>。如果所有循环的迭代次数与<code>n</code>成正比，你可以仅仅对循环进行计数之后离开。但是，如在这个例子中，<strong>迭代次数并不总是与<code>n</code>成正比</strong>，所以你必须考虑更多。</p></blockquote><br><p>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/5.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/5.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（二） 算法分析</title>
      <link href="/blog/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-简单算法分类"><a href="#1-简单算法分类" class="headerlink" title="1.简单算法分类"></a>1.简单算法分类</h6><ul><li>常数时间<strong>O(1)</strong>：不依赖于输入</li><li>线性<strong>O(n)</strong>:依赖于输入，并跟输入量大小成正比</li><li>平方<strong>O(n^2 )</strong>:随着n的增长变为n^2</li></ul><h6 id="2-简单排序"><a href="#2-简单排序" class="headerlink" title="2.简单排序"></a>2.简单排序</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Swaps the elements at indexes i and j.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> swapElements(int[] array, int i, int j) &#123;</span><br><span class="line">        int temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Finds the index of the lowest value</span></span><br><span class="line"><span class="comment">     * starting from the index at start (inclusive)</span></span><br><span class="line"><span class="comment">     * and going to the end of the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> int indexLowest(int[] array, int start) &#123;</span><br><span class="line">        int lowIndex = start;</span><br><span class="line">        <span class="keyword">for</span> (int i = start; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[lowIndex]) &#123;</span><br><span class="line">                lowIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sorts the elements (in place) using selection sort.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> selectionSort(int[] array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            int j = indexLowest(array, i);</span><br><span class="line">            swapElements(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap()是常数级操作，时间恒定<br>indexLowest()复杂度，同n-start有关，属于线性关系<br>selectionSort()，需要算n(n-1)/2,属于平方关系<br><br><br></p><p>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/1.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/1.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构思维笔记（一）接口</title>
      <link href="/blog/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%A5%E5%8F%A3/"/>
      <url>/blog/2019/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h6 id="1-为什么要有两种List"><a href="#1-为什么要有两种List" class="headerlink" title="1.为什么要有两种List"></a>1.为什么要有两种List</h6><blockquote><p>Java中List接口为ArrayList, LinkedList都继承于List.哪一个更适合于特定的应用程序，取决于它最常执行的操作.对于一些应用，<code>LinkedList</code>更快；对于其他应用，<code>ArrayList</code>更快.<br></p></blockquote><h6 id="2-List接口"><a href="#2-List接口" class="headerlink" title="2.List接口"></a>2.List接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClientExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListClientExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListClientExample lce = <span class="keyword">new</span> ListClientExample();</span><br><span class="line">        List list = lce.getList();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>ListClientExample</code>没有任何有用的东西，但它封装了<code>List</code>，并具有一个类的基本要素。也就是说，它包含一个<code>List</code>实例变量。<br> <strong>通过实例化（也就是创建）新的<code>LinkedList</code>，这个<code>ListClientExample</code>构造函数初始化<code>list</code>；读取器方法叫做<code>getList</code>，返回内部<code>List</code>对象的引用；并且<code>main</code>包含几行代码来测试这些方法。</strong></p><p>这个例子的要点是，它尽可能地使用<code>List</code>，避免指定<code>LinkedList</code>，<code>ArrayList</code>，除非有必要。例如，实例变量被声明为<code>List</code>，并且<code>getList</code>返回<code>List</code>，但都不指定哪种类型的列表。<br>如果你改变主意并决定使用<code>ArrayList</code>，你只需要改变构造函数; 你不必进行任何其他更改。<br>这种风格被称为<strong>基于接口的编程</strong>，或者更随意，“面向接口编程”。这里我们谈论接口的一般思想，而不是 Java 接口。<br><br></p><p>原书链接：<a href="https://wizardforcel.gitbooks.io/think-dast/content/5.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/think-dast/content/5.html</a><br>GitHub链接(提供源码)：<a href="https://github.com/huoji555/Shadow/tree/master/DataStructure" target="_blank" rel="noopener">https://github.com/huoji555/Shadow/tree/master/DataStructure</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构思维 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现课程推荐算法</title>
      <link href="/blog/2019/04/09/Java%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/04/09/Java%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h4><p>现在有课程若干，需要在用户打开客户端时，推荐给用户相关内容。具体推荐规则如下:</p><blockquote><ul><li>有3个以上4分以上的：“基于您的个人能力测试，发现您的【xxx、xxx、xxx】很强”；<br>   a)    Xxx: 为能力，随机选3个最高值。<br>比如：您的基于您的个人能力测试，发现您“语言能力、英语能力、逻辑能力”能力很强</li><li>¬    有4分以上的：“基于您的个人能力测试，发现您的【xxx、xxx、xxx】比较不错”；<br>   a)    Xxx: 为能力，随机选3个最高值。</li><li>¬    没有4分以上的，3分及以下，提示能力最高的3个；同样分值，随机取几个，凑个3个能力：<br>   a)    基于您的个人能力测试，发现您的【xxx、xxx 】能力比较均衡.；<br>比如：您的基于您的个人能力测试，发现您“语言能力、英语能力、逻辑能力”能力均衡</li></ul></blockquote><br><h4 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h4><p>设计思路其实很简单，我们需要把获取到的分数降序排序，如果相同就随机推荐相同分值的科目。</p><p>因为是K-V值关系的数据关系，所以可以选择用Map，用到排序，选用Map中的TreeMap，自己定义排序规则，需手写Compare方法。<br><br></p><h4 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3.具体代码"></a>3.具体代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        Integer finalSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> math = <span class="number">4.2</span>;</span><br><span class="line">        <span class="keyword">double</span> chinese = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> english = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> computer = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> design = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> practice = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"数学能力"</span>,math);</span><br><span class="line">        map.put(<span class="string">"语言能力"</span>,chinese);</span><br><span class="line">        map.put(<span class="string">"英文能力"</span>,english);</span><br><span class="line">        map.put(<span class="string">"逻辑能力"</span>,computer);</span><br><span class="line">        map.put(<span class="string">"设计能力"</span>,design);</span><br><span class="line">        map.put(<span class="string">"体育能力"</span>,practice);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Double&gt; good = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line">        Map&lt;String,Double&gt; normal = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line">        Map&lt;String,Double&gt; bad = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            Double score =  (Double) entry.getValue();</span><br><span class="line">            String classes = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (score &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                good.put(classes,score);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">3</span> &amp;&amp; score&lt;<span class="number">4</span>) &#123;</span><br><span class="line">                normal.put(classes,score);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bad.put(classes,score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Double&gt; map1 = <span class="keyword">new</span> TreeMap&lt;String, Double&gt;(<span class="keyword">new</span> MapValueComparator&lt;Double&gt;(good));</span><br><span class="line">        Map&lt;String, Double&gt; map2 = <span class="keyword">new</span> TreeMap&lt;String, Double&gt;(<span class="keyword">new</span> MapValueComparator&lt;Double&gt;(normal));</span><br><span class="line">        Map&lt;String, Double&gt; map3 = <span class="keyword">new</span> TreeMap&lt;String, Double&gt;(<span class="keyword">new</span> MapValueComparator&lt;Double&gt;(bad));</span><br><span class="line">        map1.putAll(good);</span><br><span class="line">        map2.putAll(normal);</span><br><span class="line">        map3.putAll(bad);</span><br><span class="line"></span><br><span class="line">        String[] keys = map1.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        String[] keys1 = map2.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        String[] keys2 = map3.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">"测试前:"</span>+map.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (good.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys,result,finalSize)+<span class="string">"】能力很强"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (good.size()&gt;<span class="number">0</span> &amp;&amp; (normal.size()+good.size()&gt;=<span class="number">3</span> || bad.size()+good.size()&gt;=<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String xx : keys) &#123;  result += (result == <span class="string">""</span> || result == <span class="keyword">null</span>) ? xx : <span class="string">","</span>+xx;&#125;</span><br><span class="line">            finalSize -= keys.length;</span><br><span class="line">            <span class="keyword">if</span> (normal.size()+good.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys1,result,finalSize)+<span class="string">"】比较不错"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bad.size()+good.size() &gt;= <span class="number">3</span> &amp;&amp;  normal.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys2,result,finalSize)+<span class="string">"】比较不错"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String xx : keys1) &#123;  result += (result == <span class="string">""</span> || result == <span class="keyword">null</span>) ? xx : <span class="string">","</span>+xx;&#125;</span><br><span class="line">                finalSize -= keys1.length;</span><br><span class="line">                System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys2,result,finalSize)+<span class="string">"】比较不错"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (keys1.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys1,result,finalSize)+<span class="string">"】比较均衡"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String xx : keys1) &#123;  result += (result == <span class="string">""</span> || result == <span class="keyword">null</span>) ? xx : <span class="string">","</span>+xx;&#125;</span><br><span class="line">                finalSize -= keys1.length;</span><br><span class="line">                System.out.println(<span class="string">"基于您的个人能力测试，发现您的【"</span>+Random(keys2,result,finalSize)+<span class="string">"】比较均衡"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  随机科目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 11:07 2019/4/8</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Random</span><span class="params">(String[] keys,String result,Integer finalSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;finalSize; i++) &#123;</span><br><span class="line">            result += (result == <span class="string">""</span> || result == <span class="keyword">null</span>) ? keys[i] : <span class="string">","</span>+keys[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  比较器（按值排序,相同的随机取值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 10:38 2019/4/9</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapValueComparator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, T&gt; map = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MapValueComparator</span><span class="params">(Map&lt;String, T&gt; map)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.map = map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r = map.get(o2).compareTo(map.get(o1));</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> randomOne = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> randomTwo = (<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> randomOne - randomTwo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="4-测试结果-多组结果"><a href="#4-测试结果-多组结果" class="headerlink" title="4.测试结果(多组结果)"></a>4.测试结果(多组结果)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">测试前:&#123;语言能力=<span class="number">4.2</span>, 设计能力=<span class="number">3.0</span>, 英文能力=<span class="number">2.0</span>, 数学能力=<span class="number">3.0</span>, 逻辑能力=<span class="number">3.0</span>, 体育能力=<span class="number">1.0</span>&#125;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">基于您的个人能力测试，发现您的【语言能力,数学能力,设计能力】比较不错</span><br><span class="line"></span><br><span class="line">测试前:&#123;语言能力=<span class="number">4.2</span>, 设计能力=<span class="number">3.0</span>, 英文能力=<span class="number">2.0</span>, 数学能力=<span class="number">3.0</span>, 逻辑能力=<span class="number">3.0</span>, 体育能力=<span class="number">1.0</span>&#125;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">基于您的个人能力测试，发现您的【语言能力,逻辑能力,设计能力】比较不错</span><br><span class="line"></span><br><span class="line">测试前:&#123;语言能力=<span class="number">4.2</span>, 设计能力=<span class="number">3.0</span>, 英文能力=<span class="number">2.0</span>, 数学能力=<span class="number">3.0</span>, 逻辑能力=<span class="number">3.0</span>, 体育能力=<span class="number">1.0</span>&#125;</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">基于您的个人能力测试，发现您的【语言能力,数学能力,逻辑能力】比较不错</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
            <tag> Java推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql存储过程</title>
      <link href="/blog/2019/03/28/MySql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/blog/2019/03/28/MySql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h4 id="1-存储过程概念"><a href="#1-存储过程概念" class="headerlink" title="1.存储过程概念"></a>1.存储过程概念</h4><p>存储过程是<strong>一组为了完成特定功能的SQL语句集</strong>，经编译后存储在数据库中。用户通过指定存储过程的名字并给出参数(如果该存储过程带有参数)来执行它。存储过程可由应用程序通过一个调用来执行，而且允许用户声明变量 。同时，存储过程可以接收和输出参数、返回执行存储过程的状态值，也可以嵌套调用。(<strong>相当于一个函数</strong>)<br></p><h4 id="2-存储过程与函数的区别"><a href="#2-存储过程与函数的区别" class="headerlink" title="2.存储过程与函数的区别"></a>2.存储过程与函数的区别</h4><p>函数往往作为<strong>公式</strong>使用，存储过程作为<strong>完成某种功能使用</strong>。</p><p>函数分为<strong>表值函数(通过sql返回一张表)</strong>跟<strong>标量函数(通过sql返回一个值)</strong>。</p><p>函数可以在select语句中直接使用，而过程不能。<br></p><h4 id="3-存储过程优点"><a href="#3-存储过程优点" class="headerlink" title="3.存储过程优点"></a>3.存储过程优点</h4><ul><li><strong>减少网络通信量</strong>。调用一个行数不多的存储过程与直接调用SQL语句的网络通信量可能不会有很大的差别，可是如果存储过程包含上百行SQL语句，那么其性能绝对比一条一条的调用SQL语句要高得多。</li><li><strong>执行速度更快</strong>。存储过程创建的时候，数据库已经对其进行了一次解析和优化。其次，存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接中读取。</li><li><strong>更强的安全性</strong>。存储过程是通过向用户授予权限(而不是基于表)，它们可以提供对特定数据的访问，提高代码安全，比如防止 SQL注入。</li><li><strong>业务逻辑可以封装存储过程中</strong>，这样不仅容易维护，而且执行效率也高<br></li></ul><h4 id="4-存储过程缺点"><a href="#4-存储过程缺点" class="headerlink" title="4.存储过程缺点"></a>4.存储过程缺点</h4><ul><li><strong>可移植性方面</strong>：当从一种数据库迁移到另外一种数据库时，不少的存储过程的编写要进行部分修改</li><li><strong>存储过程需要花费一定的学习时间去学习</strong>，比如学习其语法等</li></ul><h4 id="5-存储过程的编写"><a href="#5-存储过程的编写" class="headerlink" title="5.存储过程的编写"></a>5.存储过程的编写</h4><h6 id="定义存储过程的结束符"><a href="#定义存储过程的结束符" class="headerlink" title="定义存储过程的结束符"></a>定义存储过程的结束符</h6><blockquote><p>sql中我们用;隔开结尾，存储过程中我们用 <strong>DELIMITER //</strong>定义分隔符，//为自定义的分隔符<br></p></blockquote><h6 id="如何创建存储过程"><a href="#如何创建存储过程" class="headerlink" title="如何创建存储过程"></a>如何创建存储过程</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATEPROCEDURE &#96;p2&#96; ()</span><br><span class="line">LANGUAGE SQL</span><br><span class="line">DETERMINISTIC</span><br><span class="line">SQL SECURITY DEFINER</span><br><span class="line">COMMENT &#39;A procedure&#39;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT&#39;Hello World !&#39;;</span><br><span class="line">END&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><strong>CREATE PROCEDURE</strong>+<strong>存储过程名的方法</strong>创建存储过程</p><p><strong>LANGUAGE</strong>选项指定了使用的语言，这里默认是使用SQL。</p><p><strong>DETERMINISTIC</strong>，声明它是否为确定型函数（输入一的结果肯定为2），默认为不确定型。</p><p><strong>SQL SECURITY</strong>，是表示调用时检查用户的权限。当值为INVOKER时，表示是用户调用该存储过程时检查，默认为DEFINER,即创建存储过程时检查。</p><p><strong>COMMENT</strong>部分是存储过程的注释说明部分。</p><p><strong>BEGIN    END</strong>部分中，是存储过程的主体部分。<br></p><h6 id="调用存储过程的方法"><a href="#调用存储过程的方法" class="headerlink" title="调用存储过程的方法"></a>调用存储过程的方法</h6><p>使用call命令，后边跟调用存储过程的名称及输入的变量列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL stored_procedure_name (param1, param2, ....)</span><br><span class="line">CALL procedure1(10 , &#39;string parameter&#39; , @parameter_var);</span><br></pre></td></tr></table></figure><br><h6 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h6><p><strong>修改：</strong>ALTER的语法去修改存储过程的主要特征和参数，</p><p>​       要修改其存储过程的主体部分的话，必须要先删除然后再重建</p><p>e.g：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER PROCEDURE num_from&#x2F;&#x2F;修改存储过程的定义，将读写权限改为 MODIFIES SQL DATA</span><br><span class="line">MODIFIES SQL DATA SQL SECURITY INVOKER ;   &#x2F;&#x2F;并指明调用者可执行</span><br></pre></td></tr></table></figure><p><strong>删除：</strong>使用DROP关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS p2;</span><br></pre></td></tr></table></figure><h6 id="存储过程的参数"><a href="#存储过程的参数" class="headerlink" title="存储过程的参数"></a>存储过程的参数</h6><ul><li><p>CREATE PROCEDURE proc1 () 这个存储过程中是空的参数列表</p></li><li><p>CREATE PROCEDURE proc1 (<strong>IN varname DATA-TYPE</strong>) 这个存储过程中有一个输出参数，名称为varname，后面是跟数据类型DATA-TYPE,<strong>IN参数是默认的</strong>，因此可以省略不写</p></li><li><p>CREATE PROCEDURE proc1 (<strong>OUT varname DATA-TYPE</strong>) 这个存储过程中varname为输出参数</p></li><li><p>CREATE PROCEDURE proc1 (<strong>INOUT varname DATA-TYPE</strong>) 这个存储过程中，varname既是输入参数也是输出参数</p></li></ul><p><strong>IN输入参数的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_IN&#96; (IN var1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT var1 + 2 AS result;</span><br><span class="line">END&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><strong>OUT输入参数的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DeLIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_OUT&#96;(OUT var1 varchar(100))</span><br><span class="line">BEGIN</span><br><span class="line">    SET var1 &#x3D; &#39;This is the test!&#39;;</span><br><span class="line">END&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><strong>IN-OUT的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_IN_OUT&#96;(OUT var1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">   SET var1 &#x3D; var1+2;</span><br><span class="line">END&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><h6 id="存储过程定义变量"><a href="#存储过程定义变量" class="headerlink" title="存储过程定义变量"></a>存储过程定义变量</h6><blockquote><p>必须显式地在存储过程的一开始声明变量，并指出它们的数据类型，一但声明了变量后，就可以在存储过程中使用</p></blockquote><p><code>DECLARE varname DATA-TYPE DEFAULT defaultvalue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE a, b INT DEFAULT 5;</span><br><span class="line">DECLARE str VARCHAR(50);</span><br><span class="line">DECLARE today TIMESTAMP DEFAULT CURRENT_DATE;</span><br><span class="line">DECLARE v1, v2, v3 TINYINT;</span><br></pre></td></tr></table></figure><p>调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;var_proc&#96; (IN paramstr VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE a, b INT DEFAULT 5;</span><br><span class="line">　　DECLARE str VARCHAR(50);</span><br><span class="line">　　DECLARE today TIMESTAMP DEFAULT CURRENT_DATE;</span><br><span class="line">　　DECLARE v1, v2, v3 TINYINT;</span><br><span class="line">　　INSERT INTO table1 VALUES (a);</span><br><span class="line">　　SET str &#x3D; &#39;I am a string&#39;;</span><br><span class="line">　　SELECT CONCAT(str,paramstr), today FROM table2 WHERE b&gt;&#x3D;5;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><h4 id="6-存储过程的语法结构"><a href="#6-存储过程的语法结构" class="headerlink" title="6.存储过程的语法结构"></a><strong>6.存储过程的语法结构</strong></h4><blockquote><p>MYSQL存储过程中支持IF，CASE，ITERATE，LEAVE LOOP，WHILE和REPEAT等语法结构和语句<br></p></blockquote><p><strong>IF语句</strong>（if语句使用的是if…then end if的语法结构）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_IF&#96; (IN param1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE variable1 INT;</span><br><span class="line">　　SET variable1 &#x3D; param1 + 1;</span><br><span class="line">　　IF variable1 &#x3D; 0 THEN</span><br><span class="line">　　    SELECT variable1;</span><br><span class="line">　　END IF;</span><br><span class="line">　　IF param1 &#x3D; 0 THEN</span><br><span class="line">　　    SELECT &#39;Parameter value &#x3D; 0&#39;;</span><br><span class="line">　　ELSE</span><br><span class="line">　　    SELECT &#39;Parameter value &lt;&#x3D; 0&#39;;</span><br><span class="line">　　END IF;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><p><strong>CASE语句</strong>（当有很多IF语句时，就应该考虑使用CASE语句了，它是多分支选择语句）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_CASE&#96; (IN param1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE variable1 INT;</span><br><span class="line">　　SET variable1 &#x3D; param1 + 1;</span><br><span class="line">　　CASE variable1</span><br><span class="line">　　WHEN 0 THEN</span><br><span class="line">　　    INSERT INTO table1 VALUES (param1);</span><br><span class="line">　　WHEN 1 THEN</span><br><span class="line">　　    INSERT INTO table1 VALUES (variable1);</span><br><span class="line">　　ELSE</span><br><span class="line">　　    INSERT INTO table1 VALUES (99);</span><br><span class="line">　　END CASE;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_CASE&#96; (IN param1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE variable1 INT;</span><br><span class="line">　　SET variable1 &#x3D; param1 + 1;</span><br><span class="line">　　CASE</span><br><span class="line">　　WHEN variable1 &#x3D; 0 THEN</span><br><span class="line">　　    INSERT INTO table1 VALUES (param1);</span><br><span class="line">　　WHEN variable1 &#x3D; 1 THEN</span><br><span class="line">　　    INSERT INTO table1 VALUES (variable1);</span><br><span class="line">　　ELSE</span><br><span class="line">　　    INSERT INTO table1 VALUES (99);</span><br><span class="line">　　END CASE;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><p><strong>WHILE语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_WHILE&#96; (IN param1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE variable1, variable2 INT;</span><br><span class="line">　　SET variable1 &#x3D; 0;</span><br><span class="line">　　WHILE variable1</span><br><span class="line">　　    INSERT INTO table1 VALUES (param1);</span><br><span class="line">　　    SELECT COUNT(*) INTO variable2 FROM table1;</span><br><span class="line">　　    SET variable1 &#x3D; variable1 + 1;</span><br><span class="line">　　END WHILE;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><br><h4 id="7-Mysql存储过程中的游标"><a href="#7-Mysql存储过程中的游标" class="headerlink" title="7.Mysql存储过程中的游标"></a>7.Mysql存储过程中的游标</h4><blockquote><p>MySQL中的游标是一个十分重要的概念。游标提供了一种对从表中检索出的数据进行操作的灵活手段，就本质而言，游标实际上是一种<strong>能从包括多条数据记录的结果集中每次提取一条记录的机制</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor-name CURSOR FOR SELECT ...; &#x2F;* 声明一个游标，名称为cursor-name,并用CURSOR                                              FOR SELECT*&#x2F;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND &#x2F;*指定当遍历完结果集后，游标如何继续处理*&#x2F;</span><br><span class="line">OPEN cursor-name; &#x2F;*打开游标 *&#x2F;</span><br><span class="line">FETCH cursor-name INTO variable [, variable]; &#x2F;* 将变量赋值给游标*&#x2F;</span><br><span class="line">CLOSE cursor-name; &#x2F;*使用后关闭游标*&#x2F;</span><br></pre></td></tr></table></figure><p>e.g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE &#96;proc_CURSOR&#96; (OUT param1 INT)</span><br><span class="line">BEGIN</span><br><span class="line">　　DECLARE a, b, c INT;</span><br><span class="line">　　DECLARE cur1 CURSOR FOR SELECT col1 FROM table1;</span><br><span class="line">　　DECLARE CONTINUE HANDLER FOR NOT FOUND SET b &#x3D; 1;</span><br><span class="line">　　OPEN cur1;</span><br><span class="line">　　SET b &#x3D; 0;</span><br><span class="line">　　SET c &#x3D; 0;</span><br><span class="line">　　WHILE b &#x3D; 0 DO</span><br><span class="line">　　    FETCH cur1 INTO a;</span><br><span class="line">　　    IF b &#x3D; 0 THEN</span><br><span class="line">　　        SET c &#x3D; c + a;</span><br><span class="line">　　    END IF;</span><br><span class="line">　　END WHILE;</span><br><span class="line">　　CLOSE cur1;</span><br><span class="line">　　SET param1 &#x3D; c;</span><br><span class="line">END &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>其中，DECLARE cur1 CURSOR FOR SELECT col1 FROM table1;</p><p>表示将从table1表中选取col1列的内容放到游标curl中，即每次游标遍历的结果都放在curl中，要注意游标只能向前遍历，而不能向后，并且注意，游标不能更新，最后关闭游标。</p></blockquote><p>附上人生第一个SQL存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE DEFINER &#x3D; &#96;root&#96;@&#96;localhost&#96; PROCEDURE &#96;NewProc&#96;(INOUT &#96;left1&#96; varchar(20),INOUT &#96;right1&#96; varchar(20),INOUT &#96;feed1&#96; varchar(20))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE leftlen,rightlen,feedlen INT;</span><br><span class="line">SET leftlen &#x3D; len(leftl);</span><br><span class="line">SET rightlen &#x3D; len(rightl);</span><br><span class="line">SET feedlen &#x3D; len(feedl);</span><br><span class="line"></span><br><span class="line">IF not EXISTS (select autocode from autocode where autocode like CONCAT(left1,&#39;%&#39;) and autocode like CONCAT(&#39;%&#39;,right1)) THEN</span><br><span class="line">insert into autocode (autocode) values ( CONCAT(left1,feed1,right1));</span><br><span class="line">select CONCAT(left1,feed1,right1) as autocode;</span><br><span class="line">  ELSE </span><br><span class="line">insert into autocode </span><br><span class="line">select CONCAT(left1,max(substring(autocode,leftlen+1,feedlen))+1,right1) from autocode where autocode like CONCAT(left1,&#39;%&#39;) and autocode like CONCAT(&#39;%&#39;,right1);</span><br><span class="line">delete from autocode where autocode like CONCAT(left1,&#39;%&#39;) and autocode like CONCAT(&#39;%&#39;,right1)</span><br><span class="line">and autocode not in (select max(autocode) from autocode where autocode like CONCAT(left1,&#39;%&#39;) and autocode like CONCAT(&#39;%&#39;,right1));</span><br><span class="line">select max(autocode)  as autocode  from  autocode where autocode like CONCAT(left1,&#39;%&#39;) and autocode like CONCAT(&#39;%&#39;,right1);</span><br><span class="line">set feedlen &#x3D; 2323;</span><br><span class="line">END IF;</span><br><span class="line">   </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储过程 </tag>
            
            <tag> Mysql存储过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现定时从远程服务器下载文件(Redis消息队列)</title>
      <link href="/blog/2019/03/19/Java%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%8E%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6(Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)/"/>
      <url>/blog/2019/03/19/Java%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%8E%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6(Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><ul><li>获取Redis队列中的文件名称</li><li>更新远程服务器上的资源到本地(Https)</li><li>定时刷新，一但那边的服务器上传文件，就下载<br><br></li></ul><h3 id="2-从Redis中获取文件名称-此时的Redis相当于一个消息队列"><a href="#2-从Redis中获取文件名称-此时的Redis相当于一个消息队列" class="headerlink" title="2.从Redis中获取文件名称(此时的Redis相当于一个消息队列)"></a>2.从Redis中获取文件名称(此时的Redis相当于一个消息队列)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 定时程序(每十秒请求一次)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 15:05 2019/3/19</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">10</span>*<span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ListOperations los = redisTemplate.opsForList();</span><br><span class="line">        List&lt;String&gt; list = los.range(reidsPath,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String fileUrl : list) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Download File ..."</span>);</span><br><span class="line">                fileUrl = los.leftPop(reidsPath).toString().replaceAll(<span class="string">" "</span>,<span class="string">""</span>);</span><br><span class="line">                down(fileUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><h3 id="3-从远程地址下载文件资源-Htpps"><a href="#3-从远程地址下载文件资源-Htpps" class="headerlink" title="3.从远程地址下载文件资源(Htpps)"></a>3.从远程地址下载文件资源(Htpps)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 下载文件(https)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 17:25 2019/3/19</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(String fileUrl)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String fileLocal = fileUrl.split(spiltPath)[<span class="number">1</span>];</span><br><span class="line">        String[] array = fileLocal.split(<span class="string">"/"</span>);</span><br><span class="line">        String folder = rootPath + fileLocal.split(array[array.length-<span class="number">1</span>])[<span class="number">0</span>].trim();</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(folder);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        X509TrustManager x509m = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] x509Certificates, String s)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] x509Certificates, String s)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> X509Certificate[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        SSLContext sslcontext = SSLContext.getInstance(<span class="string">"SSL"</span>, <span class="string">"SunJSSE"</span>);</span><br><span class="line">        sslcontext.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[] &#123;x509m&#125;, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(fileUrl);</span><br><span class="line">        HostnameVerifier ignoreHostnameVerifier = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String s, SSLSession sslsession)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"WARNING: Hostname is not matched for cert."</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier(ignoreHostnameVerifier);</span><br><span class="line">        HttpsURLConnection.setDefaultSSLSocketFactory(sslcontext.getSocketFactory());</span><br><span class="line">        HttpsURLConnection urlCon = (HttpsURLConnection) url.openConnection();</span><br><span class="line">        urlCon.setConnectTimeout(<span class="number">6000</span>);</span><br><span class="line">        urlCon.setReadTimeout(<span class="number">6000</span>);</span><br><span class="line">        <span class="keyword">int</span> code = urlCon.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (code != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"文件读取失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读文件流</span></span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(urlCon.getInputStream());</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(fileLocal));</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((count = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h3><p><strong>本文中的定时程序需要在启动类里开启定时调度</strong>（否则无法定时执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br></pre></td></tr></table></figure><p><strong>本文中的变量从配置文件里获取</strong>(下面给出文中定义的变量)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;redis.path&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String reidsPath;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;download.file.spiltPath&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String spiltPath;</span><br><span class="line">   <span class="meta">@Value</span>(<span class="string">"$&#123;download.file.rootPath&#125;"</span>)</span><br><span class="line">   <span class="keyword">private</span> String rootPath;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis消息队列 </tag>
            
            <tag> 远程下载文件(https) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决SpringBoot中RedisTemplate存储时出现的乱码</title>
      <link href="/blog/2019/03/15/%E8%A7%A3%E5%86%B3SpringBoot%E4%B8%ADRedisTemplate%E5%AD%98%E5%82%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B9%B1%E7%A0%81/"/>
      <url>/blog/2019/03/15/%E8%A7%A3%E5%86%B3SpringBoot%E4%B8%ADRedisTemplate%E5%AD%98%E5%82%A8%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><blockquote><p>往Redis里存数据时，会出现一系列的乱码<br>\xAC\xED\x00\x05t\x00\x04uuid</p></blockquote><br><h3 id="2-乱码原因"><a href="#2-乱码原因" class="headerlink" title="2.乱码原因"></a>2.乱码原因</h3><blockquote><p>spring-data-redis的RedisTemplate&lt;K, V&gt;模板类在操作redis时默认使用JdkSerializationRedisSerializer来进行序列化</p></blockquote><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RedisSerializer stringSerializer &#x3D; new StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">redisTemplate.setKeySerializer(stringSerializer);</span><br><span class="line">redisTemplate.setValueSerializer(stringSerializer);</span><br><span class="line">redisTemplate.setHashKeySerializer(stringSerializer);</span><br><span class="line">redisTemplate.setHashValueSerializer(stringSerializer);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java图片转换为PDF并合成同一PDF</title>
      <link href="/blog/2019/03/08/Java%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E5%B9%B6%E5%90%88%E6%88%90%E5%90%8C%E4%B8%80PDF/"/>
      <url>/blog/2019/03/08/Java%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E5%B9%B6%E5%90%88%E6%88%90%E5%90%8C%E4%B8%80PDF/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>将同一文件夹下的图片和PDF,转换合并为同一个PDF，并要求转换中的图片按格式排版好 <br><br></p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><ol><li>调整图片，检测图片大小及方向，调整至A4大小(842×595)， 寻找最佳缩放比，等比例缩放图片，为避免多次IO操作，返回BufferedImage</li><li>将图片转换为PDF</li><li>将文件夹下的PDF按顺序合并，得到最终的final.pdf<br><br></li></ol><h3 id="3-所需工具类"><a href="#3-所需工具类" class="headerlink" title="3.所需工具类"></a>3.所需工具类</h3><p>前两个为处理PDF的工具类，最后一个为图片处理类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.itextpdf/itextpdf --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.itextpdf&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;itextpdf&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.5</span><span class="number">.13</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.pdfbox/pdfbox --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.pdfbox&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;pdfbox&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.7</span><span class="number">.1</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.coobird&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;thumbnailator&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.4</span><span class="number">.8</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dependency&gt;</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="4-图片处理类"><a href="#4-图片处理类" class="headerlink" title="4.图片处理类"></a>4.图片处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaPdf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.coobird.thumbnailator.Thumbnails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.ConvolveOp;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.Kernel;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImgUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span> 调整图片角度并生成合适大小的图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Date</span> 16:37 2019/3/7</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedImage <span class="title">rotateImage</span><span class="params">(String imgFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedImage bufferedImage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(imgFile != <span class="string">""</span> || imgFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">                File _img_file_ = <span class="keyword">new</span> File(imgFile);</span><br><span class="line">                <span class="keyword">if</span>(_img_file_.exists())&#123;</span><br><span class="line">                    Integer angel = <span class="number">270</span>;</span><br><span class="line">                    BufferedImage src = ImageIO.read(_img_file_);</span><br><span class="line"></span><br><span class="line">                    BigDecimal height = BigDecimal.valueOf(src.getHeight());</span><br><span class="line">                    BigDecimal width = BigDecimal.valueOf(src.getWidth());</span><br><span class="line">                    BigDecimal bd = height.divide(width,<span class="number">4</span>,BigDecimal.ROUND_CEILING);</span><br><span class="line">                    BigDecimal theValue = BigDecimal.valueOf(<span class="number">1.1700</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bd.compareTo(theValue) == -<span class="number">1</span> ) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"转换中 ..."</span>);</span><br><span class="line">                        bufferedImage = Thumbnails.of(src).rotate(angel).scale(<span class="number">1</span>).asBufferedImage();</span><br><span class="line">                        bufferedImage = calcScale(bufferedImage);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        bufferedImage = calcScale(src);</span><br><span class="line">                        System.out.println(<span class="string">"宽高比合适,跳过 ..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//bufferedImage = getSharperPicture(bufferedImage);</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bufferedImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Ragty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>  计算最佳放缩比</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 9:19 2019/3/11</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedImage <span class="title">calcScale</span><span class="params">(BufferedImage bufferedImage)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        BigDecimal standaraHeight = BigDecimal.valueOf(<span class="number">842</span>);</span><br><span class="line">        BigDecimal standaraWeight = BigDecimal.valueOf(<span class="number">595</span>);</span><br><span class="line">        BigDecimal height = BigDecimal.valueOf(bufferedImage.getHeight());</span><br><span class="line">        BigDecimal width = BigDecimal.valueOf(bufferedImage.getWidth());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (height.compareTo(standaraHeight) == <span class="number">1</span> || width.compareTo(standaraWeight) == <span class="number">1</span>) &#123; <span class="comment">//不符合标准，缩放</span></span><br><span class="line">            BigDecimal scaleHeight = standaraHeight.divide(height,<span class="number">4</span>,BigDecimal.ROUND_CEILING);</span><br><span class="line">            BigDecimal scaleWidth = standaraWeight.divide(width,<span class="number">4</span>,BigDecimal.ROUND_CEILING);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scaleHeight.compareTo(BigDecimal.valueOf(<span class="number">1</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                bufferedImage = Thumbnails.of(bufferedImage).scale(scaleHeight.floatValue()).outputQuality(<span class="number">1.0f</span>).asBufferedImage();</span><br><span class="line">                calcScale(bufferedImage);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (scaleWidth.compareTo(BigDecimal.valueOf(<span class="number">1</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">                bufferedImage = Thumbnails.of(bufferedImage).scale(scaleWidth.floatValue()).outputQuality(<span class="number">1.0f</span>).asBufferedImage();</span><br><span class="line">                calcScale(bufferedImage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  bufferedImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="5-PDF处理类"><a href="#5-PDF处理类" class="headerlink" title="5.PDF处理类"></a>5.PDF处理类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">package JavaPdf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.*;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfPCell;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfPTable;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.PdfWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.util.PDFMergerUtility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.color.ColorSpace;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.ColorConvertOp;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PdfUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author <span class="variable">Ragty</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description </span>将图片转换为PDF</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date </span>15:27 2019/3/4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> Img2PDF(<span class="built_in">String</span> imagePath,BufferedImage img,<span class="built_in">String</span> descfolder) throws Exception&#123;</span><br><span class="line">        <span class="built_in">String</span> pdfPath = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//图片操作</span></span><br><span class="line">            Image image = <span class="literal">null</span>;</span><br><span class="line">            File file = <span class="keyword">new</span> File(descfolder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pdfPath = descfolder +<span class="string">"/"</span>+System.currentTimeMillis()+<span class="string">".pdf"</span>;</span><br><span class="line">            <span class="built_in">String</span> type = imagePath.substring(imagePath.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">            Document doc = <span class="keyword">new</span> Document(<span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更换图片图层</span></span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(img.getWidth(), img.getHeight(),BufferedImage.TYPE_3BYTE_BGR);</span><br><span class="line">            bufferedImage.getGraphics().drawImage(img, <span class="number">0</span>,<span class="number">0</span>, img.getWidth(), img.getHeight(), <span class="literal">null</span>);</span><br><span class="line">            bufferedImage=<span class="keyword">new</span> ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_GRAY),<span class="literal">null</span>).filter (bufferedImage,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//图片流处理</span></span><br><span class="line">            doc.setPageSize(<span class="keyword">new</span> Rectangle(bufferedImage.getWidth(), bufferedImage.getHeight()));</span><br><span class="line">            System.out.println(bufferedImage.getWidth()+<span class="string">"()()()()()"</span>+bufferedImage.getHeight());</span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            boolean flag = ImageIO.write(bufferedImage, type, out);</span><br><span class="line">            byte[] b = out.toByteArray();</span><br><span class="line">            image = Image.getInstance(b);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入PDF</span></span><br><span class="line">            System.out.println(<span class="string">"写入PDf:"</span> + pdfPath);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(pdfPath);</span><br><span class="line">            PdfWriter.getInstance(doc, fos);</span><br><span class="line">            doc.open();</span><br><span class="line">            doc.add(image);</span><br><span class="line">            doc.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadElementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pdfPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author <span class="variable">Ragty</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description </span>获取文件夹下的PDF</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date </span>17:33 2019/3/7</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="built_in">String</span>[] getFiles(<span class="built_in">String</span> folder) throws IOException &#123;</span><br><span class="line">        File _folder = <span class="keyword">new</span> File(folder);</span><br><span class="line">        <span class="built_in">String</span>[] filesInFolder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_folder.isDirectory()) &#123;</span><br><span class="line">            filesInFolder = _folder.list();</span><br><span class="line">            <span class="keyword">return</span> filesInFolder;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Path is not a directory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author <span class="variable">Ragty</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description </span>合成PDF</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date </span>17:25 2019/3/7</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> mergePDF(<span class="built_in">String</span>[] files,<span class="built_in">String</span> desfolder,<span class="built_in">String</span> mergeFileName ) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        PDFMergerUtility mergePdf = <span class="keyword">new</span> PDFMergerUtility();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> file :files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toLowerCase().endsWith(<span class="string">"pdf"</span>))</span><br><span class="line">                mergePdf.addSource(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mergePdf.setDestinationFileName(desfolder+<span class="string">"/"</span>+mergeFileName);</span><br><span class="line">        mergePdf.mergeDocuments();</span><br><span class="line">        System.out.println(<span class="string">"merge over"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        ImgUtil imageUtil = <span class="keyword">new</span> ImgUtil();</span><br><span class="line">        <span class="built_in">String</span>[] files = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="number">11</span>];</span><br><span class="line">        files[<span class="number">0</span>] = <span class="string">"D:/test2/2019021910311346.jpg"</span>;</span><br><span class="line">        files[<span class="number">1</span>] = <span class="string">"D:/test2/2019021816284226.jpg"</span>;</span><br><span class="line">        files[<span class="number">2</span>] = <span class="string">"D:/test2/2019021816284244.png"</span>;</span><br><span class="line">        files[<span class="number">3</span>] = <span class="string">"D:/test2/2019021816284299.jpg"</span>;</span><br><span class="line">        files[<span class="number">4</span>] = <span class="string">"D:/test2/2019021816284346.png"</span>;</span><br><span class="line">        files[<span class="number">5</span>] = <span class="string">"D:/test2/2019021816285533.png"</span>;</span><br><span class="line">        files[<span class="number">6</span>] = <span class="string">"D:/test2/2019021816285546.jpg"</span>;</span><br><span class="line">        files[<span class="number">7</span>] = <span class="string">"D:/test2/2019021816285553.jpg"</span>;</span><br><span class="line">        files[<span class="number">8</span>] = <span class="string">"D:/test2/2019021816285640.png"</span>;</span><br><span class="line">        files[<span class="number">9</span>] = <span class="string">"D:/test2/2019021910305527.pdf"</span>;</span><br><span class="line">        files[<span class="number">10</span>] = <span class="string">"D:/test2/201902191030445.pdf"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">String</span> folder = <span class="string">"D:/test2"</span>;</span><br><span class="line">        <span class="built_in">String</span> mergeFileName = <span class="string">"final.pdf"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;files.length;i++) &#123;</span><br><span class="line">            <span class="built_in">String</span> file = files[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file.toLowerCase().endsWith(<span class="string">".png"</span>)</span><br><span class="line">                    || file.toLowerCase().endsWith(<span class="string">".jpg"</span>)</span><br><span class="line">                    || file.toLowerCase().endsWith(<span class="string">".gif"</span>)</span><br><span class="line">                    || file.toLowerCase().endsWith(<span class="string">".jpeg"</span>)</span><br><span class="line">                    || file.toLowerCase().endsWith(<span class="string">".gif"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                BufferedImage bi = imageUtil.rotateImage(file);</span><br><span class="line">                <span class="keyword">if</span> (bi==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">String</span> pdffile = Img2PDF(file,bi,folder);</span><br><span class="line">                files[i] = pdffile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mergePDF(files,folder,mergeFileName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h3><p>处理前<img src="https://img-blog.csdnimg.cn/20190308094925582.png" alt="在这里插入图片描述"><br>处理后的图片<br><img src="https://img-blog.csdnimg.cn/20190308100117975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>合并后的PDF<br><img src="https://img-blog.csdnimg.cn/20190308100206758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf转换 </tag>
            
            <tag> Java图片转换pdf </tag>
            
            <tag> pdf合并 </tag>
            
            <tag> 图片处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 23种设计模式</title>
      <link href="/blog/2019/02/14/Java%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2019/02/14/Java%2023%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><ul><li>饿汉模式(线程不安全，速度快，浪费资源多)</li><li>懒汉模式(线程不安全,第一次加载较慢)</li><li>双重检测(加锁，线程安全，第一次加载较慢)</li><li>静态方法</li></ul><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><blockquote><p>定义一个用于创建爱你对象的接口，让子类决定实例化哪一个类，是一个类的实例化延迟到其子类</p></blockquote><p><img src="http://www.runoob.com/wp-content/uploads/2018/07/1530601917-1999-DP-Factory.png" alt=""></p><h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h3><blockquote><p>提供一个创建乙烯类相关或者相互依赖对象的接口，而无需指定他们具体的类</p></blockquote><p><img src="http://www.runoob.com/wp-content/uploads/2018/07/1530601916-7298-DP-AbstractFactory.png" alt=""></p><p><img src="http://www.runoob.com/wp-content/uploads/2018/07/1530601980-8080-P-AbstractFactory-AddFactory.png" alt=""></p><p><img src="http://www.runoob.com/wp-content/uploads/2018/07/1530601917-7462-P-AbstractFactory-AddProduct.png" alt=""></p><h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h3><blockquote><p>使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式</p></blockquote><blockquote><p>解决的问题：</p><ol><li>用户只需要给出指定复杂对象的类型和内容；</li><li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li></ol></blockquote><ul><li><p><strong>Product（产品角色）：</strong> 一个具体的产品对象 (指出它的部件)</p></li><li><p><strong>Builder（抽象建造者）：</strong> 创建一个Product对象的各个部件指定的抽象接口  (<strong>定义抽象动作，具体实现未知)</strong></p></li><li><p><strong>ConcreteBuilder（具体建造者）：</strong> 实现抽象接口，构建和装配各个部件  (<strong>定义具体做什么</strong>)</p></li><li><p><strong>Director（指挥者）：</strong> 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，</p><p>一：隔离了客户与对象的生产过程</p><p>二：负责控制产品对象的生产过程。</p></li></ul><blockquote><p>模式讲解： </p><ol><li>指挥者（Director）直接和客户（Client）进行需求沟通； </li><li>沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）； </li><li>将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）； </li><li>各个具体建造者负责进行产品部件的构建； </li><li>最终构建成具体产品（Product）。</li></ol></blockquote><blockquote><ol><li>电脑城老板（Diretor）和小成（Client）进行需求沟通</li><li>了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）</li><li>指挥装机人员（ConcreteBuilder）去构建组件；</li><li>组装成电脑(Product)</li></ol></blockquote><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p></blockquote><p> <strong>浅拷贝：</strong>使用一个已知实例对新创建实例的成员变量逐个赋值（传递引用，不能复制实例）</p><p><strong>深拷贝：</strong>当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量，还要引用类型的成员变量创建新的实例，并且初始化为形式参数的实例值（对象内部的引用均复制，它是创建一个新的实例，并且复制实例）</p><p><img src="https://images0.cnblogs.com/blog/381060/201309/10205053-c368741694b842aca314a0690ab0d00d.jpg" alt=""></p><p><strong>主要解决：</strong>在运行期建立和删除原型。</p><p><strong>何时使用：</strong> </p><ol><li>如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 </li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便</li></ol><h6 id="模式构成"><a href="#模式构成" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li>Prototype：抽象原型类。声明克隆自身的接口。 </li><li>ConcretePrototype：具体原型类。实现克隆的具体操作。</li><li>Client：客户类。让一个原型克隆自身，从而获得一个新的对象。</li></ul><h6 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h6><ol><li>原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。</li><li>克隆分为浅克隆和深克隆两种。</li></ol><h3 id="6-适配者模式"><a href="#6-适配者模式" class="headerlink" title="6.适配者模式"></a>6.适配者模式</h3><blockquote><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作（直白点就是转接器）</p></blockquote><h6 id="模式构成-1"><a href="#模式构成-1" class="headerlink" title="模式构成"></a>模式构成</h6><ol><li><strong>Target(目标抽象类)：</strong>目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。</li><li><strong>Adapter(适配器类)：</strong>它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配</li><li><strong>Adaptee(适配者类)：</strong>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类包好了客户希望的业务方法</li></ol><h3 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7.桥接模式"></a>7.桥接模式</h3><blockquote><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化</p></blockquote><h6 id="模式构成-2"><a href="#模式构成-2" class="headerlink" title="模式构成"></a>模式构成</h6><ol><li><strong>实现化（Implementor）角色：</strong>定义实现化角色的接口，供扩展抽象化角色调用。</li><li><strong>Abstraction(抽象化对象)：</strong>定义抽象类，并包含一个对实现化对象的引用</li><li><strong>扩展抽象化（Refined    Abstraction）角色：</strong>是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li><strong>具体实现化（Concrete Implementor）角色：</strong>给出实现化角色接口的具体实现。</li></ol><p><img src="http://c.biancheng.net/uploads/allimg/181115/3-1Q11512532X54.gif" alt=""></p><h3 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8.组合模式"></a>8.组合模式</h3><blockquote><p>又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次</p></blockquote><h6 id="模式构成-3"><a href="#模式构成-3" class="headerlink" title="模式构成"></a>模式构成</h6><ol><li><strong>Component（抽象构件）：</strong>它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</li><li><strong>Leaf（叶子构件）：</strong>它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。</li><li><strong>Composite（容器构件）：</strong>表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ol><h3 id="9-装饰器模式"><a href="#9-装饰器模式" class="headerlink" title="9.装饰器模式"></a>9.装饰器模式</h3><blockquote><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活(继承关系的替代方案)</p></blockquote><ul><li><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</li><li><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</li><li><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</li></ul><h6 id="模式构成-4"><a href="#模式构成-4" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li>抽象构件角色 (给出一个抽象接口，一规范接收附加责任的对象)</li><li>具体构件角色 (定义一个将要接受附加责任的类)</li><li>装饰角色 (持有一个构件对象的实例，并定义一个与抽象构件接               口一致的接口)</li><li>具体装饰角色 (负责给构件对象贴上附加的责任)</li></ul><h3 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10.外观模式"></a>10.外观模式</h3><blockquote><p>隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口</p></blockquote><ul><li><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li><li><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</li><li><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口</li></ul><h6 id="模式构成-5"><a href="#模式构成-5" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li>接口</li><li>接口实现类(实现不同的方法)</li><li>外观类 xxMarker (使用实体类来代表用户对这些类的调用)</li></ul><h3 id="11-代理模式"><a href="#11-代理模式" class="headerlink" title="11.代理模式"></a>11.代理模式</h3><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。    </p></blockquote><h6 id="模式总结-1"><a href="#模式总结-1" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p></li><li><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p></li><li><p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p></li><li><p><strong>如何解决：</strong>增加中间层。</p></li><li><p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p></li></ul><h6 id="模式构成-6"><a href="#模式构成-6" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li>接口类</li><li>接口实现</li><li>接口代理类(直接调用接口代理类，实现对象操作)</li></ul><h3 id="12-责任链模式"><a href="#12-责任链模式" class="headerlink" title="12.责任链模式"></a>12.责任链模式</h3><blockquote><p>为请求创建了一个接收者对象的链，每个接收者都包含对另一个接收者的引用，当某个接受者不能处理该请求时，会将该请求转给下一个接受者处</p></blockquote><h6 id="模式总结-2"><a href="#模式总结-2" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p></li><li><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p></li><li><p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p></li><li><p><strong>如何解决：</strong>拦截的类都实现统一接口。</p></li><li><p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p></li></ul><h6 id="模式构成-7"><a href="#模式构成-7" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li><strong>请求者</strong>：负责请求的类型</li><li><strong>处理者</strong>：负责处理请求</li><li><strong>客户端</strong>：负责发出接收请求</li></ul><h3 id="13-命令模式"><a href="#13-命令模式" class="headerlink" title="13.命令模式"></a>13.命令模式</h3><blockquote><p>显而易见，是将命令和实际操作相隔离，解耦合，客户端只发出命令，具体的操作不需要关心，只需要完成任务。举个很简单的例子，用户点菜，然后厨师做菜，根据点菜的口味不同厨师做不同的菜</p></blockquote><h6 id="模式总结-3"><a href="#模式总结-3" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li><li><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</li><li><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li><li><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</li></ul><h6 id="模式构成-8"><a href="#模式构成-8" class="headerlink" title="模式构成"></a>模式构成</h6><p><strong>Invoker(调用者)</strong>：使用命令对象的入口</p><p><strong>Command</strong>：命令</p><p><strong>Received(命令接收者)</strong>：正真的命令执行对象</p><h3 id="14-解释器模式"><a href="#14-解释器模式" class="headerlink" title="14.解释器模式"></a>14.解释器模式</h3><blockquote><p>是一种用得比较少的行为型模式.提供了一种解释语言的语法或表达式的方式. 通过定义一个表达式接口,解释一个特定的上下文</p></blockquote><h6 id="模式总结-4"><a href="#模式总结-4" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</li><li><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</li><li><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</li><li><strong>如何解决：</strong>构件语法树，定义终结符与非终结符。</li></ul><h6 id="模式构成-9"><a href="#模式构成-9" class="headerlink" title="模式构成"></a>模式构成</h6><p><strong><em>Expression</em></strong>：接口(创建表达式)</p><p><strong>SimpleExpresson</strong>:具体的实现接口(校验表达式，并输出)</p><h3 id="15-迭代器模式"><a href="#15-迭代器模式" class="headerlink" title="15.迭代器模式"></a>15.迭代器模式</h3><blockquote><p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示</p></blockquote><h6 id="模式总结-5"><a href="#模式总结-5" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</li><li><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</li><li><strong>何时使用：</strong>遍历一个聚合对象。</li><li><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</li></ul><h6 id="模式构成-10"><a href="#模式构成-10" class="headerlink" title="模式构成"></a>模式构成</h6><p><strong>List</strong>: 设计实现list，底层为数组，提供方法</p><p><strong>Iterator</strong>: 迭代器，直接操作list,提供访问方法在不暴露内部的情况下</p><h3 id="16-中介者模式"><a href="#16-中介者模式" class="headerlink" title="16.中介者模式"></a>16.中介者模式</h3><blockquote><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护</p></blockquote><h6 id="模式构成-11"><a href="#模式构成-11" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</li><li><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</li><li><strong>如何解决：</strong>将上述网状结构分离为星型结构。</li><li><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</li></ul><h6 id="模式构成-12"><a href="#模式构成-12" class="headerlink" title="模式构成"></a>模式构成</h6><p><strong>ConcreateMeditor(中介者)：</strong>具体中介者通过协调各同事对象实现协作行为，了解并维护它的各个同事</p><p><strong>Colleague(同事类):</strong> 规定同事内部的方法</p><h3 id="17-备忘录模式"><a href="#17-备忘录模式" class="headerlink" title="17.备忘录模式"></a>17.备忘录模式</h3><blockquote><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象</p></blockquote><h6 id="模式总结-6"><a href="#模式总结-6" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li><li><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</li><li><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</li><li><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</li><li><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合</li></ul><h6 id="模式构成-13"><a href="#模式构成-13" class="headerlink" title="模式构成"></a>模式构成</h6><ul><li><strong>Originator(原型):</strong>    可设置状态</li><li><strong>Caretaker(保存型):</strong>  可做中间保存媒介</li><li><strong>Memento(保存实体)</strong>: 可做为实体进行保存</li></ul><h3 id="18-观察者模式"><a href="#18-观察者模式" class="headerlink" title="18.观察者模式"></a>18.观察者模式</h3><blockquote><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p></blockquote><h6 id="模式总结-7"><a href="#模式总结-7" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</li><li><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</li><li><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</li><li><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</li></ul><h6 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h6><ul><li><strong>观察者</strong>：负责进行</li><li><strong>被观察者接口</strong>：定义操作观察者的方法，提供发布消息的方法</li></ul><h3 id="19-状态模式"><a href="#19-状态模式" class="headerlink" title="19.状态模式"></a>19.状态模式</h3><blockquote><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象</p></blockquote><h6 id="模式总结-8"><a href="#模式总结-8" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</li><li><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</li><li><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</li><li><strong>如何解决：</strong>将各种具体的状态类抽象出来。</li><li><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</li><li><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</li></ul><h6 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h6><ul><li><strong>State</strong>: 状态类，定义状态</li><li><strong>Context:</strong> 被定义状态类，可根据具体传入的状态改变</li></ul><h3 id="20-策略模式"><a href="#20-策略模式" class="headerlink" title="20.策略模式"></a>20.策略模式</h3><blockquote><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p></blockquote><h6 id="模式总结-9"><a href="#模式总结-9" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li><li><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</li><li><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</li><li><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</li><li><strong>关键代码：</strong>实现同一个接口。</li></ul><h6 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h6><ul><li><strong>Straegy</strong>：确定策略接口</li><li><strong>具体策略接口:</strong> 具体的策略</li><li><strong>Context:</strong> 使用了某种策略的类</li></ul><h3 id="21-模板模式"><a href="#21-模板模式" class="headerlink" title="21.模板模式"></a>21.模板模式</h3><blockquote><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p></blockquote><h6 id="模式总结-10"><a href="#模式总结-10" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</li><li><strong>何时使用：</strong>有一些通用的方法。</li><li><strong>如何解决：</strong>将这些通用算法抽象出来。</li><li><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</li><li><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li></ul><h6 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h6><ul><li><strong>模板类：</strong>定义模板方法</li><li><strong>模板实现类:</strong>模板实现的具体方法</li></ul><h3 id="22-访问者模式"><a href="#22-访问者模式" class="headerlink" title="22.访问者模式"></a>22.访问者模式</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示一个作用于其对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作</span><br></pre></td></tr></table></figure></blockquote><h6 id="模式总结-11"><a href="#模式总结-11" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>主要将数据结构与数据操作分离。</li><li><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</li><li><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</li><li><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</li><li><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</li><li><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式</li></ul><h6 id="模式结构-4"><a href="#模式结构-4" class="headerlink" title="模式结构"></a><strong>模式结构</strong></h6><ul><li><strong>基础类</strong>：提供基础方法</li><li><strong>访问者</strong>：在不改变基础类的同时，传入访问者</li></ul><h3 id="23-享元模式"><a href="#23-享元模式" class="headerlink" title="23.享元模式"></a>23.享元模式</h3><blockquote><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p></blockquote><h6 id="模式总结-12"><a href="#模式总结-12" class="headerlink" title="模式总结"></a>模式总结</h6><ul><li><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</li><li><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</li><li><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</li><li><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</li><li><strong>关键代码：</strong>用 HashMap 存储这些对象。</li><li><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现简易Tomcat服务器(内附原理和测试)</title>
      <link href="/blog/2019/01/28/Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8(%E5%86%85%E9%99%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95)/"/>
      <url>/blog/2019/01/28/Java%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8(%E5%86%85%E9%99%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%8B%E8%AF%95)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h3><blockquote><p>Tomcat服务器是一个轻量级的Java代码实现的Web服务器。这篇文章会讲述如何用Java实现一个简单的Tomcat服务器。</p></blockquote><h3 id="1-简易原理"><a href="#1-简易原理" class="headerlink" title="1.简易原理"></a>1.简易原理</h3><ol><li><p>Tomcat开始运行后，会在服务器上开一个端口(本文中用的是8888端口)，在所开辟的端口上运行一个ServerScoket,执行accpet()方法等待浏览器访问。</p></li><li><p>浏览器访问端口，ServerSocket的accept()方法返回一个运行在服务器端的socket，通过socket的getInputStream()方法和getOutputStream方法，可获得浏览器和服务器之间发送的内容和浏览器的响应内容()。</p></li><li><p>这里我们主要获取浏览器的请求地址和参数，响应时根据浏览器所传的参数和地址，到服务器上去寻找对应的资源(目前只支持静态资源)，将用户请求的资源转化为文件流，传输给前端(浏览器)。</p></li><li><p>浏览器收到服务器的响应后，向用户展示界面。</p><h3 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2.实现类"></a>2.实现类</h3><blockquote><p>主要分为以下几个类：<br>(1) Server 用于加载并启动服务器<br>(2) ServerThread 当接收到新请求时，开辟一个新的线程处理它<br>(3) Request 用于获取请求的数据(主要是请求的地址和请求参数)<br>(4) Response 用于响应请求(根据请求所获参数和地址，访问服务器上的资源)<br>(5) GetParam 用于获取环境变量参数</p></blockquote><h3 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h3></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package TomcatServer.server;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    private ServerSocket server;            &#x2F;&#x2F;服务</span><br><span class="line">    private int port;                       &#x2F;&#x2F;端口号</span><br><span class="line">    private static Properties prop;         &#x2F;&#x2F;用于读取配置文件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;配置参数读取位置</span><br><span class="line">    static &#123;</span><br><span class="line">        prop &#x3D; new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            prop.load(new FileInputStream(new File(&quot;src&#x2F;TomcatServer&#x2F;source&#x2F;property.properties&quot;)));</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 初始化服务器</span><br><span class="line">     * @param: []</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;24</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            port &#x3D; Integer.parseInt(prop.getProperty(&quot;port&quot;));</span><br><span class="line">            server &#x3D; new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器启动&quot;+ port + &quot;端口&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 在当前线程内，创建一个Client服务</span><br><span class="line">     * @param: []</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;25</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void recive() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;收到新请求&quot;);</span><br><span class="line">            Socket client &#x3D; server.accept();                       &#x2F;&#x2F;监听服务器，平时等待连接，有client则创建客户端实例(阻塞的)</span><br><span class="line">            ServerThread thread &#x3D; new ServerThread(client);        &#x2F;&#x2F;处理客户端请求,并返回请求页面</span><br><span class="line">            thread.start();</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; catch (IOException e1) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Server() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 启动Tomcat服务器</span><br><span class="line">     * @param: [args]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;25</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Server server2 &#x3D; new Server();</span><br><span class="line">        server2.init();</span><br><span class="line">        while (true) &#123;           &#x2F;&#x2F;一直等待用户访问定义端口，访问后，开辟新线程处理它</span><br><span class="line">            server2.recive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package TomcatServer.Request;</span><br><span class="line"></span><br><span class="line">import TomcatServer.Util.GetParam;</span><br><span class="line">import com.hjy.util.GetParm;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Request &#123;</span><br><span class="line">    private Socket client;                  &#x2F;&#x2F;客户端</span><br><span class="line">    private BufferedReader reader;</span><br><span class="line">    private String url;                     &#x2F;&#x2F;请求资源</span><br><span class="line">    private String method;                  &#x2F;&#x2F;请求方式</span><br><span class="line">    private String protocal;                &#x2F;&#x2F;请求协议</span><br><span class="line">    private Map&lt;String,String&gt; map;         &#x2F;&#x2F;参数列表</span><br><span class="line">    private GetParam getParam;              &#x2F;&#x2F;请求参数分割工具</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Request() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 接收并客户端(Client)发出的请求，获取请求的链接及参数</span><br><span class="line">     * @param: [client]</span><br><span class="line">     * @return:</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;25</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Request(Socket client) &#123;</span><br><span class="line">        this.client &#x3D; client;</span><br><span class="line">        map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        getParam &#x3D; new GetParam();</span><br><span class="line">        try &#123;</span><br><span class="line">            reader &#x3D; new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">            String firstLine &#x3D; reader.readLine();</span><br><span class="line">            String[] spilt &#x3D; firstLine.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            method &#x3D; spilt[0];</span><br><span class="line">            url &#x3D; spilt[1];</span><br><span class="line">            protocal &#x3D; spilt[2];</span><br><span class="line">            System.out.println(url);</span><br><span class="line"></span><br><span class="line">            if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;</span><br><span class="line">                if(url.contains(&quot;?&quot;)) &#123;</span><br><span class="line">                    String[] split2 &#x3D; url.split(&quot;[?]&quot;);</span><br><span class="line">                    url &#x3D; split2[0];                               &#x2F;&#x2F;重新定义url</span><br><span class="line">                    String property &#x3D; split2[1];</span><br><span class="line">                    map &#x3D; getParam.getParam(property);             &#x2F;&#x2F;分割参数</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int length &#x3D; 0;</span><br><span class="line">                while (reader.ready()) &#123;                           &#x2F;&#x2F;确保已经缓冲完毕</span><br><span class="line">                    String line &#x3D; reader.readLine();</span><br><span class="line">                    if (line.contains(&quot;Content-Length&quot;)) &#123;</span><br><span class="line">                        String[] spilt2 &#x3D; line.split(&quot; &quot;);</span><br><span class="line">                        length &#x3D; Integer.parseInt(spilt2[1]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (line.equals(&quot;&quot;)) &#123;                          &#x2F;&#x2F;Post方法无参数</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String info &#x3D; null;</span><br><span class="line">                char[] ch &#x3D; new char[length];</span><br><span class="line">                reader.read(ch , 0, length);</span><br><span class="line">                info &#x3D; new String(ch, 0, length);</span><br><span class="line">                map &#x3D; getParam.getParam(info);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Socket getClient() &#123; return client; &#125;</span><br><span class="line">    public void setClient(Socket client) &#123; this.client &#x3D; client; &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123; return url; &#125;</span><br><span class="line">    public void setUrl(String url) &#123; this.url &#x3D; url; &#125;</span><br><span class="line"></span><br><span class="line">    public String getMethod() &#123; return method; &#125;</span><br><span class="line">    public void setMethod(String method) &#123; this.method &#x3D; method; &#125;</span><br><span class="line"></span><br><span class="line">    public String getProtocal() &#123; return protocal; &#125;</span><br><span class="line">    public void setProtocal(String protocal) &#123; this.protocal &#x3D; protocal; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package TomcatServer.Response;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class Response &#123;</span><br><span class="line"></span><br><span class="line">    private Socket client;</span><br><span class="line">    private PrintStream ps;</span><br><span class="line">    private String path &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public Response() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 获取服务端传输给客户端的输出流</span><br><span class="line">     * @param: [client]</span><br><span class="line">     * @return:</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;24</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Response(Socket client) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.client &#x3D; client;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps &#x3D; new PrintStream(client.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe:根据当前路径将服务器上有的资源用流传给客户端</span><br><span class="line">     * @param: []</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;24</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void forword() throws FileNotFoundException &#123;</span><br><span class="line">        FileInputStream fis &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis &#x3D; new FileInputStream(new File(path));</span><br><span class="line">            ps.println(&quot;HTTP&#x2F;1.1 200 OK&quot;);</span><br><span class="line">            ps.println();</span><br><span class="line">            byte[] buf &#x3D; new byte[1024];</span><br><span class="line">            int length &#x3D; 0;</span><br><span class="line">            while ( (length &#x3D; fis.read(buf)) !&#x3D; -1 ) &#123;</span><br><span class="line">                ps.write(buf, 0, length);</span><br><span class="line">                ps.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fis !&#x3D; null) &#123;fis.close();&#125;</span><br><span class="line">                if (ps !&#x3D; null) &#123;ps.close();&#125;</span><br><span class="line">                if (client !&#x3D; null) &#123;client.close();&#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * @auther: Ragty</span><br><span class="line">     * @describe: 分情况处理请求Url(1.为空，返回默认资源 2.存在，加载该资源 3.不存在，返回错误信息)</span><br><span class="line">     * @param: [url]</span><br><span class="line">     * @return: void</span><br><span class="line">     * @date: 2019&#x2F;1&#x2F;24</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void forword(String url) &#123;</span><br><span class="line"></span><br><span class="line">        if (url.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            path &#x3D; &quot;src&#x2F;TomcatServer&#x2F;source&#x2F;2.jpg&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            path &#x3D; &quot;src&#x2F;TomcatServer&#x2F;source&quot; + url;</span><br><span class="line">            File file &#x3D; new File(path);</span><br><span class="line">            if (!file.exists()) &#123; path &#x3D; &quot;src&#x2F;TomcatServer&#x2F;source&#x2F;error.html&quot;; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            forword();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试效果"><a href="#4-测试效果" class="headerlink" title="4.测试效果"></a>4.测试效果</h3><p>浏览器输入 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> ，效果如下<br><img src="https://img-blog.csdnimg.cn/20190128140924350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt=""><br>浏览器输入 <a href="http://localhost:8888/success.html" target="_blank" rel="noopener">http://localhost:8888/success.html</a> ，效果如下<br><img src="https://img-blog.csdnimg.cn/20190128141206725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat服务器 </tag>
            
            <tag> Java实现Tomcat服务器 </tag>
            
            <tag> Web服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java爬虫抓取网页数据(抓取慕课网论坛为实例)</title>
      <link href="/blog/2019/01/23/Java%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE(%E6%8A%93%E5%8F%96%E6%85%95%E8%AF%BE%E7%BD%91%E8%AE%BA%E5%9D%9B%E4%B8%BA%E5%AE%9E%E4%BE%8B)/"/>
      <url>/blog/2019/01/23/Java%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE(%E6%8A%93%E5%8F%96%E6%85%95%E8%AF%BE%E7%BD%91%E8%AE%BA%E5%9D%9B%E4%B8%BA%E5%AE%9E%E4%BE%8B)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1. 网络爬虫</h3><p><strong><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E7%88%AC%E8%9F%B2" target="_blank" rel="noopener">网络爬虫</a></strong>（英语：<strong>web crawler</strong>），也叫网络蜘蛛（spider），是一种用来自动浏览万维网的网络机器人。其目的一般为编纂网络索引。简单来说，就是获取请求的页面源码，再通过正则表达式获取自己需要的内容。 实现的时候大致分为以下几个步骤:</p><p>       (1)爬取网页源码</p><p>       (2)利用正则截取自己需要的内容(我这里截取问题，以及下面的回答)</p><p> </p><h3>2.爬取网页源码</h3><pre class="has"><code class="hljs language-java">import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;public class Spider {    /**     * @auther: Ragty     * @describe: 爬虫爬取网页源码     * @param: [url]     * @return: java.lang.String     * @date: 2019/1/23     */    public static String getSource (String url) {        BufferedReader reader = null;        String result = "";        try {            URL realurl = new URL(url);            URLConnection conn = realurl.openConnection();        //连接外部url            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));            String line = "";            while ( (line = reader.readLine()) != null ) {                result += line;            }            if (reader != null) {                reader.close();            }        } catch (Exception e) {            e.printStackTrace();        }        return result;    }​    }</code></pre><p> </p><h3>3.抓取规则及实体类</h3><pre class="has"><code class="hljs language-java">import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import JavaSpider.spider.Spider;public class Imooc {    public String question;    public String quesUrl;    public String quesDescription;    public Map&lt;String,String&gt; answers;    public String nextUrl;    /**     * @auther: Ragty     * @describe: 爬取慕课问答界面的问题及回答     * @param: [url]     * @return:     * @date: 2019/1/23     */    public Imooc(String url) {        question="";        quesUrl=url;        quesDescription="";        answers = new HashMap&lt;String,String&gt;();        nextUrl="";        //获取单个问题页面源码        String codeSource = Spider.getSource(url);        //正则获取question        Pattern pattern=Pattern.compile("js-qa-wenda-title.+?&gt;(.+?)&lt;/h1&gt;");        Matcher matcher=pattern.matcher(codeSource);        if(matcher.find()){            question = matcher.group(1);        }        //正则表达式获取问题描述        pattern=Pattern.compile("js-qa-wenda.+?rich-text\"&gt;(.+?)&lt;/div&gt;");        matcher=pattern.matcher(codeSource);        if(matcher.find()){            quesDescription = matcher.group(1).replace("&lt;p&gt;", "").replace("&lt;/p&gt;", "");        }        //正则表达式获取答案列表        pattern=Pattern.compile("nickname.+?&gt;(.+?)&lt;/a&gt;.+?answer-desc rich-text aimgPreview.+?&gt;(.+?)&lt;/div&gt;");        matcher=pattern.matcher(codeSource);        while(matcher.find()){            String answer = matcher.group(2).replace("&lt;p&gt;", "");            answer = answer.replace("&lt;/p&gt;", "");            answer = answer.replace("&lt;br /&gt;", "");            String name = matcher.group(1);            answers.put(name.trim(), answer.trim());        }        //正则表达式获取下一个url    爬取获取相关问题的url        pattern=Pattern.compile("class=\"r relwenda\".+?href=\"(.+?)\".+?&lt;/a&gt;");//获取回答者name        matcher=pattern.matcher(codeSource);        while(matcher.find()){            nextUrl="http://www.imooc.com"+matcher.group(1);            //只取第一个推荐            if(!nextUrl.equals(quesUrl)){                break;            }        }    }    @Override    public String toString() {        return "问题为:"+ question +"\n问题地址为:"+quesUrl+                "\n问题的表述为:"+quesDescription+"\n"                + "回答的内容为:"+answers+"\n指向下一个链接地址为:"+nextUrl+"\n";    }}</code></pre><p> </p><h3>3.抓取测试类</h3><pre class="has"><code class="hljs language-java">package JavaSpider.main;import JavaSpider.bean.Imooc;public class Main {    public static void main(String[] args) {        String url = "http://www.imooc.com/wenda/detail/351144";        Imooc imooc;        for(int i=0; i&lt;5;i++){            imooc = new Imooc(url);            url = imooc.nextUrl;            System.out.println(imooc);        }    }}</code></pre><p> </p><h3>4.测试网站原样</h3><p>测试网址：<a href="http://www.imooc.com/wenda/detail/351144" target="_blank" rel="noopener">http://www.imooc.com/wenda/detail/351144</a></p><p><br /></p><h3>5. 测试效果 </h3><pre class="has"><code class="hljs language-java">问题为:为啥要做程序员，初心是什么？问题地址为:http://www.imooc.com/wenda/detail/351144问题的表述为:                        如题&lt;br /&gt;                    回答的内容为:{慕粉1043575294=一位大牛曾经说过：“我以前原本以为计算机是一个很好的工具，但我真正了解它我才发现或许它也可以像我们一样拥有生命！我想让她活过来。”(我没那么高的逼格，当初接触这个目的只是为了赚点外快。希望可以帮助迷茫的你), 浩哥辣么帅=专业就是这个，感觉挣得也多，好好学，不会太差，然后就一直做这个了。, Ea_=&lt;pre class="brush:js;toolbar:false"&gt;console.log("%c 为了活着","color:red")&lt;/pre&gt;, 慕尼黑1381709=return "一失足成千古恨", qq_lol_9=为了养的起我的女人，让她过的更好！, 小熊熊HELLO=&lt;strong&gt;听说工资高&lt;/strong&gt;, 不可忍=想跟被人一样装逼, Lani_Carol=&lt;pre class="brush:java;toolbar:false"&gt;System.out.println("可能只是因为一时的突发奇想，选择了这条不归路。所以硬着头皮也要走下去！");&lt;/pre&gt;, 望远=&lt;pre class="brush:bash;toolbar:false"&gt;echo "一切不以赚钱为目的的工作都是在浪费生命！！"&lt;/pre&gt;, 秋名山车神=因为想学黑客技术, 程序蒜=&lt;pre class="brush:php;toolbar:false;"&gt;for (i=1; i&amp;lt;=999999999999999999999999999999999999999; i++) {        echo "被逼的！";}&lt;/pre&gt;, Caballarii=赚钱，装什么高大上, 慕村1106498=&lt;pre class="brush:php;toolbar:false"&gt;&amp;lt;?php    echo "I Love PHP";?&amp;gt;&lt;/pre&gt;, 萧俊介=&lt;pre class="brush:php;toolbar:false"&gt;echo "为了找个合理的理由穿女装！"&lt;/pre&gt;, 江户川秋风=为了毛爷爷, 天使之翼死神之镰=心之所向, 慕粉1922268251=&lt;p dir="ltr"&gt;听说能坐办公室。。。, qq_你微笑时好美_04175474=&lt;pre class="brush:java;toolbar:false"&gt;System.out.println("感兴趣")；&lt;/pre&gt;, 加加摩尔=初心还能有啥，小时候游戏玩多了，天天想摸着电脑，长大又觉得黑客很牛逼，然后学了个编程语言天天混迹在温饱线上~, 叫我娜姐=&lt;pre class="brush:js;toolbar:false"&gt;alert("听说是可以坐着上班的，还可以天天玩电脑。");&lt;/pre&gt;}指向下一个链接地址为:http://www.imooc.com/wenda/detail/493069问题为:springboot2.1 引入spring-boot-starter-web时启动报错问题地址为:http://www.imooc.com/wenda/detail/493069问题的表述为:                        idea生成的springboot项目，当pom文件引入spring-boot-starter-web时 启动报错&lt;pre class="brush:java;toolbar:false"&gt;java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [NonLoginAuthenticator[StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]]]    at java.util.concurrent.FutureTask.report(FutureTask.java:122) [na:1.8.0_191]    at java.util.concurrent.FutureTask.get(FutureTask.java:192) [na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:914) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:831) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1382) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1372) [tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) [na:1.8.0_191]    at java.util.concurrent.FutureTask.run(FutureTask.java) [na:1.8.0_191]    at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) [tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:907) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardService.startInternal(StandardService.java:423) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:933) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.startup.Tomcat.start(Tomcat.java:398) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:106) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&amp;lt;init&amp;gt;(TomcatWebServer.java:86) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:415) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:174) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:181) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:154) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:540) [spring-context-5.1.4.RELEASE.jar:5.1.4.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at com.example.demo.DemoApplication.main(DemoApplication.java:10) [classes/:na]Caused by: org.apache.catalina.LifecycleException: Failed to start component [NonLoginAuthenticator[StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]]]    at org.apache.catalina.util.LifecycleBase.handleSubClassException(LifecycleBase.java:441) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:198) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardPipeline.startInternal(StandardPipeline.java:181) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5041) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1382) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1372) [tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) [na:1.8.0_191]    at java.util.concurrent.FutureTask.run(FutureTask.java) [na:1.8.0_191]    at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) [tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) [na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:907) [tomcat-embed-core-9.0.14.jar:9.0.14]    ... 30 common frames omittedCaused by: java.lang.NoSuchMethodError: javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String;    at org.apache.catalina.authenticator.AuthenticatorBase.startInternal(AuthenticatorBase.java:1178) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    ... 41 common frames omitted2019-01-21 22:19:30.303 ERROR 30556 --- [           main] org.apache.catalina.core.ContainerBase   : A child container failed during startjava.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: A child container failed during start    at java.util.concurrent.FutureTask.report(FutureTask.java:122) ~[na:1.8.0_191]    at java.util.concurrent.FutureTask.get(FutureTask.java:192) ~[na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:914) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardService.startInternal(StandardService.java:423) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:933) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.startup.Tomcat.start(Tomcat.java:398) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:106) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&amp;lt;init&amp;gt;(TomcatWebServer.java:86) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:415) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:174) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:181) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:154) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:540) [spring-context-5.1.4.RELEASE.jar:5.1.4.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) [spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]    at com.example.demo.DemoApplication.main(DemoApplication.java:10) [classes/:na]Caused by: org.apache.catalina.LifecycleException: A child container failed during start    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:926) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:831) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1382) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1372) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_191]    at java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_191]    at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:907) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    ... 21 common frames omittedCaused by: java.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException: Failed to start component [NonLoginAuthenticator[StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]]]    at java.util.concurrent.FutureTask.report(FutureTask.java:122) ~[na:1.8.0_191]    at java.util.concurrent.FutureTask.get(FutureTask.java:192) ~[na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:914) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    ... 30 common frames omittedCaused by: org.apache.catalina.LifecycleException: Failed to start component [NonLoginAuthenticator[StandardEngine[Tomcat].StandardHost[localhost].TomcatEmbeddedContext[]]]    at org.apache.catalina.util.LifecycleBase.handleSubClassException(LifecycleBase.java:441) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:198) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardPipeline.startInternal(StandardPipeline.java:181) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5041) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1382) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1372) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266) ~[na:1.8.0_191]    at java.util.concurrent.FutureTask.run(FutureTask.java) ~[na:1.8.0_191]    at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) ~[na:1.8.0_191]    at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:907) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    ... 30 common frames omittedCaused by: java.lang.NoSuchMethodError: javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String;    at org.apache.catalina.authenticator.AuthenticatorBase.startInternal(AuthenticatorBase.java:1178) ~[tomcat-embed-core-9.0.14.jar:9.0.14]    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) [tomcat-embed-core-9.0.14.jar:9.0.14]    ... 41 common frames omittedDisconnected from the target VM, address: '127.0.0.1:57321', transport: 'socket'2019-01-21 22:19:30.321  INFO 30556 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]2019-01-21 22:19:30.322  WARN 30556 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat2019-01-21 22:19:30.322  INFO 30556 --- [           main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2019-01-21 22:19:30.333 ERROR 30556 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : ***************************APPLICATION FAILED TO START***************************Description:An attempt was made to call the method javax.servlet.ServletContext.getVirtualServerName()Ljava/lang/String; but it does not exist. Its class, javax.servlet.ServletContext, is available from the following locations:    jar:file:/C:/Program%20Files%20(x86)/JAVA/JDK/jre/lib/ext/servlet-api.jar!/javax/servlet/ServletContext.class    jar:file:/C:/Mavn/maven-repository/org/apache/tomcat/embed/tomcat-embed-core/9.0.14/tomcat-embed-core-9.0.14.jar!/javax/servlet/ServletContext.classIt was loaded from the following location:    file:/C:/Program%20Files%20(x86)/JAVA/JDK/jre/lib/ext/servlet-api.jarAction:Correct the classpath of your application so that it contains a single, compatible version of javax.servlet.ServletContextProcess finished with exit code 1&lt;/pre&gt;截图为：&lt;br /&gt;&lt;img src="https://img3.mukewang.com/5c45dc8a0001b44c05000236.jpg" title="" alt="https://img.mukewang.com/5c45dc8a0001b44c16890797.jpg" /&gt;&lt;img src="https://img3.mukewang.com/5c45dca50001f8e405000250.jpg" title="" alt="https://img.mukewang.com/5c45dca50001f8e417630881.jpg" /&gt;跪求大佬！！！                    回答的内容为:{阿尔法a=你按照我下面的步骤来一遍，应该没问题的。&lt;img src="https://img1.mukewang.com/5c45f4c200016d1d05000353.jpg" title="" alt="https://img3.mukewang.com/5c45f4c200016d1d08350588.jpg" /&gt;&lt;img src="https://img2.mukewang.com/5c45f5370001bd1605000472.jpg" title="" alt="https://img3.mukewang.com/5c45f5370001bd1610330975.jpg" /&gt;&lt;img src="https://img2.mukewang.com/5c45f5210001323a05000472.jpg" title="" alt="https://img3.mukewang.com/5c45f5210001323a10330975.jpg" /&gt;&lt;img src="https://img1.mukewang.com/5c45f5510001fe2005000472.jpg" title="" alt="https://img2.mukewang.com/5c45f5510001fe2010330975.jpg" /&gt;&lt;img src="https://img.mukewang.com/5c45f5ac000176e805000271.jpg" title="" alt="https://img1.mukewang.com/5c45f5ac000176e819201039.jpg" /&gt;如果成功了，希望采纳，互相获得积分。下面是我的pom.xml文件，你可以对比一下。如果还有问题，在这里回复我。&lt;pre class="brush:xml;toolbar:false"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&amp;gt;   &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;   &amp;lt;parent&amp;gt;      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;      &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;      &amp;lt;version&amp;gt;2.1.2.RELEASE&amp;lt;/version&amp;gt;      &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;   &amp;lt;/parent&amp;gt;   &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;   &amp;lt;artifactId&amp;gt;demo&amp;lt;/artifactId&amp;gt;   &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;   &amp;lt;name&amp;gt;demo&amp;lt;/name&amp;gt;   &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;   &amp;lt;properties&amp;gt;      &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;   &amp;lt;/properties&amp;gt;   &amp;lt;dependencies&amp;gt;      &amp;lt;dependency&amp;gt;         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;         &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;      &amp;lt;/dependency&amp;gt;      &amp;lt;dependency&amp;gt;         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;         &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;         &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;      &amp;lt;/dependency&amp;gt;   &amp;lt;/dependencies&amp;gt;   &amp;lt;build&amp;gt;      &amp;lt;plugins&amp;gt;         &amp;lt;plugin&amp;gt;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;            &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;         &amp;lt;/plugin&amp;gt;      &amp;lt;/plugins&amp;gt;   &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;&lt;/pre&gt;, qq_沉稳_3=加了tomcat之后报错&lt;img src="https://img2.mukewang.com/5c46e4ad000104b705000273.jpg" title="" alt="https://img4.mukewang.com/5c46e4ad000104b719201048.jpg" /&gt;}指向下一个链接地址为:http://www.imooc.com/wenda/detail/493284问题为:如何成功的连接到数据库中？问题地址为:http://www.imooc.com/wenda/detail/493284问题的表述为:                        &lt;img src="https://img3.mukewang.com/5c46e3cb00011e4305000167.jpg" title="" alt="https://img2.mukewang.com/5c46e3cb00011e4311090369.jpg" /&gt;没办法和老师一样在数据库中成功的建表，还望大牛指点一下子，万分感谢！！                    回答的内容为:{阿尔法a=首先看一下你的本地数据库账号密码对不对，然后在resources下新建一个application-dev.yml，把jpa和DataSource的配置放在这个文档里&lt;img src="https://img1.mukewang.com/5c46f7770001115103630215.jpg" title="" alt="https://img.mukewang.com/5c46f7770001115103630215.jpg" /&gt;, 比格Pick=&lt;img src="https://img.mukewang.com/5c47c19300014e8c05000363.jpg" title="" alt="https://img1.mukewang.com/5c47c19300014e8c09400682.jpg" /&gt;密码与·账户是正确的 ，也新建了一个application.dev.yml,但是还是没有建表成功}指向下一个链接地址为:http://www.imooc.com/wenda/detail/493069</code></pre><p> </p><p>   </p><p> </p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现AES加密解密</title>
      <link href="/blog/2019/01/18/Java%E5%AE%9E%E7%8E%B0AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/blog/2019/01/18/Java%E5%AE%9E%E7%8E%B0AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1. 什么是AES</h3><p><strong>高级加密标准</strong>（英语：<strong>Advanced Encryption Standard</strong>，缩写：<strong>AES</strong>），是一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p><p>那么为什么原来的DES会被取代呢，原因就在于其使用56位密钥，比较容易被破解。而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，更不用说去破解采用256位密钥长度的AES算法了。</p><p> </p><h3>2. AES加密</h3><pre class="has"><code class="hljs language-java">    /*     * @auther: Ragty     * @describe: AES加密     * @param: [content, password]     * @return: byte[]     * @date: 2019/1/18     */    public static String encrypt(String content, String password) {        try {            KeyGenerator kgen = KeyGenerator.getInstance("AES");            // 创建AES的Key生产者            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");            random.setSeed(password.getBytes());            kgen.init(128, random);                                         // 利用用户密码作为随机数初始化出(密码一样，就可以解密)            SecretKey secretKey = kgen.generateKey();                       // 根据用户密码，生成一个密钥            byte[] enCodeFormat = secretKey.getEncoded();                   // 返回基本编码格式的密钥，如果此密钥不支持编码，则返回null            SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");     // 转换为AES专用密钥            Cipher cipher = Cipher.getInstance("AES");                      // 创建密码器            byte[] byteContent = content.getBytes("utf-8");                 // 设置转换格式            cipher.init(Cipher.ENCRYPT_MODE, key);                          // 初始化为加密模式的密码器            byte[] encrypt = cipher.doFinal(byteContent);                   // 加密            String result = parseByte2HexStr(encrypt);                      // 防止乱码，转换进制            return result;        } catch (Exception e) {            e.printStackTrace();        }        return null;    }</code></pre><p> </p><h3>2. AES解密</h3><p> </p><pre class="has"><code class="hljs language-java">/**     * @auther: Ragty     * @describe: AES解密器     * @param: [content, password]     * @return: byte[]     * @date: 2019/1/18     */    public static String decrypt(String content, String password) {        try {            KeyGenerator kgen = KeyGenerator.getInstance("AES");            // 创建AES的Key生产者            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");            random.setSeed(password.getBytes());            kgen.init(128, random);                                         // 利用用户密码作为随机数初始化出(密码一样，就可以解密)            SecretKey secretKey = kgen.generateKey();                       // 根据用户密码，生成一个密钥            byte[] enCodeFormat = secretKey.getEncoded();                   // 返回基本编码格式的密钥，如果此密钥不支持编码，则返回null            SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");     // 转换为AES专用密钥            Cipher cipher = Cipher.getInstance("AES");                      // 创建密码器            cipher.init(Cipher.DECRYPT_MODE, key);                          // 初始化为解密模式的密码器            byte[] results = cipher.doFinal(parseHexStr2Byte(content));     // 解密            return new String(results);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }</code></pre><p> </p><h3>4. 进制转换工具（不进行进制转换会出现乱码）</h3><pre class="has"><code class="hljs language-java">/*     * @auther: Ragty     * @describe: 将二进制转换为十六进制     * @param: [buf]     * @return: java.lang.String     * @date: 2019/1/18     */    private static String parseByte2HexStr(byte buf[]) {        StringBuffer sb = new StringBuffer();        for (int i = 0; i &lt; buf.length; i++) {            String hex = Integer.toHexString(buf[i] &amp; 0xFF);            if (hex.length() == 1) {                hex = '0' + hex;            }            sb.append(hex.toUpperCase());        }        return sb.toString();    }    /**     * @auther: Ragty     * @describe: 十六进制转换二进制     * @param: [hexStr]     * @return: byte[]     * @date: 2019/1/18     */    private static byte[] parseHexStr2Byte(String hexStr) {        if (hexStr.length() &lt; 1)            return null;        byte[] result = new byte[hexStr.length()/2];        for (int i = 0;i&lt; hexStr.length()/2; i++) {            int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);            int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);            result[i] = (byte) (high * 16 + low);        }        return result;    }</code></pre><p> </p><h3>5. 测试程序</h3><pre class="has"><code class="hljs language-java">public static void main(String[] args) {        String content = "AES 测试";        String password = "2019";        String result = encrypt(content,password);        String decrypt = decrypt(result,password);        System.out.println("加密前:" + content);        System.out.println("加密后:" + result);        System.out.println("解密后:" + decrypt);    }</code></pre><h3>6. 测试结果 </h3><pre class="has"><code class="hljs language-java">加密前:AES 测试加密后:E385F2B1B2BED8898C8A9D92F41BD637解密后:AES 测试</code></pre><p> </p><p> </p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AES加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java模拟Http请求远程接口</title>
      <link href="/blog/2019/01/16/Java%E6%A8%A1%E6%8B%9FHttp%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/blog/2019/01/16/Java%E6%A8%A1%E6%8B%9FHttp%E8%AF%B7%E6%B1%82%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>     最近业务需要请求远程API接口，并返回相应的数据，同步到公司的服务器。因此编写了下面两个方法，主要是用Java.net.URL模拟http请求，主要写了POST和GET两个方法。</p><h3>1.GET请求</h3><pre class="has"><code class="language-java">/*     * @auther: Ragty     * @describe: Get请求远程接口     * @param: [url, parameters]     * @return: java.lang.String     * @date: 2019/1/16     */    public static String sendGet(String url, Map&lt;String, String&gt; parameters) {        String result="";        BufferedReader in = null;// 读取响应输入流        StringBuffer sb = new StringBuffer();// 存储参数        String params = "";// 编码之后的参数        try {            // 编码请求参数            if(parameters.size()==1){                for(String name:parameters.keySet()){                    sb.append(name).append("=").append(java.net.URLEncoder.encode(parameters.get(name), "UTF-8"));                }                params=sb.toString();            }else{                for (String name : parameters.keySet()) {                    sb.append(name).append("=").append(java.net.URLEncoder.encode(parameters.get(name), "UTF-8")).append("&amp;");                }                String temp_params = sb.toString();                params = temp_params.substring(0, temp_params.length() - 1);            }            String full_url = url + "?" + params;            System.out.println("请求链接为:"+full_url);            // 创建URL对象            URL connURL = new java.net.URL(full_url);            // 打开URL连接            HttpURLConnection httpConn = (java.net.HttpURLConnection) connURL.openConnection();            // 设置通用属性            httpConn.setRequestProperty("Accept", "*/*");            httpConn.setRequestProperty("Connection", "Keep-Alive");            httpConn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)");            // 建立实际的连接            httpConn.connect();            // 响应头部获取            Map&lt;String, List&lt;String&gt;&gt; headers = httpConn.getHeaderFields();            // 遍历所有的响应头字段            for (String key : headers.keySet()) {                System.out.println(key + "\t：\t" + headers.get(key));            }            // 定义BufferedReader输入流来读取URL的响应,并设置编码方式            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), "UTF-8"));            String line;            // 读取返回的内容            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            e.printStackTrace();        }finally{            try {                if (in != null) { in.close(); }            } catch (IOException ex) {                ex.printStackTrace();            }        }        return result ;    }</code></pre><p> </p><h3>2.POST请求</h3><pre class="has"><code class="language-java">/*     * @auther: Ragty     * @describe: Post请求远程接口     * @param: [url, parameters]     * @return: java.lang.String     * @date: 2019/1/16     */    public static String sendPost(String url, Map&lt;String, String&gt; parameters) {        String result = "";// 返回的结果        BufferedReader in = null;// 读取响应输入流        PrintWriter out = null;        StringBuffer sb = new StringBuffer();// 处理请求参数        String params = "";// 编码之后的参数        try {            // 编码请求参数            if (parameters.size() == 1) {                for (String name : parameters.keySet()) {                    sb.append(name).append("=").append(java.net.URLEncoder.encode(parameters.get(name), "UTF-8"));                }                params = sb.toString();            } else {                for (String name : parameters.keySet()) {                    sb.append(name).append("=").append(java.net.URLEncoder.encode(parameters.get(name), "UTF-8")).append("&amp;");                }                String temp_params = sb.toString();                params = temp_params.substring(0, temp_params.length() - 1);            }            // 创建URL对象            URL connURL = new URL(url);            // 打开URL连接            HttpURLConnection httpConn = (java.net.HttpURLConnection) connURL.openConnection();            // 设置通用属性            httpConn.setRequestProperty("Accept", "*/*");            httpConn.setRequestProperty("Connection", "Keep-Alive");            httpConn.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)");            // 设置POST方式            httpConn.setDoInput(true);            httpConn.setDoOutput(true);            // 获取HttpURLConnection对象对应的输出流            out = new PrintWriter(httpConn.getOutputStream());            // 发送请求参数            out.write(params);            // flush输出流的缓冲            out.flush();            // 定义BufferedReader输入流来读取URL的响应，设置编码方式            in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), "UTF-8"));            String line;            // 读取返回的内容            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                if (out != null) { out.close(); }                if (in != null) { in.close(); }            } catch (IOException ex) {                ex.printStackTrace();            }        }        return result;    }</code></pre><p> </p><h3>3.结果测试</h3><pre class="has"><code class="language-java">public static void main(String[] args) {        Map&lt;String,String&gt; request = new HashMap&lt;String,String&gt;();        request.put("name","ragty");        String result = sendGet("https://www.baidu.com",request);        System.out.println(result);    }</code></pre><p> </p><h3>4.输出结果 </h3><pre class="has"><code>请求链接为:https://www.baidu.com?name=ragtynull    ：    [HTTP/1.1 200 OK]Server    ：    [BWS/1.1]X-Ua-Compatible    ：    [IE=Edge,chrome=1]Connection    ：    [Keep-Alive]Pragma    ：    [no-cache]Last-Modified    ：    [Thu, 10 Jan 2019 04:12:20 GMT]P3p    ：    [CP=" OTI DSP COR IVA OUR IND COM "]Date    ：    [Wed, 16 Jan 2019 12:29:01 GMT]Accept-Ranges    ：    [bytes]Etag    ：    ["5c36c624-3982"]Cache-Control    ：    [no-cache]Vary    ：    [Accept-Encoding]Set-Cookie    ：    [PSTM=1547641741; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, BIDUPSID=A341E15B4265ABB6D36D7938804110FE; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, BAIDUID=A341E15B4265ABB6D36D7938804110FE:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com]Content-Length    ：    [14722]Content-Type    ：    [text/html]&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;    &lt;link rel="dns-prefetch" href="//s1.bdstatic.com"/&gt;    &lt;link rel="dns-prefetch" href="//t1.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//t2.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//t3.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//t10.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//t11.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//t12.baidu.com"/&gt;    &lt;link rel="dns-prefetch" href="//b1.bdstatic.com"/&gt;    &lt;title&gt;百度一下，你就知道&lt;/title&gt;    &lt;link href="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/home/css/index.css" rel="stylesheet" type="text/css" /&gt;    &lt;!--[if lte IE 8]&gt;&lt;style index="index" &gt;#content{height:480px\9}#m{top:260px\9}&lt;/style&gt;&lt;![endif]--&gt;    &lt;!--[if IE 8]&gt;&lt;style index="index" &gt;#u1 a.mnav,#u1 a.mnav:visited{font-family:simsun}&lt;/style&gt;&lt;![endif]--&gt;    &lt;script&gt;var hashMatch = document.location.href.match(/#+(.*wd=[^&amp;].+)/);if (hashMatch &amp;&amp; hashMatch[0] &amp;&amp; hashMatch[1]) {document.location.replace("http://"+location.host+"/s?"+hashMatch[1]);}var ns_c = function(){};&lt;/script&gt;    &lt;script&gt;function h(obj){obj.style.behavior='url(#default#homepage)';var a = obj.setHomePage('//www.baidu.com/');}&lt;/script&gt;    &lt;noscript&gt;&lt;meta http-equiv="refresh" content="0; url=/baidu.html?from=noscript"/&gt;&lt;/noscript&gt;    &lt;script&gt;window._ASYNC_START=new Date().getTime();&lt;/script&gt;&lt;/head&gt;&lt;body link="#0000cc"&gt;&lt;div id="wrapper" style="display:none;"&gt;&lt;div id="u"&gt;&lt;a href="//www.baidu.com/gaoji/preferences.html"  onmousedown="return user_c({'fm':'set','tab':'setting','login':'0'})"&gt;搜索设置&lt;/a&gt;|&lt;a id="btop" href="/"  onmousedown="return user_c({'fm':'set','tab':'index','login':'0'})"&gt;百度首页&lt;/a&gt;|&lt;a id="lb" href="https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F" onclick="return false;"  onmousedown="return user_c({'fm':'set','tab':'login'})"&gt;登录&lt;/a&gt;&lt;a href="https://passport.baidu.com/v2/?reg&amp;regType=1&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F"  onmousedown="return user_c({'fm':'set','tab':'reg'})" target="_blank" class="reg"&gt;注册&lt;/a&gt;&lt;/div&gt;&lt;div id="head"&gt;&lt;div class="s_nav"&gt;&lt;a href="/" class="s_logo" onmousedown="return c({'fm':'tab','tab':'logo'})"&gt;&lt;img src="//www.baidu.com/img/baidu_jgylogo3.gif" width="117" height="38" border="0" alt="到百度首页" title="到百度首页"&gt;&lt;/a&gt;&lt;div class="s_tab" id="s_tab"&gt;&lt;a href="http://news.baidu.com/ns?cl=2&amp;rn=20&amp;tn=news&amp;word=" wdfield="word"  onmousedown="return c({'fm':'tab','tab':'news'})"&gt;新闻&lt;/a&gt;&amp;#12288;&lt;b&gt;网页&lt;/b&gt;&amp;#12288;&lt;a href="http://tieba.baidu.com/f?kw=&amp;fr=wwwt" wdfield="kw"  onmousedown="return c({'fm':'tab','tab':'tieba'})"&gt;贴吧&lt;/a&gt;&amp;#12288;&lt;a href="http://zhidao.baidu.com/q?ct=17&amp;pn=0&amp;tn=ikaslist&amp;rn=10&amp;word=&amp;fr=wwwt" wdfield="word"  onmousedown="return c({'fm':'tab','tab':'zhidao'})"&gt;知道&lt;/a&gt;&amp;#12288;&lt;a href="http://music.baidu.com/search?fr=ps&amp;key=" wdfield="key"  onmousedown="return c({'fm':'tab','tab':'music'})"&gt;音乐&lt;/a&gt;&amp;#12288;&lt;a href="http://image.baidu.com/i?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;word=" wdfield="word"  onmousedown="return c({'fm':'tab','tab':'pic'})"&gt;图片&lt;/a&gt;&amp;#12288;&lt;a href="http://v.baidu.com/v?ct=301989888&amp;rn=20&amp;pn=0&amp;db=0&amp;s=25&amp;word=" wdfield="word"   onmousedown="return c({'fm':'tab','tab':'video'})"&gt;视频&lt;/a&gt;&amp;#12288;&lt;a href="http://map.baidu.com/m?word=&amp;fr=ps01000" wdfield="word"  onmousedown="return c({'fm':'tab','tab':'map'})"&gt;地图&lt;/a&gt;&amp;#12288;&lt;a href="http://wenku.baidu.com/search?word=&amp;lm=0&amp;od=0" wdfield="word"  onmousedown="return c({'fm':'tab','tab':'wenku'})"&gt;文库&lt;/a&gt;&amp;#12288;&lt;a href="//www.baidu.com/more/"  onmousedown="return c({'fm':'tab','tab':'more'})"&gt;更多?&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;form id="form" name="f" action="/s" class="fm" &gt;&lt;input type="hidden" name="ie" value="utf-8"&gt;&lt;input type="hidden" name="f" value="8"&gt;&lt;input type="hidden" name="rsv_bp" value="1"&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input name="wd" id="kw" class="s_ipt" value="" maxlength="100"&gt;&lt;/span&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type="submit" id="su" value="百度一下" class="bg s_btn" onmousedown="this.className='bg s_btn s_btn_h'" onmouseout="this.className='bg s_btn'"&gt;&lt;/span&gt;&lt;span class="tools"&gt;&lt;span id="mHolder"&gt;&lt;div id="mCon"&gt;&lt;span&gt;输入法&lt;/span&gt;&lt;/div&gt;&lt;ul id="mMenu"&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_hw"&gt;手写&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_py"&gt;拼音&lt;/a&gt;&lt;/li&gt;&lt;li class="ln"&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_cl"&gt;关闭&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;&lt;span class="shouji"&gt;&lt;strong&gt;推荐&amp;nbsp;:&amp;nbsp;&lt;/strong&gt;&lt;a href="http://w.x.baidu.com/go/mini/8/10000020" onmousedown="return ns_c({'fm':'behs','tab':'bdbrowser'})"&gt;百度浏览器，打开网页快2秒！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/form&gt;&lt;/div&gt;&lt;div id="content"&gt;&lt;div id="u1"&gt;&lt;a href="http://news.baidu.com" name="tj_trnews" class="mnav"&gt;新闻&lt;/a&gt;&lt;a href="http://www.hao123.com" name="tj_trhao123" class="mnav"&gt;hao123&lt;/a&gt;&lt;a href="http://map.baidu.com" name="tj_trmap" class="mnav"&gt;地图&lt;/a&gt;&lt;a href="http://v.baidu.com" name="tj_trvideo" class="mnav"&gt;视频&lt;/a&gt;&lt;a href="http://tieba.baidu.com" name="tj_trtieba" class="mnav"&gt;贴吧&lt;/a&gt;&lt;a href="https://passport.baidu.com/v2/?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2F" name="tj_login" id="lb" onclick="return false;"&gt;登录&lt;/a&gt;&lt;a href="//www.baidu.com/gaoji/preferences.html" name="tj_settingicon" id="pf"&gt;设置&lt;/a&gt;&lt;a href="//www.baidu.com/more/" name="tj_briicon" id="bri"&gt;更多产品&lt;/a&gt;&lt;/div&gt;&lt;div id="m"&gt;&lt;p id="lg"&gt;&lt;img src="//www.baidu.com/img/bd_logo.png" width="270" height="129"&gt;&lt;/p&gt;&lt;p id="nv"&gt;&lt;a href="http://news.baidu.com"&gt;新&amp;nbsp;闻&lt;/a&gt;　&lt;b&gt;网&amp;nbsp;页&lt;/b&gt;　&lt;a href="http://tieba.baidu.com"&gt;贴&amp;nbsp;吧&lt;/a&gt;　&lt;a href="http://zhidao.baidu.com"&gt;知&amp;nbsp;道&lt;/a&gt;　&lt;a href="http://music.baidu.com"&gt;音&amp;nbsp;乐&lt;/a&gt;　&lt;a href="http://image.baidu.com"&gt;图&amp;nbsp;片&lt;/a&gt;　&lt;a href="http://v.baidu.com"&gt;视&amp;nbsp;频&lt;/a&gt;　&lt;a href="http://map.baidu.com"&gt;地&amp;nbsp;图&lt;/a&gt;&lt;/p&gt;&lt;div id="fm"&gt;&lt;form id="form1" name="f1" action="/s" class="fm"&gt;&lt;span class="bg s_ipt_wr"&gt;&lt;input type="text" name="wd" id="kw1" maxlength="100" class="s_ipt"&gt;&lt;/span&gt;&lt;input type="hidden" name="rsv_bp" value="0"&gt;&lt;input type=hidden name=ch value=""&gt;&lt;input type=hidden name=tn value="baidu"&gt;&lt;input type=hidden name=bar value=""&gt;&lt;input type="hidden" name="rsv_spt" value="3"&gt;&lt;input type="hidden" name="ie" value="utf-8"&gt;&lt;span class="bg s_btn_wr"&gt;&lt;input type="submit" value="百度一下" id="su1" class="bg s_btn" onmousedown="this.className='bg s_btn s_btn_h'" onmouseout="this.className='bg s_btn'"&gt;&lt;/span&gt;&lt;/form&gt;&lt;span class="tools"&gt;&lt;span id="mHolder1"&gt;&lt;div id="mCon1"&gt;&lt;span&gt;输入法&lt;/span&gt;&lt;/div&gt;&lt;/span&gt;&lt;/span&gt;&lt;ul id="mMenu1"&gt;&lt;div class="mMenu1-tip-arrow"&gt;&lt;em&gt;&lt;/em&gt;&lt;ins&gt;&lt;/ins&gt;&lt;/div&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_hw"&gt;手写&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_py"&gt;拼音&lt;/a&gt;&lt;/li&gt;&lt;li class="ln"&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="javascript:;" name="ime_cl"&gt;关闭&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p id="lk"&gt;&lt;a href="http://baike.baidu.com"&gt;百科&lt;/a&gt;　&lt;a href="http://wenku.baidu.com"&gt;文库&lt;/a&gt;　&lt;a href="http://www.hao123.com"&gt;hao123&lt;/a&gt;&lt;span&gt;&amp;nbsp;|&amp;nbsp;&lt;a href="//www.baidu.com/more/"&gt;更多&amp;gt;&amp;gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p id="lm"&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="ftCon"&gt;&lt;div id="ftConw"&gt;&lt;p id="lh"&gt;&lt;a id="seth" onClick="h(this)" href="/" onmousedown="return ns_c({'fm':'behs','tab':'homepage','pos':0})"&gt;把百度设为主页&lt;/a&gt;&lt;a id="setf" href="//www.baidu.com/cache/sethelp/index.html" onmousedown="return ns_c({'fm':'behs','tab':'favorites','pos':0})" target="_blank"&gt;把百度设为主页&lt;/a&gt;&lt;a onmousedown="return ns_c({'fm':'behs','tab':'tj_about'})" href="http://home.baidu.com"&gt;关于百度&lt;/a&gt;&lt;a onmousedown="return ns_c({'fm':'behs','tab':'tj_about_en'})" href="http://ir.baidu.com"&gt;About Baidu&lt;/a&gt;&lt;/p&gt;&lt;p id="cp"&gt;&amp;copy;2018&amp;nbsp;Baidu&amp;nbsp;&lt;a href="/duty/" name="tj_duty"&gt;使用百度前必读&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp;&lt;img src="http://s1.bdstatic.com/r/www/cache/static/global/img/gs_237f015b.gif"&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="wrapper_wrapper"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="c-tips-container" id="c-tips-container"&gt;&lt;/div&gt;&lt;script&gt;window.__async_strategy=2;&lt;/script&gt;&lt;script&gt;var bds={se:{},su:{urdata:[],urSendClick:function(){}},util:{},use:{},comm : {domain:"http://www.baidu.com",ubsurl : "http://sclick.baidu.com/w.gif",tn:"baidu",queryEnc:"",queryId:"",inter:"",templateName:"baidu",sugHost : "http://suggestion.baidu.com/su",query : "",qid : "",cid : "",sid : "",indexSid : "",stoken : "",serverTime : "",user : "",username : "",loginAction : [],useFavo : "",pinyin : "",favoOn : "",curResultNum:"",rightResultExist:false,protectNum:0,zxlNum:0,pageNum:1,pageSize:10,newindex:0,async:1,maxPreloadThread:5,maxPreloadTimes:10,preloadMouseMoveDistance:5,switchAddMask:false,isDebug:false,ishome : 1},_base64:{domain : "http://b1.bdstatic.com/",b64Exp : -1,pdc : 0}};var name,navigate,al_arr=[];var selfOpen = window.open;eval("var open = selfOpen;");var isIE=navigator.userAgent.indexOf("MSIE")!=-1&amp;&amp;!window.opera;var E = bds.ecom= {};bds.se.mon = {'loadedItems':[],'load':function(){},'srvt':-1};try {bds.se.mon.srvt = parseInt(document.cookie.match(new RegExp("(^| )BDSVRTM=([^;]*)(;|$)"))[2]);document.cookie="BDSVRTM=;expires=Sat, 01 Jan 2000 00:00:00 GMT"; }catch(e){}&lt;/script&gt;&lt;script&gt;if(!location.hash.match(/[^a-zA-Z0-9]wd=/)){document.getElementById("ftCon").style.display='block';document.getElementById("u1").style.display='block';document.getElementById("content").style.display='block';document.getElementById("wrapper").style.display='block';setTimeout(function(){try{document.getElementById("kw1").focus();document.getElementById("kw1").parentNode.className += ' iptfocus';}catch(e){}},0);}&lt;/script&gt;&lt;script type="text/javascript" src="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/jquery/jquery-1.10.2.min_f2fb5194.js"&gt;&lt;/script&gt;&lt;script&gt;(function(){var index_content = $('#content');var index_foot= $('#ftCon');var index_css= $('head [index]');var index_u= $('#u1');var result_u= $('#u');var wrapper=$("#wrapper");window.index_on=function(){index_css.insertAfter("meta:eq(0)");result_common_css.remove();result_aladdin_css.remove();result_sug_css.remove();index_content.show();index_foot.show();index_u.show();result_u.hide();wrapper.show();if(bds.su&amp;&amp;bds.su.U&amp;&amp;bds.su.U.homeInit){bds.su.U.homeInit();}setTimeout(function(){try{$('#kw1').get(0).focus();window.sugIndex.start();}catch(e){}},0);if(typeof initIndex=='function'){initIndex();}};window.index_off=function(){index_css.remove();index_content.hide();index_foot.hide();index_u.hide();result_u.show();result_aladdin_css.insertAfter("meta:eq(0)");result_common_css.insertAfter("meta:eq(0)");result_sug_css.insertAfter("meta:eq(0)");wrapper.show();};})();&lt;/script&gt;&lt;script&gt;window.__switch_add_mask=1;&lt;/script&gt;&lt;script type="text/javascript" src="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/global/js/instant_search_newi_redirect1_20bf4036.js"&gt;&lt;/script&gt;&lt;script&gt;initPreload();$("#u,#u1").delegate("#lb",'click',function(){try{bds.se.login.open();}catch(e){}});if(navigator.cookieEnabled){document.cookie="NOJS=;expires=Sat, 01 Jan 2000 00:00:00 GMT";}&lt;/script&gt;&lt;script&gt;$(function(){for(i=0;i&lt;3;i++){u($($('.s_ipt_wr')[i]),$($('.s_ipt')[i]),$($('.s_btn_wr')[i]),$($('.s_btn')[i]));}function u(iptwr,ipt,btnwr,btn){if(iptwr &amp;&amp; ipt){iptwr.on('mouseover',function(){iptwr.addClass('ipthover');}).on('mouseout',function(){iptwr.removeClass('ipthover');}).on('click',function(){ipt.focus();});ipt.on('focus',function(){iptwr.addClass('iptfocus');}).on('blur',function(){iptwr.removeClass('iptfocus');}).on('render',function(e){var $s = iptwr.parent().find('.bdsug');var l = $s.find('li').length;if(l&gt;=5){$s.addClass('bdsugbg');}else{$s.removeClass('bdsugbg');}});}if(btnwr &amp;&amp; btn){btnwr.on('mouseover',function(){btn.addClass('btnhover');}).on('mouseout',function(){btn.removeClass('btnhover');});}}});&lt;/script&gt;&lt;script type="text/javascript" src="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/home/js/bri_7f1fa703.js"&gt;&lt;/script&gt;&lt;script&gt;(function(){var _init=false;window.initIndex=function(){if(_init){return;}_init=true;var w=window,d=document,n=navigator,k=d.f1.wd,a=d.getElementById("nv").getElementsByTagName("a"),isIE=n.userAgent.indexOf("MSIE")!=-1&amp;&amp;!window.opera;(function(){if(/q=([^&amp;]+)/.test(location.search)){k.value=decodeURIComponent(RegExp["\x241"])}})();(function(){var u = G("u1").getElementsByTagName("a"), nv = G("nv").getElementsByTagName("a"), lk = G("lk").getElementsByTagName("a"), un = "";var tj_nv = ["news","tieba","zhidao","mp3","img","video","map"];var tj_lk = ["baike","wenku","hao123","more"];un = bds.comm.user == "" ? "" : bds.comm.user;function _addTJ(obj){addEV(obj, "mousedown", function(e){var e = e || window.event;var target = e.target || e.srcElement;if(target.name){ns_c({'fm':'behs','tab':target.name,'un':encodeURIComponent(un)});}});}for(var i = 0; i &lt; u.length; i++){_addTJ(u[i]);}for(var i = 0; i &lt; nv.length; i++){nv[i].name = 'tj_' + tj_nv[i];}for(var i = 0; i &lt; lk.length; i++){lk[i].name = 'tj_' + tj_lk[i];}})();(function() {var links = {'tj_news': ['word', 'http://news.baidu.com/ns?tn=news&amp;cl=2&amp;rn=20&amp;ct=1&amp;ie=utf-8'],'tj_tieba': ['kw', 'http://tieba.baidu.com/f?ie=utf-8'],'tj_zhidao': ['word', 'http://zhidao.baidu.com/search?pn=0&amp;rn=10&amp;lm=0'],'tj_mp3': ['key', 'http://music.baidu.com/search?fr=ps&amp;ie=utf-8'],'tj_img': ['word', 'http://image.baidu.com/i?ct=201326592&amp;cl=2&amp;nc=1&amp;lm=-1&amp;st=-1&amp;tn=baiduimage&amp;istype=2&amp;fm=&amp;pv=&amp;z=0&amp;ie=utf-8'],'tj_video': ['word', 'http://video.baidu.com/v?ct=301989888&amp;s=25&amp;ie=utf-8'],'tj_map': ['wd', 'http://map.baidu.com/?newmap=1&amp;ie=utf-8&amp;s=s'],'tj_baike': ['word', 'http://baike.baidu.com/search/word?pic=1&amp;sug=1&amp;enc=utf8'],'tj_wenku': ['word', 'http://wenku.baidu.com/search?ie=utf-8']};var domArr = [G('nv'), G('lk'),G('cp')],kw = G('kw1');for (var i = 0, l = domArr.length; i &lt; l; i++) {domArr[i].onmousedown = function(e) {e = e || window.event;var target = e.target || e.srcElement,name = target.getAttribute('name'),items = links[name],reg = new RegExp('^\\s+|\\s+\x24'),key = kw.value.replace(reg, '');if (items) {if (key.length &gt; 0) {var wd = items[0], url = items[1],url = url + ( name === 'tj_map' ? encodeURIComponent('&amp;' + wd + '=' + key) : ( ( url.indexOf('?') &gt; 0 ? '&amp;' : '?' ) + wd + '=' + encodeURIComponent(key) ) );target.href = url;} else {target.href = target.href.match(new RegExp('^http:\/\/.+\.baidu\.com'))[0];}}name &amp;&amp; ns_c({'fm': 'behs','tab': name,'query': encodeURIComponent(key),'un': encodeURIComponent(bds.comm.user || '') });};}})();};if(window.pageState==0){initIndex();}})();document.cookie = 'IS_STATIC=1;expires=' + new Date(new Date().getTime() + 10*60*1000).toGMTString();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> </p><p> </p><p> </p><h3> </h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 请求远程接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-查找+思维导图</title>
      <link href="/blog/2018/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/blog/2018/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1.总体架构</h3><p><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/20181202151009318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="850" /></p><p> </p><h3>2.线性结构</h3><p><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/2018120215114243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="850" /></p><p> </p><h3>3.散列结构</h3><p><img alt="" class="has" height="682" src="https://img-blog.csdnimg.cn/20181202151228190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="893" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构查找 </tag>
            
            <tag> 散列结构 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 数据结构思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图结构-思维导图</title>
      <link href="/blog/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%BB%93%E6%9E%84-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/blog/2018/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%BB%93%E6%9E%84-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1.整体结构</h3><p><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/20181201144134899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="850" /></p><p> </p><h3>2.图的相关应用</h3><h3><img alt="" class="has" height="537" src="https://img-blog.csdnimg.cn/20181201144314661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="1200" /> </h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图算法 </tag>
            
            <tag> 最小生成树算法 </tag>
            
            <tag> 最短路径算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树形结构+思维导图</title>
      <link href="/blog/2018/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/blog/2018/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1.整体架构</h3><p><img alt="" class="has" height="542" src="https://img-blog.csdnimg.cn/20181130173349967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="837" /></p><p> </p><h3>2.二叉树的存储结构 </h3><p><img alt="" class="has" height="371" src="https://img-blog.csdnimg.cn/20181130174324823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="800" /></p><p> </p><h3>3.二叉树的操作</h3><p><img alt="" class="has" height="462" src="https://img-blog.csdnimg.cn/20181130174618852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="751" /></p><p> </p><h3>4.二叉树的应用</h3><p><img alt="" class="has" height="673" src="https://img-blog.csdnimg.cn/20181130175255863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="1179" /></p><p> </p><h3>5.树和森林</h3><p><img alt="" class="has" height="590" src="https://img-blog.csdnimg.cn/201811301750508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="850" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 哈夫曼树 </tag>
            
            <tag> 树和森林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈与队列总结-思维导图</title>
      <link href="/blog/2018/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/blog/2018/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3>1.总体架构</h3><p><img alt="" class="has" height="295" src="https://img-blog.csdnimg.cn/20181130104250736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="403" /></p><p> </p><h3>2.栈</h3><p><img alt="" class="has" height="473" src="https://img-blog.csdnimg.cn/20181130104502999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="792" /></p><p> </p><h3>3. 队列</h3><p><img alt="" class="has" height="562" src="https://img-blog.csdnimg.cn/20181130104720742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="789" /></p><p> </p><h3>4.栈与队列的应用</h3><p><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20181130104846505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="791" /></p><p> </p><h3>5.数组与矩阵 </h3><p><img alt="" class="has" height="519" src="https://img-blog.csdnimg.cn/20181130105214774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="793" /></p><p> </p><p> </p><p> </p><p> </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈与队列 </tag>
            
            <tag> 思维导图 </tag>
            
            <tag> 数组与矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构:线性表总结+思维导图</title>
      <link href="/blog/2018/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
      <url>/blog/2018/11/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3><strong>1.总体架构</strong></h3><p><img alt="" class="has" height="663" src="https://img-blog.csdnimg.cn/20181115151245994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="1083" /></p><p> </p><h3><strong>2.顺序存储</strong></h3><h3><img alt="" class="has" height="473" src="https://img-blog.csdnimg.cn/20181115151505199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="929" /><strong> </strong></h3><p><strong>3.链式存储</strong></p><p><img alt="" class="has" height="665" src="https://img-blog.csdnimg.cn/20181115151659386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1,size_16,color_FFFFFF,t_70" width="1095" /></p><p> </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 思维导图 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBKDF2算法Java实现</title>
      <link href="/blog/2018/11/02/PBKDF2%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2018/11/02/PBKDF2%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2>1.加盐处理</h2><blockquote><p>       在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”（比如可以在密码中混入一段“随机”的字符串再进行哈希加密，这个被字符串被称作盐值）。</p></blockquote><h2> </h2><h2>2.为什么要加盐</h2><blockquote><p>      涉及身份验证的系统都需要存储用户的认证信息，常用的用户认证方式主要为用户名和密码的方式，为了安全起见，用户输入的密码需要保存为密文形式，可采用已公开的不可逆的hash加密算法，比如SHA256, SHA512, SHA3等，对于同一密码，同一加密算法会产生相同的hash值，这样，当用户进行身份验证时，也可对用户输入的明文密码应用相同的hash加密算法，得出一个hash值，然后使用该hash值和之前存储好的密文值进行对照，如果两个值相同，则密码认证成功，否则密码认证失败。</p><p>     由于密码是由用户设定的，在实际应用中，用户设置的密码复杂度可能不够高，同时不同的用户极有可能会使用相同的密码，那么这些用户对应的密文也会相同，这样，当存储用户密码的数据库泄露后，攻击者会很容易便能找到相同密码的用户，从而也降低了破解密码的难度，因此，在对用户密码进行加密时，需要考虑对密码进行掩饰，即使是相同的密码，也应该要保存为不同的密文，即使用户输入的是弱密码，也需要考虑进行增强，从而增加密码被攻破的难度，而使用带盐的加密hash值便能满足该需求。</p></blockquote><h2> </h2><h2>3.常用密码攻击方式</h2><blockquote><p> 常用的密码攻击方式有字典攻击、暴力破解、查表法、反向查表法、彩虹表等。</p><p>     对字典攻击和暴力破解，攻击者均采用逐密码尝试的方式，目前没有很好的手段来阻止字典攻击和暴力破解攻击，只能是想办法让这两种攻击方式变得相对低效一些，而相同的密码产生不同的hash值便能让攻击者针对每一个hash值都需要从头进行尝试，从而使攻击变得更加低效。</p><p>      对查表法、反向查表法和彩虹表攻击方式，攻击者需要提前准备好包含密码和密码hash值的密码表，然后根据该表和用户密码数据库进行批量匹配，从而达到攻破密码的目的；而如果我们在加密时，给每个密码附加了不同的随机值，这样每个密码对应的hash值也会不同，这样攻击者在准备密码表时，就必须要将最基本的密码和用户密码数据库中的盐值进行笛卡尔积后再计算hash值，盐值越多，用户需要准备的表量越大，这样对于攻击而言，就变得有些得不偿失了。</p></blockquote><h2> </h2><h2>4. 让密码更难破解（慢哈希函数）</h2><blockquote><p>       加盐使攻击者无法采用特定的查询表和彩虹表快速破解大量哈希值，但是却不能阻止他们使用字典攻击或暴力攻击。高端的显卡（GPU）和定制的硬件可以每秒进行数十亿次哈希计算，因此这类攻击依然可以很高效。为了降低攻击者的效率，我们可以使用一种叫做<strong>密钥扩展</strong>的技术。</p><p>      这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。</p><p>     密钥扩展的实现是依靠一种CPU密集型哈希函数。不要尝试自己发明简单的迭代哈希加密，如果迭代不够多，是可以被高效的硬件快速并行计算出来的，就和普通哈希一样。应该使用标准的算法，比如<a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener">PBKDF2</a>或者<a href="http://en.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a>。这里使用<a href="http://en.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener">PBKDF2</a>实现</p><p>      这类算法使用一个安全因子或迭代次数作为参数，这个值决定了哈希函数会有多慢。对于桌面软件或者手机软件，获取参数最好的办法就是执行一个简短的性能基准测试，找到使哈希函数大约耗费0.5秒的值。这样，你的程序就可以尽可能保证安全，而又不影响到用户体验。</p></blockquote><h2> </h2><h2>5.实现代码 </h2><pre class="has"><code>package com.hwj.util;import org.springframework.stereotype.Component;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import java.math.BigInteger;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.spec.InvalidKeySpecException;import java.security.spec.KeySpec;@Componentpublic class PBKDF2Util {    public static final String PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA1";    public static final int SALT_BYTE_SIZE = 32 / 2;         //盐的长度    public static final int HASH_BIT_SIZE = 128 * 4;         //生成密文的长度    public static final int PBKDF2_ITERATIONS = 1000;        //迭代次数    /**     * @auther: Ragty     * @describe: 对输入的密码进行验证     * @param: [attemptedPassword(待验证密码), encryptedPassword(密文), salt(盐值)]     * @return: boolean     * @date: 2018/11/2     */    public boolean authenticate(String attemptedPassword, String encryptedPassword, String salt)            throws NoSuchAlgorithmException, InvalidKeySpecException {        // 用相同的盐值对用户输入的密码进行加密        String encryptedAttemptedPassword = getEncryptedPassword(attemptedPassword, salt);        // 把加密后的密文和原密文进行比较，相同则验证成功，否则失败        return encryptedAttemptedPassword.equals(encryptedPassword);    }    /**     * @auther: Ragty     * @describe: 生成密文     * @param: [password(明文密码), salt(盐值)]     * @return: java.lang.String     * @date: 2018/11/2     */    public String getEncryptedPassword(String password, String salt) throws NoSuchAlgorithmException,            InvalidKeySpecException {        KeySpec spec = new PBEKeySpec(password.toCharArray(), fromHex(salt), PBKDF2_ITERATIONS, HASH_BIT_SIZE);        SecretKeyFactory f = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);        return toHex(f.generateSecret(spec).getEncoded());    }    /**     * @auther: Ragty     * @describe: 通过加密的强随机数生成盐(最后转换为16进制)     * @param: []     * @return: java.lang.String     * @date: 2018/11/2     */    public String generateSalt() throws NoSuchAlgorithmException {        SecureRandom random = SecureRandom.getInstance("SHA1PRNG");        byte[] salt = new byte[SALT_BYTE_SIZE];        random.nextBytes(salt);        return toHex(salt);    }    /**     * @auther: Ragty     * @describe: 十六进制字符串转二进制字符串     * @param: [hex]     * @return: byte[]     * @date: 2018/11/2     */    private static byte[] fromHex(String hex) {        byte[] binary = new byte[hex.length() / 2];        for (int i = 0; i &lt; binary.length; i++) {            binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);        }        return binary;    }    /**     * @auther: Ragty     * @describe: 二进制字符串转十六进制字符串     * @param: [array]     * @return: java.lang.String     * @date: 2018/11/2     */    private static String toHex(byte[] array) {        BigInteger bi = new BigInteger(1, array);        String hex = bi.toString(16);        int paddingLength = (array.length * 2) - hex.length();        if (paddingLength &gt; 0)            return String.format("%0" + paddingLength + "d", 0) + hex;        else            return hex;    }}</code></pre><h2> </h2><h2>6.单元测试</h2><pre class="has"><code>package com.hwj;import com.hwj.util.MD5Util;import com.hwj.util.PBKDF2Util;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import sun.security.util.Password;@RunWith(SpringRunner.class)@SpringBootTestpublic class SaltTest {    @Autowired    private PBKDF2Util pbkdf2Util;    @Autowired    private MD5Util md5Util;    @Test    public void mailSendTest() throws Exception{        String password = "123456";        String salt = pbkdf2Util.generateSalt();        String pbkdf2 = pbkdf2Util.getEncryptedPassword(password,salt);        String md5 = md5Util.digest(password);        System.out.println("原始密码:"+password);        System.out.println("MD5加密后的密码:"+md5);        System.out.println("盐值:"+salt);        System.out.println("PBKDF2加盐后的密码:"+pbkdf2);        System.out.println("Test success");    }}</code></pre><p> </p><p>7.测试结果</p><blockquote><p>原始密码:123456<br />MD5加密后的密码:e10adc3949ba59abbe56e057f20f883e<br />盐值:fb8681ed06d293f602596206089cc961<br />PBKDF2加盐后的密码:ac9bb962cc0e9b8a8c9887e0df41982b98001456afa191123fcd67ece84d3f715ecc5be82a704ec001e8bec1b53fe01f8adacffbfa3bc425f10b962c3690a904<br />Test success </p></blockquote><p> </p>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码加盐 </tag>
            
            <tag> PBKDF2 </tag>
            
            <tag> 密码攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度OCR识别表格文字，并自动下载到本地(准确率很高)</title>
      <link href="/blog/2018/08/22/%E7%99%BE%E5%BA%A6OCR%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC%E6%96%87%E5%AD%97%EF%BC%8C%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0(%E5%87%86%E7%A1%AE%E7%8E%87%E5%BE%88%E9%AB%98)/"/>
      <url>/blog/2018/08/22/%E7%99%BE%E5%BA%A6OCR%E8%AF%86%E5%88%AB%E8%A1%A8%E6%A0%BC%E6%96%87%E5%AD%97%EF%BC%8C%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0(%E5%87%86%E7%A1%AE%E7%8E%87%E5%BE%88%E9%AB%98)/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2>一、输入文件及申请的Token</h2><hr /><pre class="has"><code>import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLEncoder;import java.util.List;import java.util.Map;import java.util.Timer;import java.util.TimerTask;<p>import org.json.JSONObject;</p><p>import com.alibaba.fastjson.JSON;<br>import com.baidu.ai.aip.utils.Base64Util;<br>import com.baidu.ai.aip.utils.FileUtil;<br>import com.baidu.ai.aip.utils.HttpUtil;</p><p>public class BaiduExcel {</p><pre><code>public static void main(String[] args) throws IOException {    String accessToken = getAuth(&quot;aI62Wj4bu6ZOF46R7taLstZ8&quot;, &quot;OUBy6goyji2IU4yWjlvlbFxXF6dKGgcP&quot;);    String request_id = requestPic(&quot;D:/007.jpg&quot;,accessToken);    //定时器    Timer timer=new Timer();       timer.schedule(new TimerTask(){       public void run(){           String url = getUrl(request_id,accessToken);        download download = new download();        try {            download.downLoadFromUrl(url, &quot;识别文件.xls&quot;, &quot;D://&quot;, accessToken);            System.out.println(&quot;识别成功&quot;);        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    this.cancel();}},50000);            //延迟10s进行，否则显示进行中（可根据文件大小调整时间）}</code></pre><p>​<br>​<br>    /**<br>     * @author Ragty<br>     * @param  获取请求id<br>     * @serialData 2018.8.22<br>     * @param filePath<br>     * @return<br>     */<br>    public static String requestPic(String filePath,String accessToken) {<br>        String otherHost = “<a href="https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/request&quot;" target="_blank" rel="noopener">https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/request&quot;</a>;</p><pre><code>    try {        byte[] imgData = FileUtil.readFileByBytes(filePath);        String imgStr = Base64Util.encode(imgData);        String params = URLEncoder.encode(&quot;image&quot;, &quot;UTF-8&quot;) + &quot;=&quot; + URLEncoder.encode(imgStr, &quot;UTF-8&quot;);        /**         * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。         */        String result = HttpUtil.post(otherHost, accessToken, params);        JsonAnalyze jsonAnalyze = new JsonAnalyze();        Map&amp;lt;String, Object&amp;gt; map = jsonAnalyze.json2Map(result);        Object a = map.get(&quot;result&quot;);        String zz = jsonAnalyze.object2Json(a);        String zz1 = zz.substring(1, zz.length()-1);        jsonAnalyze.json2Map(zz1);        String result1 = jsonAnalyze.json2Map(zz1).get(&quot;request_id&quot;).toString();        return result1;    } catch (Exception e) {        e.printStackTrace();    }    return null;}</code></pre><p>​<br>​<br>    /**<br>     * @author Ragty<br>     * @param  获取异步请求到的excel地址<br>     * @param  2018.8.22<br>     * @param request_id<br>     * @return<br>     */<br>    public static String getUrl(String request_id,String accessToken) {<br>            String otherHost = “<a href="https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/get_request_result&quot;" target="_blank" rel="noopener">https://aip.baidubce.com/rest/2.0/solution/v1/form_ocr/get_request_result&quot;</a>;</p><pre><code>        try {           String params = URLEncoder.encode(&quot;request_id&quot;, &quot;UTF-8&quot;) + &quot;=&quot; + URLEncoder.encode(request_id, &quot;UTF-8&quot;);            /**             * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。             */            String result = HttpUtil.post(otherHost, accessToken, params);            JsonAnalyze jsonAnalyze = new JsonAnalyze();            Map&amp;lt;String, Object&amp;gt; map = jsonAnalyze.json2Map(result);            Object a = map.get(&quot;result&quot;);            String zz = jsonAnalyze.object2Json(a);            Map&amp;lt;String, Object&amp;gt; map1 = jsonAnalyze.json2Map(zz);            String url = map1.get(&quot;result_data&quot;).toString();            return url;        } catch (Exception e) {            e.printStackTrace();        }    return null;}</code></pre><p>​<br>​<br>    /**<br>     * @author Ragty<br>     * @param  获取当前的token<br>     * @serialData 2018.8.22<br>     * @param ak<br>     * @param sk<br>     * @return<br>     <em>/<br>    public static String getAuth(String ak, String sk) {<br>        // 获取token地址<br>        String authHost = “<a href="https://aip.baidubce.com/oauth/2.0/token?&quot;" target="_blank" rel="noopener">https://aip.baidubce.com/oauth/2.0/token?&quot;</a>;<br>        String getAccessTokenUrl = authHost<br>                // 1. grant_type为固定参数<br>                + “grant_type=client_credentials”<br>                // 2. 官网获取的 API Key<br>                + “&amp;client_id=” + ak<br>                // 3. 官网获取的 Secret Key<br>                + “&amp;client_secret=” + sk;<br>        try {<br>            URL realUrl = new URL(getAccessTokenUrl);<br>            // 打开和URL之间的连接<br>            HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();<br>            connection.setRequestMethod(“GET”);<br>            connection.connect();<br>            // 获取所有响应头字段<br>            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();<br>            // 遍历所有的响应头字段<br>            for (String key : map.keySet()) {<br>                System.err.println(key + “—&gt;” + map.get(key));<br>            }<br>            // 定义 BufferedReader输入流来读取URL的响应<br>            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));<br>            String result = “”;<br>            String line;<br>            while ((line = in.readLine()) != null) {<br>                result += line;<br>            }<br>            /*</em><br>             * 返回结果示例<br>             */<br>            System.err.println(“result:” + result);<br>            JSONObject jsonObject = new JSONObject(result);<br>            String access_token = jsonObject.getString(“access_token”);<br>            return access_token;<br>        } catch (Exception e) {<br>            System.err.printf(“获取token失败！”);<br>            e.printStackTrace(System.err);<br>        }<br>        return null;<br>    }</p><p>}<br></code></pre></p><p> </p><h2>二、识别效果</h2><h3>识别前：</h3><hr /><p><img alt="" class="has" height="506" src="https://img-blog.csdn.net/20180822174836937?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="380" /></p><h3>识别后：</h3><hr /><p><img alt="" class="has" height="514" src="https://img-blog.csdn.net/20180822175054270?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="832" /></p>]]></content>
      
      
      <categories>
          
          <category> OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR识别表格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中解析上传的excel文件（xls,xlsx）</title>
      <link href="/blog/2018/08/15/java%E4%B8%AD%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84excel%E6%96%87%E4%BB%B6%EF%BC%88xls,xlsx%EF%BC%89/"/>
      <url>/blog/2018/08/15/java%E4%B8%AD%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84excel%E6%96%87%E4%BB%B6%EF%BC%88xls,xlsx%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2><strong>一、在maven库中导入相关依赖</strong></h2><hr /><p>其中poi是解析xls格式的，poi-ooxml是解析xlsx格式的</p><pre class="has"><code class="language-java">&lt;!-- POI,excel解析相关 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;    &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;    &lt;artifactId&gt;json-lib&lt;/artifactId&gt;    &lt;version&gt;2.4&lt;/version&gt;    &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt;</code></pre><h2> </h2><h2><strong>二、解析代码</strong></h2><hr /><pre class="has"><code class="language-java">import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;<p>import org.apache.poi.hssf.usermodel.HSSFDateUtil;<br>import org.apache.poi.hssf.usermodel.HSSFWorkbook;<br>import org.apache.poi.openxml4j.exceptions.InvalidFormatException;<br>import org.apache.poi.poifs.filesystem.POIFSFileSystem;<br>import org.apache.poi.ss.usermodel.Cell;<br>import org.apache.poi.ss.usermodel.Row;<br>import org.apache.poi.ss.usermodel.Sheet;<br>import org.apache.poi.ss.usermodel.Workbook;<br>import org.apache.poi.xssf.usermodel.XSSFWorkbook;</p><p>import net.sf.json.JSONArray;<br>import net.sf.json.JSONObject;<br>import org.springframework.stereotype.Component;<br>import sun.applet.Main;</p><p>@Component<br>public class ExcelResolve {</p><pre><code>public final String XLSX = &quot;.xlsx&quot;;public final String XLS=&quot;.xls&quot;;/** * 获取Excel文件（.xls和.xlsx都支持） * @param file * @return  解析excle后的Json数据 * @throws IOException * @throws FileNotFoundException * @throws InvalidFormatException */public JSONArray readExcel(File file) throws Exception{    int res = checkFile(file);    if (res == 0) {        System.out.println(&quot;File not found&quot;);    }else if (res == 1) {        return readXLSX(file);    }else if (res == 2) {        return readXLS(file);    }    JSONArray array = new JSONArray();    return array;}/** * 判断File文件的类型 * @param file 传入的文件 * @return 0-文件为空，1-XLSX文件，2-XLS文件，3-其他文件 */public int checkFile(File file){    if (file==null) {        return 0;    }    String flieName = file.getName();    if (flieName.endsWith(XLSX)) {        return 1;    }    if (flieName.endsWith(XLS)) {        return 2;    }    return 3;}/** * 读取XLSX文件 * @param file * @return * @throws IOException * @throws InvalidFormatException */public JSONArray readXLSX(File file) throws InvalidFormatException, IOException{    Workbook book = new XSSFWorkbook(file);    Sheet sheet = book.getSheetAt(0);    return read(sheet, book);}/** * 读取XLS文件 * @param file * @return * @throws IOException * @throws FileNotFoundException */public JSONArray readXLS(File file) throws FileNotFoundException, IOException{    POIFSFileSystem poifsFileSystem = new POIFSFileSystem(new FileInputStream(file));    Workbook book = new HSSFWorkbook(poifsFileSystem);    Sheet sheet = book.getSheetAt(0);    return read(sheet, book);}/** * 解析数据 * @param sheet 表格sheet对象 * @param book 用于流关闭 * @return * @throws IOException */public JSONArray read(Sheet sheet,Workbook book) throws IOException{    int rowStart = sheet.getFirstRowNum();    // 首行下标    int rowEnd = sheet.getLastRowNum();    // 尾行下标    // 如果首行与尾行相同，表明只有一行，直接返回空数组    if (rowStart == rowEnd) {        book.close();        return new JSONArray();    }    // 获取第一行JSON对象键    Row firstRow = sheet.getRow(rowStart);    int cellStart = firstRow.getFirstCellNum();    int cellEnd = firstRow.getLastCellNum();    Map&amp;lt;Integer, String&amp;gt; keyMap = new HashMap&amp;lt;Integer, String&amp;gt;();    for (int j = cellStart; j &amp;lt; cellEnd; j++) {        keyMap.put(j,getValue(firstRow.getCell(j), rowStart, j, book, true));    }    // 获取每行JSON对象的值    JSONArray array = new JSONArray();    for(int i = rowStart+1; i &amp;lt;= rowEnd ; i++) {        Row eachRow = sheet.getRow(i);        JSONObject obj = new JSONObject();        StringBuffer sb = new StringBuffer();        for (int k = cellStart; k &amp;lt; cellEnd; k++) {            if (eachRow != null) {                String val = getValue(eachRow.getCell(k), i, k, book, false);                sb.append(val);        // 所有数据添加到里面，用于判断该行是否为空                obj.put(keyMap.get(k),val);            }        }        if (sb.toString().length() &amp;gt; 0) {            array.add(obj);        }    }    book.close();    return array;}/** * 获取每个单元格的数据 * @param cell 单元格对象 * @param rowNum 第几行 * @param index 该行第几个 * @param book 主要用于关闭流 * @param isKey 是否为键：true-是，false-不是。 如果解析Json键，值为空时报错；如果不是Json键，值为空不报错 * @return * @throws IOException */public String getValue(Cell cell,int rowNum,int index,Workbook book,boolean isKey) throws IOException{    // 空白或空    if (cell == null || cell.getCellType()==Cell.CELL_TYPE_BLANK ) {        if (isKey) {            book.close();            throw new NullPointerException(String.format(&quot;the key on row %s index %s is null &quot;, ++rowNum,++index));        }else{            return &quot;&quot;;        }    }    // 0. 数字 类型    if (cell.getCellType() == Cell.CELL_TYPE_NUMERIC) {        if (HSSFDateUtil.isCellDateFormatted(cell)) {            Date date = cell.getDateCellValue();            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            return df.format(date);        }        String val = cell.getNumericCellValue()+&quot;&quot;;        val = val.toUpperCase();        if (val.contains(&quot;E&quot;)) {            val = val.split(&quot;E&quot;)[0].replace(&quot;.&quot;, &quot;&quot;);        }        return val;    }    // 1. String类型    if (cell.getCellType() == Cell.CELL_TYPE_STRING) {        String val = cell.getStringCellValue();        if (val == null || val.trim().length()==0) {            if (book != null) {                book.close();            }            return &quot;&quot;;        }        return val.trim();    }    // 2. 公式 CELL_TYPE_FORMULA    if (cell.getCellType() == Cell.CELL_TYPE_FORMULA) {        return cell.getStringCellValue();    }    // 4. 布尔值 CELL_TYPE_BOOLEAN    if (cell.getCellType() == Cell.CELL_TYPE_BOOLEAN) {        return cell.getBooleanCellValue()+&quot;&quot;;    }    // 5.    错误 CELL_TYPE_ERROR    return &quot;&quot;;}</code></pre><p>}<br></code></pre></p><p> </p><h2><strong>三、单元测试</strong></h2><hr /><p>  这里点出调用封装好的组件时，要用try catch将异常抛出</p><pre class="has"><code class="language-java">@RunWith(SpringRunner.class)@SpringBootTestpublic class ExcelTest extends TestCase {    @Autowired    private ExcelResolve excelResolve;    @Test    public void readTest() throws Exception{        File f1 = new File("D:/work/1.xlsx");        try {            System.out.println(excelResolve.readExcel(f1));        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p> </p><h2><strong>四、测试结果</strong></h2><p><img alt="" class="has" src="https://img-blog.csdn.net/20180815092008819?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1b2ppNTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" /></p><p> </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excel解析 </tag>
            
            <tag> 解析工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Adaline神经网络识别印刷体数字</title>
      <link href="/blog/2018/04/25/%E4%BD%BF%E7%94%A8Adaline%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E5%8D%B0%E5%88%B7%E4%BD%93%E6%95%B0%E5%AD%97/"/>
      <url>/blog/2018/04/25/%E4%BD%BF%E7%94%A8Adaline%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E5%8D%B0%E5%88%B7%E4%BD%93%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><span style="font-size:24px;color:#666666;">1.创建Adaline神经网络</span></p><pre class="html">       /**     * @author Ragty     * @param  设置Adaline神经网络     * @serialData 2018.4.24     * @param inputNeuralCount     * @param outputNeuralNetwork     */    public void creatNetwork(int inputNeuralCount, int outputNeuralCount){<pre><code>    //设置神经网络类型为Adaline    this.setNetworkType(NeuralNetworkType.ADALINE);    //建立输入神经元，表刺激    NeuronProperties inputNeural = new NeuronProperties();    inputNeural.setProperty(&quot;transferFunction&quot;, TransferFunctionType.LINEAR);    //建立神经网络的输入层    Layer inputLayer = LayerFactory.createLayer(inputNeuralCount, inputNeural);    inputLayer.addNeuron(new BiasNeuron());    this.addLayer(inputLayer);    //建立输出神经元    NeuronProperties outputNeural = new NeuronProperties();    outputNeural.setProperty(&quot;transferFunction&quot;, TransferFunctionType.LINEAR);    //创建输出层    Layer outputLayer = LayerFactory.createLayer(outputNeuralCount, outputNeural);    this.addLayer(outputLayer);    //输入输出层全连接    ConnectionFactory.fullConnect(inputLayer, outputLayer);    NeuralNetworkFactory.setDefaultIO(this);    //设置LMS算法    //学习步长系数为0.05（由最速下降法引入，表示学习的速度）一般是在0.1或0.01这样的数量级            //步长太大，不精准，步长太小，学习速度慢，易陷入局部最优    //设置最大可接受误差为0.5  (LMS中不同于感知机，误差是连续的)    //(w_new = w_old + 2aep) (b_new = b_old + 2ae)  &amp;gt;&amp;gt;LMS公式（步长系数a，省略常数2）    LMS lms = new LMS();    lms.setLearningRate(0.05);    lms.setMaxError(0.5);    this.setLearningRule(lms);}</code></pre><p>​    </p><p>2.实现Adaline的核心算法LMS<br>public LMS(){</p><pre><code>}</code></pre><p>   /**<br>    *@author Ragty<br>    *@param  LMS核心算法<br>    *@serialData 2018.4.24<br>    *@核心公式  deltaWeight = learningRate * neuronError * input(learingRate是学习系数)<br>    */<br>    @Override<br>    protected void updateNetworkWeights(double[] outputError) {<br>        // TODO Auto-generated method stub<br>        int i = 0;</p><pre><code>    //遍历每个神经元，修改权值    for(Neuron neuron : neuralNetwork.getOutputNeurons()){        neuron.setError(outputError[i]);        this.updateNetworkWeights(neuron);        i++;    }}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  迭代更新每个输入神经元的权值<br>     * @serialData 2018.4.24<br>     * @param neuron<br>     */<br>    protected void updateNetworkWeights(Neuron neuron) {<br>        // TODO Auto-generated method stub<br>        //取得神经元误差<br>        double neuronError = neuron.getError();</p><pre><code>    //根据所有神经元输入迭代学习    for(Connection connection : neuron.getInputConnections()){        //神经元的一个输入        double input = connection.getInput();        double weightChange = this.learningRate * neuronError * input;        //更新权值        Weight weight = connection.getWeight();        weight.weightChange = weightChange;        weight.value += weightChange;    }}</code></pre><p>3.实现Adaline感知机识别印刷体数字<br>public class AdalineDemo implements LearningEventListener{</p><pre><code>//设置输入神经元的个数为5*7=35个public final static int char_width = 5;public final static int char_height = 7;public static String[][] DIGITS = {       { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  },      { &quot;  O  &quot;,        &quot; OO  &quot;,        &quot;O O  &quot;,        &quot;  O  &quot;,        &quot;  O  &quot;,        &quot;  O  &quot;,        &quot;  O  &quot;  },      { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;    O&quot;,        &quot;   O &quot;,        &quot;  O  &quot;,        &quot; O   &quot;,        &quot;OOOOO&quot;  },      { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;    O&quot;,        &quot; OOO &quot;,        &quot;    O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  },      { &quot;   O &quot;,        &quot;  OO &quot;,        &quot; O O &quot;,        &quot;O  O &quot;,        &quot;OOOOO&quot;,        &quot;   O &quot;,        &quot;   O &quot;  },      { &quot;OOOOO&quot;,        &quot;O    &quot;,        &quot;O    &quot;,        &quot;OOOO &quot;,        &quot;    O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  },      { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;O    &quot;,        &quot;OOOO &quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  },      { &quot;OOOOO&quot;,        &quot;    O&quot;,        &quot;    O&quot;,        &quot;   O &quot;,        &quot;  O  &quot;,        &quot; O   &quot;,        &quot;O    &quot;  },      { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  },      { &quot; OOO &quot;,        &quot;O   O&quot;,        &quot;O   O&quot;,        &quot; OOOO&quot;,        &quot;    O&quot;,        &quot;O   O&quot;,        &quot; OOO &quot;  } };</code></pre><p>​<br>    public static void main(String[] args) {</p><pre><code>    //设置Adaline神经网络输入节点为35个，输出节点为10个    Adaline ada = new Adaline(char_width * char_height, DIGITS.length);    //设置训练集为35个输入节点，10个输出节点    DataSet ds = new DataSet(char_width * char_height, DIGITS.length);    //设置训练集(前面是输入值，后面是期望值)    for(int i = 0; i &amp;lt; DIGITS.length; i++ ){       ds.addRow(creatTrainRow(DIGITS[i], i));    }    //监督训练过程    ada.getLearningRule().addListener(new AdalineDemo());    //训练该神经网络    ada.learn(ds);    //测试训练好的数据    for(int i = 0; i &amp;lt; DIGITS.length; i++){        ada.setInput(image2data(DIGITS[i]));        ada.calculate();        print(DIGITS[i]);        System.out.print(maxIndex(ada.getOutput()));        System.out.println();    }}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  设置这几个数字的训练集<br>     * @serialData 2018.4.24<br>     * @param image<br>     * @param idealValue<br>     * @return<br>     */<br>    public static DataSetRow creatTrainRow(String[] image, int idealValue){<br>        double[] output = new double[DIGITS.length];</p><pre><code>    //将训练集初始化    for(int i = 0; i &amp;lt;DIGITS.length; i++)        output[i] = -1;    //输入数据    double[] input = image2data(image);    //用这样的方式来表示一个具体的数字（10个数字分为十个维度，表示哪个数字把哪个数字的维度设置为1）    output[idealValue] = 1;    //设置训练集以及期望值    DataSetRow dsr = new DataSetRow(input, output);    return dsr;}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  将输入的二维数组转化为网络能够识别的格式（有字的地方全部转化为1，无字的地方转化为-1）<br>     * @serialData 2018.4.24<br>     * @param image<br>     * @return<br>     */<br>    public static double[] image2data(String[] image){<br>        double[] input = new double[char_width * char_height];</p><pre><code>    for(int row = 0; row &amp;lt; char_height; row++){        for(int col = 0; col &amp;lt; char_width; col++){            int index = (row*char_width)+col;            char ch = image[row].charAt(col);            input[index] = ch == &apos;O&apos;? 1 :-1;        }    }    return input;}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  识别输出数据为数字（采用竞争规则，在所有维度里，将最大的那个维度视为1，其余均为0）<br>     * @param  即找到数组中最大值的索引下标(第一次从左边的条件进入)<br>     * @serialData 2018.4.24<br>     * @param data<br>     * @return<br>     */<br>    public static int maxIndex(double[] data){<br>        int result = -1;<br>        for(int i = 0; i &lt; data.length; i++){<br>            if(result == -1 || data[i] &gt; data[result]){<br>                result = i;<br>            }<br>        }<br>        return result;<br>    }</p><p>​<br>    /**<br>     * @author Ragty<br>     * @param  打印输出的打印字体<br>     * @serialData 2018.4.24<br>     * @param dIGITS2<br>     */<br>    public static void print(String[] dIGITS2){</p><pre><code>    for(int i = 0; i &amp;lt;dIGITS2.length; i++){        if(i == dIGITS2.length-1){            System.out.print(dIGITS2[i]+&quot;===&amp;gt;&quot;);        } else {            System.out.println(dIGITS2[i]);        }    }}/** * @param 监督训练 */@Overridepublic void handleLearningEvent(LearningEvent event) {    // TODO Auto-generated method stub    IterativeLearning bp = (IterativeLearning)event.getSource();    System.out.println(&quot;iterate:&quot;+bp.getCurrentIteration());     System.out.println(Arrays.toString(bp.getNeuralNetwork().getWeights()));}</code></pre><p>​<br>}</pre><br /><br /><span style="font-size:24px;">4.识别结果</span><p><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="" alt="" /><img src="https://img-blog.csdn.net/20180425103537962" alt="" /><br /></p></p>]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> Adaline神经网络 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机加算法自动识别象限</title>
      <link href="/blog/2018/04/23/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8A%A0%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%B1%A1%E9%99%90/"/>
      <url>/blog/2018/04/23/%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%8A%A0%E7%AE%97%E6%B3%95%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%B1%A1%E9%99%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><span style="font-size:24px;">1.创建感知机</span></p><p><span style="font-size:24px;"><br /></span></p><p><span style="font-size:24px;">2.创建迭代学习算法</span></p><p><span style="font-size:24px;"><br /></span></p><p><span style="font-size:24px;">3.通过训练数据，不断学习，并检验学习的正确率</span></p><pre class="java">public class FeelPosLearning implements LearningEventListener{<pre><code>public static void main(String[] args) {    new FeelPosLearning().run();}/** * @author Ragty * @param  根据学习数据自动学习，识别象限 */public void run(){    //新建一个两个输入两个输出的训练集    DataSet dataSet = new DataSet(2,2);    //一万个测试数据，让训练效果更显著    for (int i = 0; i &amp;lt; 10000; i++){        //第一象限期望        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), 1 * nextDouble() },new double[] { 1, 1 }));        //第二象限期望        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), 1 * nextDouble() },new double[] { 0, 1 }));        //第三象限期望        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), -1 * nextDouble() },new double[] { 0, 0 }));        //第四象限期望        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), -1 * nextDouble() },new double[] { 1, 0 }));    }    //创建两个输入，两个输出的感知机    simplePerceptron posPerceptron = new simplePerceptron(2,2);    //设置最小误差为0.001(增加监听器)    perceptronLearningRule learningRule = (perceptronLearningRule) posPerceptron.getLearningRule();    learningRule.setMaxError(0.001);    learningRule.addListener(this);    //进行学习    System.out.println(&quot;进行学习&quot;);    posPerceptron.learn(dataSet);    //检测学习    System.out.println(&quot;检测学习&quot;);    testData(posPerceptron);}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @deprecated 得到一个0到1之间的随机数<br>     * @serialData 2018.4.23<br>     */<br>    static Random r = new Random();</p><pre><code>public static double nextDouble() {    double re = 0;    while ((re = r.nextDouble()) != 0) {        return re;    }    return r.nextDouble();}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  测试训练的效果，得出正确率<br>     * @param neuralNetwork<br>     */<br>    public static void testData(NeuralNetwork neuralNetwork){</p><pre><code>    DataSet dataSet = new DataSet(2,2);    for (int i = 0; i &amp;lt; 1000; i++) {        // 第一象限        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), 1 * nextDouble() }, new double[] { 1, 1 }));        // 第二象限        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), 1 * nextDouble() }, new double[] { 0, 1 }));        // 第三象限        dataSet.addRow(new DataSetRow(new double[] { -1 * nextDouble(), -1 * nextDouble() }, new double[] { 0, 0 }));        // 第四象限        dataSet.addRow(new DataSetRow(new double[] { 1 * nextDouble(), -1 * nextDouble() }, new double[] { 1, 0 }));    }    //正确总数    int correctCount = 0;    int incorrectCount = 0;    //遍历整个测试数组    for(DataSetRow dataSetRow : dataSet.getRows()){        //获得一个输入        neuralNetwork.setInput(dataSetRow.getInput());        neuralNetwork.calculate();        double[] output = neuralNetwork.getOutput();        //实际输出跟期望输出相比较        if(Arrays.equals(output, dataSetRow.getDesiredOutput())){            correctCount++;        } else{            incorrectCount++;        }    }    System.out.println(&quot;正确率：&quot;+correctCount * 1.0 / (correctCount + incorrectCount));}</code></pre><p>​<br>    /**<br>     * @author Ragty<br>     * @param  监督学习<br>     * @serialData 2018.4.23<br>     */<br>    @Override<br>    public void handleLearningEvent(LearningEvent event) {<br>        // TODO Auto-generated method stub<br>        IterativeLearning bp = (IterativeLearning) event.getSource();<br>        System.out.println(“iterate:” + bp.getCurrentIteration());<br>        System.out.print(“TotalNetworkError:”);<br>        System.out.println(((perceptronLearningRule) bp.getNeuralNetwork().getLearningRule()).getTotalNetworkError());</p><pre><code>}&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;span style=&quot;font-size:24px;&quot;&gt;4.输出结果(正确率)&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;font-size:24px;&quot;&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180423165030350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neuroph感知机自我学习实现记忆逻辑与</title>
      <link href="/blog/2018/04/23/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/"/>
      <url>/blog/2018/04/23/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%87%AA%E6%88%91%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><span style="font-size:24px; color:#333333">1.创建增加学习算法的感知机</span></p><p><pre name="code" class="java">    /**     * @author Ragty     * @param  增加学习算法的感知机(记忆逻辑与)     * @serialData 2018.4.22     * @param inputNeuralCount     */    public void creatPerceptron(int inputNeuralCount){<pre><code>    //设置类型为感知机    this.setNetworkType(NeuralNetworkType.PERCEPTRON);    //建立输入神经元，表示输入刺激    NeuronProperties inputNeuronProperties = new NeuronProperties();    inputNeuronProperties.setProperty(&amp;quot;neuronType&amp;quot;,InputNeuron.class);    //建立输入层    Layer inputLayer = LayerFactory.createLayer(inputNeuralCount, inputNeuronProperties);    this.addLayer(inputLayer);    inputLayer.addNeuron(new BiasNeuron());    //建立输出神经元（传输函数为step）    NeuronProperties outputNeuronProperties = new NeuronProperties();    outputNeuronProperties.setProperty(&amp;quot;transferFunction&amp;quot;, TransferFunctionType.STEP);    //建立输出层    Layer outputLayer = LayerFactory.createLayer(1, outputNeuronProperties);    this.addLayer(outputLayer);    //输入层输出层全连接    ConnectionFactory.fullConnect(inputLayer, outputLayer);    NeuralNetworkFactory.setDefaultIO(this);    //设置感知机学习算法    this.setLearningRule(new perceptronLearningRule());}&lt;/pre&gt;&lt;br&gt;</code></pre><br></p><p><span style="font-size:24px">2.创建学习算法</span></p><p><pre name="code" class="java">public class perceptronLearningRule extends SupervisedLearning implements Serializable{<pre><code>private static final long serialVersionUID = 1L;public perceptronLearningRule() {}/** * @author Ragty * @param  迭代计算权值 * @serialData 2018.4.22 */@Overrideprotected void updateNetworkWeights(double[] outputError) {    int i = 0;    for (Neuron neuron : neuralNetwork.getOutputNeurons()) {        neuron.setError(outputError[i]);         double neuronError = neuron.getError();        // 根据所有的神经元输入 迭代学习        for (Connection connection : neuron.getInputConnections()) {            // 神经元的一个输入            double input = connection.getInput();            // 计算权值的变更            double weightChange =  neuronError * input;            // 更新权值            Weight weight = connection.getWeight();            weight.weightChange = weightChange;                            weight.value += weightChange;        }        i++;    }}</code></pre><p>​    </p><p>}</pre></p></p><p><br></p><span style="font-size:24px">3.训练数据并测试</span><p><pre name="code" class="java">public class AndPerceptron implements LearningEventListener{<pre><code>public static void main(String[] args) {    new AndPerceptron().run();}public void run(){   //给出学习的训练数据(用于训练神经网络)   //数据集有两个输入，一个输出   //dataSetRow的构造函数接受两个参数，第一个为输入向量，第二个为期望值   DataSet trainningSet = new DataSet(2,1);       trainningSet.addRow(new DataSetRow(new double[]{0,0},new double[]{0}));   trainningSet.addRow(new DataSetRow(new double[]{0,1},new double[]{0}));   trainningSet.addRow(new DataSetRow(new double[]{1,0},new double[]{0}));   trainningSet.addRow(new DataSetRow(new double[]{1,1},new double[]{1}));   //创建一个只有两个输入节点的感知机   simplePerceptron andPerceptron = new simplePerceptron(2);   //给学习过程增加事件监听器（监督训练）   perceptronLearningRule learningRule = (perceptronLearningRule) andPerceptron.getLearningRule();   learningRule.addListener(this);       //使用训练数据训练感知机（进行学习）   System.out.println(&amp;quot;训练开始&amp;quot;);   andPerceptron.learn(trainningSet);   //测试感知机是否能正确输出   System.out.println(&amp;quot;测试输出&amp;quot;);   testNeuralNetwork(andPerceptron, trainningSet);}</code></pre><p>​<br>​    /**<br>​     * @author Ragty<br>​     * @param  训练之后对网络测试(测试感知机)<br>​     * @serialData 2018.4.22<br>​     * @param neuralNetwork<br>​     * @param data<br>​     */<br>​    public static void testNeuralNetwork(NeuralNetwork neuralNetwork, DataSet testSet){<br>​<br>        for(DataSetRow testSetRow : testSet.getRows()){<br>            neuralNetwork.setInput(testSetRow.getInput());<br>            neuralNetwork.calculate();<br>            double[] networkOutput = neuralNetwork.getOutput();</p><pre><code>        System.out.println(&amp;quot;Input:&amp;quot;+Arrays.toString(testSetRow.getInput()));        System.out.println(&amp;quot;Output:&amp;quot;+Arrays.toString(networkOutput));    }}</code></pre><p>​<br>​    //监督训练过程<br>​    @Override<br>​    public void handleLearningEvent(LearningEvent event) {<br>​        // TODO Auto-generated method stub<br>​        //所有迭代学习算法的基类, 它为它的所有子类提供迭代学习过程<br>​        IterativeLearning bp = (IterativeLearning) event.getSource();<br>​        System.out.println(&quot;iterate:&quot;+bp.getCurrentIteration());<br>​        System.out.println(Arrays.toString(bp.getNeuralNetwork().getWeights()));<br>​    }</p><p>​<br>​<br>}</pre></p></p><p><br></p><span style="font-size:24px">4.学习结果</span><p><img src="https://img-blog.csdn.net/20180423135418612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neuroph使用感知机识别坐标系</title>
      <link href="/blog/2018/04/22/Neuroph%E4%BD%BF%E7%94%A8%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%AF%86%E5%88%AB%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
      <url>/blog/2018/04/22/Neuroph%E4%BD%BF%E7%94%A8%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%AF%86%E5%88%AB%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><span style="font-size:24px">1.创建识别坐标系的感知机</span></p><p><pre name="code" class="java">         /**     * @author Ragty     * @param  创建识别坐标系的感知机     * @serialData 2018.4.22     * @param inputNerouCount     * @param outputNeurophCount     */    public void creatNetwork(int inputNerouCount, int outputNeurophCount){<pre><code>    //定义感知机类型    this.setNetworkType(NeuralNetworkType.PERCEPTRON);    //建立输入神经元，表示输入的刺激    NeuronProperties inputNeuronProperties = new NeuronProperties();    inputNeuronProperties.setProperty(&amp;quot;neuronType&amp;quot;, InputNeuron.class);    //输入神经元构建的输入层    Layer inputLayer = LayerFactory.createLayer(inputNerouCount, inputNeuronProperties);    this.addLayer(inputLayer);    //设置传递函数为step函数(即为是大于0为1，小于等于1为0)    NeuronProperties outputNeuronProperties = new NeuronProperties();    outputNeuronProperties.setProperty(&amp;quot;transferFunction&amp;quot;,TransferFunctionType.STEP);    //指定输出层包含两个神经元    Layer outputLayer = LayerFactory.createLayer(outputNeurophCount, outputNeuronProperties);    this.addLayer(outputLayer);    //输入输出层全连接    ConnectionFactory.fullConnect(inputLayer, outputLayer);    NeuralNetworkFactory.setDefaultIO(this);    //设置连接权重(直接关系到神经网络能否正常工作)分 别为[1 0] [0 1]    //因为要区分四个象限对应为[1,1] [0,1] [0,0] [1,0] stpe函数中负数表示为0    //根据公式的话，以第一象限为例，要求第一想想上边得出的结果必须为1，下边得出的结果也必须为1    //据此可推断出权重为 [1 0] [0 1]    Neuron n = outputLayer.getNeuronAt(0);    n.getInputConnections()[0].getWeight().setValue(1);       n.getInputConnections()[1].getWeight().setValue(0);    n = outputLayer.getNeuronAt(1);    n.getInputConnections()[0].getWeight().setValue(0);    n.getInputConnections()[1].getWeight().setValue(1);}&lt;/pre&gt;&lt;/p&gt;</code></pre><p><br></p><span style="font-size:24px">2.输入两个&#20540;，判断为第几象限</span><p><pre name="code" class="java">          public static void main(String[] args) {<pre><code>Scanner in = new Scanner(System.in);String line = null;          double[] input = new double[2];//两个输入，两个输出的感知机feelPos perceptron = new feelPos(2, 2);try {    while ((line = in.nextLine())!= null){        String[] numbers = line.split(&amp;quot;[\\s|,|;]&amp;quot;);        input[0] = Double.parseDouble(numbers[0]);        input[1] = Double.parseDouble(numbers[1]);        perceptron.setInput(input);        perceptron.calculate();        double[] networkOutput = perceptron.getOutput();        System.out.println(Arrays.toString(input)+ &amp;quot;=&amp;quot; +posToString(networkOutput));    }} catch (Exception e) {    // TODO: handle exception}</code></pre><p>​<br>​    }<br>​<br>    //判断为第几象限<br>    public static String posToString(double[] networkOutput ){<br>        if((networkOutput[0]+networkOutput[1])==2){<br>            return &quot;第一象限&quot;;<br>        }else if((networkOutput[0]+networkOutput[1])==0){<br>            return &quot;第三象限&quot;;<br>        }else if((networkOutput[0]-networkOutput[1])==1){<br>            return &quot;第四象限&quot;;<br>        }<br>        return &quot;第二象限&quot;;<br>    }</pre><span style="font-size:24px"></span></p></p><p><span style="font-size:24px"><br></span></p>3.识别结果<p><span style="font-size:24px"><img src="https://img-blog.csdn.net/20180422163116373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></span><br></p>]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> 感知机 </tag>
            
            <tag> 识别坐标系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neuroph感知机实现记忆逻辑与</title>
      <link href="/blog/2018/04/22/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/"/>
      <url>/blog/2018/04/22/Neuroph%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BF%86%E9%80%BB%E8%BE%91%E4%B8%8E/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1><span style="font-size:24px">&nbsp;<span style="font-weight:normal">1</span>.<span style="color:#666666">创建感知机</span></span></h1><div><span style="font-size:14px; color:#666666"></span><pre name="code" class="html">    private void creatNetwork(int inputNeuronsCount){<pre><code>//设置网络类别为感知机this.setNetworkType(NeuralNetworkType.PERCEPTRON);</code></pre><p>​<br>​        //建立输入神经元，表示输入的刺激<br>​        NeuronProperties inputNeuron = new NeuronProperties();<br>​        inputNeuron.setProperty(&quot;neuronType&quot;, InputNeuron.class);</p><p>​<br>​        //由输入神经元构成的底层<br>​        Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, inputNeuron);<br>​        this.addLayer(inputLayer);<br>​        //在输入层增加贝叶斯神经，表示神经元偏置<br>​        inputLayer.addNeuron(new BiasNeuron());</p><p>​<br>​        //设置传递函数为step()函数<br>​        NeuronProperties outputProperties = new NeuronProperties();<br>​        outputProperties.setProperty(&quot;transferFunction&quot;, TransferFunctionType.STEP);<br>​        Layer outputLayer = LayerFactory.createLayer(1, outputProperties);<br>​        this.addLayer(outputLayer);</p><p>​<br>​        //将输入层和输出层进行全连接(输入节点和每个神经元都两两连接)<br>​        ConnectionFactory.fullConnect(inputLayer, outputLayer);<br>​        NeuralNetworkFactory.setDefaultIO(this);<br>​        Neuron n = outputLayer.getNeuronAt(0);<br>​<br>        System.out.println(n);</p><pre><code>    //设置每个连接的权重，1和1是输入节点到神经元的权值，-1.5是神经元的偏置    n.getInputConnections()[0].getWeight().setValue(1);    n.getInputConnections()[1].getWeight().setValue(1);    n.getInputConnections()[2].getWeight().setValue(-1.5);}&lt;/pre&gt;&lt;br&gt;</code></pre></div><div><span style="font-size:14px; color:#666666"><br></span></div><div><span style="color:#666666"></span><h1><span style="font-size:32px">&nbsp;</span><span style="font-size:24px">2.<span style="color:rgb(102,102,102)">使用感知机记忆逻辑与</span></span></h1><div style="font-size:14px"><span style="color:#666666"><span style="font-size:24px"></span></span><pre name="code" class="html" style="color: rgb(102, 102, 102);font-size:14px;"><pre name="code" class="java">public static void main(String[] args) {<pre><code>//创建学习数据集DataSet trainingSet = new DataSet(2,1);  //两个输入，一个输出trainingSet.addRow(new DataSetRow(new double[] {0,0},new double[] {Double.NaN}));trainingSet.addRow(new DataSetRow(new double[] {0,1},new double[] {Double.NaN}));trainingSet.addRow(new DataSetRow(new double[] {1,0},new double[] {Double.NaN}));trainingSet.addRow(new DataSetRow(new double[] {1,1},new double[] {Double.NaN}));simpleDemo perceptron = new simpleDemo(2);for(DataSetRow row : trainingSet.getRows()){    perceptron.setInput(row.getInput());    perceptron.calculate();    double[] networkOutput = perceptron.getOutput();    System.out.println(Arrays.toString(row.getInput())+&amp;quot;=&amp;quot;+Arrays.toString(networkOutput));}</code></pre><p>​<br>​    }</pre><br></p><pre></pre><br></div><div><h1 style="color:rgb(102,102,102)"><span style="font-size:24px">3.识别结果</span></h1><div style="font-size:14px"><img src="https://img-blog.csdn.net/20180422142020774?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></div><br></div></div>]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neuroph开发环境搭建</title>
      <link href="/blog/2018/04/20/Neuroph%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/blog/2018/04/20/Neuroph%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><br></p><h1><span style="font-size:32px; color:#666666">Neuroph简介</span></h1><p><span style="font-size:18px"><a target="_blank" href="http://sourceforge.net/projects/neuroph/?source=typ_redirect" style="color:rgb(103,149,181); margin:0px; padding:0px; text-decoration:none; font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">Neuroph</a><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">是一个轻量级的Java神经网络的框架，可以用来模拟常见的神经网络架构。少数基本类别相对应的基本网络的概念，它非常容易学习。而且它也还有一个不错的GUI应用程序。Neurop最初是一位硕士研究生的毕业论文主题，随后成为一个开源项目，它采用LGPL3许可证发布源代码。</span></span></p><p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><br></span></span></p><h1><span style="color:rgb(79,79,79); line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-family:SimSun; font-size:32px">Neuroph开发环境搭建</span></span></span></h1><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-size:18px"><br></span></span></span></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify"><span style="color:rgb(102,102,102)"><span style="font-size:18px">一. &nbsp;JDK的配置及安装 &nbsp; &nbsp; &nbsp;&nbsp;</span></span></span><a target="_blank" href="https://www.cnblogs.com/cxysj/p/8204267.html" style="font-size:18px; font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px; text-align:justify">传送门</a></p><p><span style="font-size:24px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">二</span>.&nbsp;<span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">Maven安装 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a target="_blank" href="https://www.cnblogs.com/yyiou/archive/2017/08/22/7411409.html">传送门</a></span></span></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">三. &nbsp;新建项目</span></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">&nbsp;(1) 新建 maven 项目（结构如下）</span></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"></span></p><div></div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img-blog.csdn.net/20180420204454236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><p></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify"><br></span></span></p><p><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">(2) 引入需要的包 (右键builld path)</span></span></p><p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img-blog.csdn.net/20180420204820069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVvamk1NTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></span></span></p><p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify"><br></span></span></span></p><p><span style="font-size:18px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; line-height:26px"><span style="color:rgb(79,79,79); font-family:'PingFang SC','Microsoft YaHei',SimHei,Arial,SimSun; font-size:18px; line-height:26px; text-align:justify">(3) &nbsp;pom.xml添加依赖</span></span></span></p><pre class="html">   &lt;dependency&gt;            &lt;groupId&gt;org.neuroph&lt;/groupId&gt;            &lt;artifactId&gt;neuroph-core&lt;/artifactId&gt;            &lt;version&gt;2.8&lt;/version&gt;            &lt;scope&gt;system&lt;/scope&gt;             &lt;systemPath&gt;${project.basedir}/lib/neuroph-core-2.8.jar&lt;/systemPath&gt;         &lt;/dependency&gt;<pre><code>&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;slf4j-nop&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;    &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt;    &amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt;    &amp;lt;version&amp;gt;3.14&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;</code></pre><br>这样我们就搭建好了Neuroph的基本环境]]></content>
      
      
      <categories>
          
          <category> 神经网络-Neuroph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neuroph </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA实现百度OCR文字识别功能</title>
      <link href="/blog/2018/03/17/JAVA%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6OCR%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/"/>
      <url>/blog/2018/03/17/JAVA%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6OCR%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1><span style="font-size:18px">&nbsp;</span><span style="font-size:24px"> &nbsp; &nbsp; 调用百度OCR文字识别接口，实现图片文字识别，需要获取百度提供的API Key (ak) 和Scerct Key (sk),下面是具体实现代码和效果图。</span></h1><p></p><pre class="java">package imageProcessing;<p>import java.io.BufferedReader;<br>import java.io.InputStreamReader;<br>import java.net.HttpURLConnection;<br>import java.net.URL;<br>import java.net.URLEncoder;<br>import java.util.List;<br>import java.util.Map;</p><p>import org.json.JSONObject;</p><p>import com.baidu.ai.aip.utils.FileUtil;<br>import com.baidu.ai.aip.utils.HttpUtil;<br>import com.baidu.aip.util.Base64Util;</p><p>public class baidu1 {</p><pre><code>public static void main(String[] args) {    String otherHost = &amp;quot;https://aip.baidubce.com/rest/2.0/ocr/v1/general&amp;quot;;        // 本地图片路径        String filePath = &amp;quot;E:/img/38.jpg&amp;quot;;        try {            byte[] imgData = FileUtil.readFileByBytes(filePath);            String imgStr = Base64Util.encode(imgData);            String params = URLEncoder.encode(&amp;quot;image&amp;quot;, &amp;quot;UTF-8&amp;quot;) &amp;#43; &amp;quot;=&amp;quot; &amp;#43; URLEncoder.encode(imgStr, &amp;quot;UTF-8&amp;quot;);            /**             * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。             */            String accessToken = getAuth(&amp;quot;你的ak&amp;#20540;&amp;quot;, &amp;quot;你的secerct key&amp;#20540;&amp;quot;);            String result = HttpUtil.post(otherHost, accessToken, params);            System.out.println(result);        } catch (Exception e) {            e.printStackTrace();        }</code></pre><p>​<br>    }</p><p>​<br>     public static String getAuth(String ak, String sk) {<br>            // 获取token地址<br>            String authHost = &quot;<a href="https://aip.baidubce.com/oauth/2.0/token" target="_blank" rel="noopener">https://aip.baidubce.com/oauth/2.0/token</a>?&quot;;<br>            String getAccessTokenUrl = authHost<br>                    // 1. grant_type为固定参数<br>                    &#43; &quot;grant_type=client_credentials&quot;<br>                    // 2. 官网获取的 API Key<br>                    &#43; &quot;&amp;client_id=&quot; &#43; ak<br>                    // 3. 官网获取的 Secret Key<br>                    &#43; &quot;&amp;client_secret=&quot; &#43; sk;<br>            try {<br>                URL realUrl = new URL(getAccessTokenUrl);<br>                // 打开和URL之间的连接<br>                HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();<br>                connection.setRequestMethod(&quot;GET&quot;);<br>                connection.connect();<br>                // 获取所有响应头字段<br>                Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();<br>                // 遍历所有的响应头字段<br>                for (String key : map.keySet()) {<br>                    System.err.println(key &#43; &quot;—&gt;&quot; &#43; map.get(key));<br>                }<br>                // 定义 BufferedReader输入流来读取URL的响应<br>                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));<br>                String result = &quot;&quot;;<br>                String line;<br>                while ((line = in.readLine()) != null) {<br>                    result &#43;= line;<br>                }<br>                /**<br>                 * 返回结果示例<br>                 */<br>                System.err.println(&quot;result:&quot; &#43; result);<br>                JSONObject jsonObject = new JSONObject(result);<br>                String access_token = jsonObject.getString(&quot;access_token&quot;);<br>                return access_token;<br>            } catch (Exception e) {<br>                System.err.printf(&quot;获取token失败！&quot;);<br>                e.printStackTrace(System.err);<br>            }<br>            return null;<br>        }</p><h2>}<span style="font-family:SimSun">&nbsp; &nbsp;</span></h2></pre><h1 style="font-family:monospace; white-space:pre"><span style="font-family:SimSun">需要调用的几个类：</span></h1><pre class="java">package com.baidu.ai.aip.utils;<p>/**</p><ul><li><p>Base64 工具类</p></li><li><p>/<br>public class Base64Util {<br>  private static final char last2byte = (char) Integer.parseInt(&quot;00000011&quot;, 2);<br>  private static final char last4byte = (char) Integer.parseInt(&quot;00001111&quot;, 2);<br>  private static final char last6byte = (char) Integer.parseInt(&quot;00111111&quot;, 2);<br>  private static final char lead6byte = (char) Integer.parseInt(&quot;11111100&quot;, 2);<br>  private static final char lead4byte = (char) Integer.parseInt(&quot;11110000&quot;, 2);<br>  private static final char lead2byte = (char) Integer.parseInt(&quot;11000000&quot;, 2);<br>  private static final char[] encodeTable = new char[]{‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’, ‘J’, ‘K’, ‘L’, ‘M’, ‘N’, ‘O’, ‘P’, ‘Q’, ‘R’, ‘S’, ‘T’, ‘U’, ‘V’, ‘W’, ‘X’, ‘Y’, ‘Z’, ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’, ‘k’, ‘l’, ‘m’, ‘n’, ‘o’, ‘p’, ‘q’, ‘r’, ‘s’, ‘t’, ‘u’, ‘v’, ‘w’, ‘x’, ‘y’, ‘z’, ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘&#43;’, ‘/‘};</p><p>  public Base64Util() {<br>  }</p><p>  public static String encode(byte[] from) {</p><pre><code>StringBuilder to = new StringBuilder((int) ((double) from.length * 1.34D) &amp;#43; 3);int num = 0;char currentByte = 0;int i;for (i = 0; i &amp;lt; from.length; &amp;#43;&amp;#43;i) {    for (num %= 8; num &amp;lt; 8; num &amp;#43;= 6) {        switch (num) {            case 0:                currentByte = (char) (from[i] &amp;amp; lead6byte);                currentByte = (char) (currentByte &amp;gt;&amp;gt;&amp;gt; 2);            case 1:            case 3:            case 5:            default:                break;            case 2:                currentByte = (char) (from[i] &amp;amp; last6byte);                break;            case 4:                currentByte = (char) (from[i] &amp;amp; last4byte);                currentByte = (char) (currentByte &amp;lt;&amp;lt; 2);                if (i &amp;#43; 1 &amp;lt; from.length) {                    currentByte = (char) (currentByte | (from[i &amp;#43; 1] &amp;amp; lead2byte) &amp;gt;&amp;gt;&amp;gt; 6);                }                break;            case 6:                currentByte = (char) (from[i] &amp;amp; last2byte);                currentByte = (char) (currentByte &amp;lt;&amp;lt; 4);                if (i &amp;#43; 1 &amp;lt; from.length) {                    currentByte = (char) (currentByte | (from[i &amp;#43; 1] &amp;amp; lead4byte) &amp;gt;&amp;gt;&amp;gt; 4);                }        }        to.append(encodeTable[currentByte]);    }}if (to.length() % 4 != 0) {    for (i = 4 - to.length() % 4; i &amp;gt; 0; --i) {        to.append(&amp;quot;=&amp;quot;);    }}return to.toString();</code></pre><p>  }<br>}<br></pre></p><br><pre class="java">package com.baidu.ai.aip.utils;</li></ul><p>import java.io.*;</p><p>/**</p><ul><li><p>文件读取工具类</p></li><li><p>/<br>public class FileUtil {</p><p>  /**</p><ul><li><p>读取文件内容，作为字符串返回</p></li><li><p>/<br>public static String readFileAsString(String filePath) throws IOException {<br>  File file = new File(filePath);<br>  if (!file.exists()) {</p><pre><code>throw new FileNotFoundException(filePath);</code></pre><p>  } </p><p>  if (file.length() &gt; 1024 * 1024 * 1024) {</p><pre><code>throw new IOException(&amp;quot;File is too large&amp;quot;);</code></pre><p>  } </p><p>  StringBuilder sb = new StringBuilder((int) (file.length()));<br>  // 创建字节输入流<br>  FileInputStream fis = new FileInputStream(filePath);<br>  // 创建一个长度为10240的Buffer<br>  byte[] bbuf = new byte[10240];<br>  // 用于保存实际读取的字节数<br>  int hasRead = 0;<br>  while ( (hasRead = fis.read(bbuf)) &gt; 0 ) {  </p><pre><code>sb.append(new String(bbuf, 0, hasRead));  </code></pre><p>  }<br>  fis.close();<br>  return sb.toString();<br>}</p><p>/**</p></li><li><p>根据文件路径读取byte[] 数组</p></li><li><p>/<br>public static byte[] readFileByBytes(String filePath) throws IOException {<br>  File file = new File(filePath);<br>  if (!file.exists()) {</p><pre><code>throw new FileNotFoundException(filePath);</code></pre><p>  } else {</p><pre><code>ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length());BufferedInputStream in = null;try {    in = new BufferedInputStream(new FileInputStream(file));    short bufSize = 1024;    byte[] buffer = new byte[bufSize];    int len1;    while (-1 != (len1 = in.read(buffer, 0, bufSize))) {        bos.write(buffer, 0, len1);    }    byte[] var7 = bos.toByteArray();    return var7;} finally {    try {        if (in != null) {            in.close();        }    } catch (IOException var14) {        var14.printStackTrace();    }    bos.close();}</code></pre><p>  }<br>}<br>}<br></pre></p><pre class="java">package com.baidu.ai.aip.utils;</li></ul></li></ul><p>import java.io.BufferedReader;<br>import java.io.DataOutputStream;<br>import java.io.InputStreamReader;<br>import java.net.HttpURLConnection;<br>import java.net.URL;<br>import java.util.List;<br>import java.util.Map;</p><p>/**</p><ul><li><p>http 工具类</p></li><li><p>/<br>public class HttpUtil {</p><p>  public static String post(String requestUrl, String accessToken, String params)</p><pre><code>    throws Exception {String contentType = &amp;quot;application/x-www-form-urlencoded&amp;quot;;return HttpUtil.post(requestUrl, accessToken, contentType, params);</code></pre><p>  }</p><p>  public static String post(String requestUrl, String accessToken, String contentType, String params)</p><pre><code>    throws Exception {String encoding = &amp;quot;UTF-8&amp;quot;;if (requestUrl.contains(&amp;quot;nlp&amp;quot;)) {    encoding = &amp;quot;GBK&amp;quot;;}return HttpUtil.post(requestUrl, accessToken, contentType, params, encoding);</code></pre><p>  }</p><p>  public static String post(String requestUrl, String accessToken, String contentType, String params, String encoding)</p><pre><code>    throws Exception {String url = requestUrl &amp;#43; &amp;quot;?access_token=&amp;quot; &amp;#43; accessToken;return HttpUtil.postGeneralUrl(url, contentType, params, encoding);</code></pre><p>  }</p><p>  public static String postGeneralUrl(String generalUrl, String contentType, String params, String encoding)</p><pre><code>    throws Exception {URL url = new URL(generalUrl);// 打开和URL之间的连接HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setRequestMethod(&amp;quot;POST&amp;quot;);// 设置通用的请求属性connection.setRequestProperty(&amp;quot;Content-Type&amp;quot;, contentType);connection.setRequestProperty(&amp;quot;Connection&amp;quot;, &amp;quot;Keep-Alive&amp;quot;);connection.setUseCaches(false);connection.setDoOutput(true);connection.setDoInput(true);// 得到请求的输出流对象DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.write(params.getBytes(encoding));out.flush();out.close();// 建立实际的连接connection.connect();// 获取所有响应头字段Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; headers = connection.getHeaderFields();// 遍历所有的响应头字段for (String key : headers.keySet()) {    System.err.println(key &amp;#43; &amp;quot;---&amp;gt;&amp;quot; &amp;#43; headers.get(key));}// 定义 BufferedReader输入流来读取URL的响应BufferedReader in = null;in = new BufferedReader(        new InputStreamReader(connection.getInputStream(), encoding));String result = &amp;quot;&amp;quot;;String getLine;while ((getLine = in.readLine()) != null) {    result &amp;#43;= getLine;}in.close();System.err.println(&amp;quot;result:&amp;quot; &amp;#43; result);return result;</code></pre><p>  }<br>}<br></pre></p><br><h1><span style="font-size:14px"><span style="white-space:pre"></span></span></h1><h1><span style="font-size:32px">&nbsp; &nbsp; &nbsp; &nbsp; 识别前的图片</span></h1><p><span style="font-size:14px"><img src="https://img-blog.csdn.net/20180317205108031" alt=""><br></span></p><p><span style="font-size:14px"><br></span></p><p><span style="font-size:32px"><br></span></p><p><strong><span style="font-size:32px">&nbsp; &nbsp; &nbsp; &nbsp;识别后的输出数据</span></strong></p><p><span style="font-size:14px"></span></p><div>&nbsp;{&quot;log_id&quot;:&nbsp;8037719738599397843,&nbsp;&quot;words_result_num&quot;:&nbsp;14,&nbsp;&quot;words_result&quot;:&nbsp;[{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;1043,&nbsp;&quot;top&quot;:&nbsp;0,&nbsp;&quot;height&quot;:&nbsp;172,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;住所:浙江省永嘉县瓯北镇报喜鸟工业区长猜业执照信息公示专用&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;464,&nbsp;&quot;top&quot;:&nbsp;21,&nbsp;&quot;height&quot;:&nbsp;57,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;企业名称:报喜鸟控股份有限公司&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;400,&nbsp;&quot;top&quot;:&nbsp;76,&nbsp;&quot;height&quot;:&nbsp;39,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;类型:其他股份有限公司(上市)&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;238,&nbsp;&quot;top&quot;:&nbsp;149,&nbsp;&quot;height&quot;:&nbsp;32,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;法定代表人:吴志泽&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;272,&nbsp;&quot;top&quot;:&nbsp;186,&nbsp;&quot;height&quot;:&nbsp;29,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;成立时间:2001-06-20&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;354,&nbsp;&quot;top&quot;:&nbsp;219,&nbsp;&quot;height&quot;:&nbsp;31,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;注册资本:126328万人民币元&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;303,&nbsp;&quot;top&quot;:&nbsp;255,&nbsp;&quot;height&quot;:&nbsp;32,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;营业期限:200106-20至&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;1121,&nbsp;&quot;top&quot;:&nbsp;285,&nbsp;&quot;height&quot;:&nbsp;38,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;经营范围:服装、皮鞋、皮革制品的生产及销售,经营进出口业务,经济信息咨询服务,企业管理&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;983,&nbsp;&quot;top&quot;:&nbsp;325,&nbsp;&quot;height&quot;:&nbsp;33,&nbsp;&quot;left&quot;:&nbsp;128},&nbsp;&quot;words&quot;:&nbsp;&quot;与咨询服务,培训服务,企业营销策划,房屋租赁,实业投资,投资管理,资产管理,&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;999,&nbsp;&quot;top&quot;:&nbsp;358,&nbsp;&quot;height&quot;:&nbsp;35,&nbsp;&quot;left&quot;:&nbsp;124},&nbsp;&quot;words&quot;:&nbsp;&quot;投资咨询,企业管理咨询(未经金融等监管部门批准,不得从事向公众融资存款、融资&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;999,&nbsp;&quot;top&quot;:&nbsp;393,&nbsp;&quot;height&quot;:&nbsp;33,&nbsp;&quot;left&quot;:&nbsp;124},&nbsp;&quot;words&quot;:&nbsp;&quot;担保、代客理财等金融服务)。(依法须经批准的项目,经相关部门批准后方可开展经&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;105,&nbsp;&quot;top&quot;:&nbsp;429,&nbsp;&quot;height&quot;:&nbsp;34,&nbsp;&quot;left&quot;:&nbsp;123},&nbsp;&quot;words&quot;:&nbsp;&quot;营活动)&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;393,&nbsp;&quot;top&quot;:&nbsp;463,&nbsp;&quot;height&quot;:&nbsp;34,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;登记机关:浙江省工商行政管理局&quot;},&nbsp;{&quot;location&quot;:&nbsp;{&quot;width&quot;:&nbsp;274,&nbsp;&quot;top&quot;:&nbsp;499,&nbsp;&quot;height&quot;:&nbsp;34,&nbsp;&quot;left&quot;:&nbsp;0},&nbsp;&quot;words&quot;:&nbsp;&quot;核准时间:2017-08-15&quot;}]}<br></div><br><p></p><br></li></ul>]]></content>
      
      
      <categories>
          
          <category> OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
            <tag> OCR文字识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat闪退解决方案</title>
      <link href="/blog/2018/03/11/Tomcat%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2018/03/11/Tomcat%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>1.<span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">因首先确定JDK环境变量是否有问题（相信肯定没问题啦）</span>.</p><p><br></p><p>2.<span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">一行加入确定闪退原因</span></p><p><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">编辑startup.bat，在最后一行加入 &nbsp;pause ，然后保存，再次运行，就可以看到闪退的原因</span><br></p><p><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">一般是告诉你jre环境有问题（现在可以去掉PAUSE了）</span></p><p><br></p><p><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">解决方案：</span></p><p><span style="color:rgb(51,51,51); font-family:'Microsoft Yahei',微软雅黑,arial,宋体,sans-serif; font-size:14px; line-height:24px; text-align:justify">找到startup.bat 记事本打开，添加下面的两行带码</span></p><p><span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:16px; line-height:24px"><span style="color:#666666">SET JAVA_HOME=C:\Program Files\Java\jdk1.8.0_60 &nbsp;//这里是jdk的安装目录</span></span><br style="margin:0px; padding:0px; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:16px; line-height:24px"><span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:16px; line-height:24px"><span style="color:#666666">SET JRE_HOME=<span style="font-family:Verdana,Arial,Helvetica,sans-serif; font-size:16px; line-height:24px">C:\Program Files\Java\jre</span>//这里是JRE的目录&nbsp;</span></span></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomacat闪退 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js中利用ES6特性的数组排序及求最大（小）值的多种方案</title>
      <link href="/blog/2017/12/09/Js%E4%B8%AD%E5%88%A9%E7%94%A8ES6%E7%89%B9%E6%80%A7%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%B1%82%E6%9C%80%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E5%80%BC%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2017/12/09/Js%E4%B8%AD%E5%88%A9%E7%94%A8ES6%E7%89%B9%E6%80%A7%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8F%8A%E6%B1%82%E6%9C%80%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E5%80%BC%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><br><p><strong><span style="font-size:24px">1.数组去重</span></strong></p><p><span style="font-size:18px"><br></span></p><p><span style="font-size:18px">方案1：</span></p><p><span style="font-size:12px">思路：对待去重的数组arr进行for循环遍历，然后在新的数组newArr中去查找当前被遍历的元素arr[i]，如果返回&#20540;为-1，说明在新的数组中还没有出现过当前被遍历的元素arr[i]，则把该元素放到新的数组中。当数组arr遍历完以后，新数组newArr就是去重以后的数组。</span></p><p><pre name="code" class="javascript">var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr = [];for(var i = 0; i &lt; arr.length; i++) {if(newArr.indexOf(arr[i]) === -1) {newArr.push(arr[i]);}}console.log(newArr);</pre><br></p><p><span style="font-size:18px">方案2：</span></p><p>思路：该方案和方案1思路相同，只不过是使用reduce方法进行遍历。</p><p><pre name="code" class="javascript">var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr = arr.reduce((newArr, current) =&gt; {if(newArr.indexOf(current) === -1) {newArr.push(current);}return newArr;}, []);console.log(newArr);</pre><br></p><p><span style="font-size:18px">方案3：</span></p><p>思路：当前方案使用了ES6新增的set数据解构的去重特性，然后在将生成的set对象转换成数组。</p><p><pre name="code" class="javascript">var arr = [1, 4, 7, 4, 3, 2, 1, 4, 7];var newArr = Array.from(new Set(arr));console.log(newArr);</pre></p><p><br></p><p><br></p><br><span style="color:rgb(34,34,34); font-family:'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:27.2px"><span style="font-size:24px"><strong>2.在数组中找出最小&#20540;（或者最大&#20540;）</strong></span></span><br><p><span style="color:rgb(34,34,34); font-family:'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:27.2px"></span></p><div><p><span style="font-size:18px">实现方案1：</span></p><p><span style="font-size:12px">思路：假设第一个数组元素是最小&#20540;，然后对数组后面的元素进行遍历、判断，如果当前被遍历的元素小于iMin变量的&#20540;，说明iMin变量的&#20540;还不是最小&#20540;，则将当前遍历的元素&#20540;替换掉iMin变量的&#20540;。当循环结束，iMin变量的&#20540;就是数组中最小的&#20540;。</span></p><p><span style="font-size:12px"></span><pre name="code" class="javascript">var arr = [23, 45, 40, 30, 12];var iMin = arr.shift();arr.forEach((v) =&gt; {iMin = v &lt; iMin ? v : iMin;});console.log(iMin);</pre><br></p><p><span style="font-size:18px"><strong>实现方案2：</strong></span></p><p><span style="font-size:14px">思路：利用Math.min()方法求最小&#20540;，但是该方法的参数是一个数&#20540;列表，而不是一个数组，故使用ES6新增的扩展运算符将数组转换成列表，然后传递到Math.min()方法中去即可。</span></p><p><span style="font-size:14px"></span><pre name="code" class="javascript">var arr = [23, 45, 40, 30, 12];var iMin = Math.min(...arr);console.log(iMin);</pre><br><br></p></div><p></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数组排序 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生Bootstrap实现动态分页</title>
      <link href="/blog/2017/12/03/%E5%8E%9F%E7%94%9FBootstrap%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%A1%B5/"/>
      <url>/blog/2017/12/03/%E5%8E%9F%E7%94%9FBootstrap%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="font-size:18px"> &nbsp;<span style="font-family:Microsoft YaHei"> 最近开发时需要动态显示分页页数，写了一个动态显示页数的算法。效果为动态显示当前页数以及后的页数，规定自己想要显示的页数x，若总页数小于x，则显示自己的页数，若大于x，则每次只显示当前所在页数，以及之后的x页。</span></span></p><p><pre name="code" class="html">&lt;!-- 动态获取我的思维导图的页数 --&gt;    function getMyMindMapPage(currentPage){<pre><code>var html=&amp;quot;&amp;quot;;var lastPage;var nextPage;var showPage=4;      //每次显示的页数var index;var x;               //定义后面页数固定var adata={&amp;quot;parentid&amp;quot;:&amp;quot;00100&amp;quot;};var data=JSON.stringify(adata);$.ajax({    type:&amp;quot;post&amp;quot;,    contentType:&amp;quot;application/json&amp;quot;,    dataType:&amp;quot;json&amp;quot;,    data:data,    url:&amp;quot;myMindMapTotal.do&amp;quot;,    success:function(data){        if(data==null){            alert(&amp;quot;获取失败&amp;quot;);        }else{            html+=&amp;quot;&amp;lt;ul class=&apos;pagination&apos;&amp;gt;&amp;quot;;            html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(1)&apos;&amp;gt;首页&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;            lastPage=currentPage;            if(lastPage&amp;lt;=1){                lastPage==1;            }else{                lastPage--;            }            html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(&amp;quot;+lastPage+&amp;quot;)&apos;&amp;gt;上一页&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;            if(data&amp;lt;=showPage){                for(var i=1;i&amp;lt;=data;i++){                    html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(&amp;quot;+i+&amp;quot;)&apos;&amp;gt;&amp;quot;+i+&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;                }            }else{                index=currentPage+showPage;                x=currentPage;                if(index&amp;gt;data){                    index=data+1;                    x=index-showPage;                }                for(var i=x;i&amp;lt;index;i++){                    html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(&amp;quot;+i+&amp;quot;)&apos;&amp;gt;&amp;quot;+i+&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;                }            } </code></pre><p>​<br>                    nextPage=currentPage;<br>                    if(nextPage&lt;data){<br>                        nextPage++;<br>                    }else if(nextPage==data){<br>                        nextPage=data;<br>                    }</p><pre><code>                html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(&amp;quot;+nextPage+&amp;quot;)&apos;&amp;gt;下一页&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;                html+=&amp;quot;&amp;lt;li&amp;gt;&amp;lt;span onclick=&apos;getMyMindMap(&amp;quot;+data+&amp;quot;)&apos;&amp;gt;尾页&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;;                html+=&amp;quot;&amp;lt;/ul&amp;gt;&amp;quot;;                $(&amp;quot;#jsmind_container&amp;quot;).append(html);             }        },        error:function(e){            alert(&amp;quot;网络连接失败!&amp;quot;);        },    });}&lt;/pre&gt;&lt;br&gt;</code></pre><p><span style="font-size:18px">效果图</span></p></p><p><span style="font-size:18px"><img src="https://img-blog.csdn.net/20171203165314926" alt=""><br></span></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hibernate4中将fileStream转换为Blob</title>
      <link href="/blog/2017/11/01/hibernate4%E4%B8%AD%E5%B0%86fileStream%E8%BD%AC%E6%8D%A2%E4%B8%BABlob/"/>
      <url>/blog/2017/11/01/hibernate4%E4%B8%AD%E5%B0%86fileStream%E8%BD%AC%E6%8D%A2%E4%B8%BABlob/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-将fileStream转换为blob类型的方法"><a href="#1-将fileStream转换为blob类型的方法" class="headerlink" title="1.将fileStream转换为blob类型的方法"></a>1.将fileStream转换为blob类型的方法</h3><p>fileStreamToBlob.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Blob toBlob(InputStream inputStream) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">Configuration cfg &#x3D; new Configuration().configure();</span><br><span class="line">ServiceRegistry sr &#x3D; new ServiceRegistryBuilder().applySettings(</span><br><span class="line">cfg.getProperties()).buildServiceRegistry();</span><br><span class="line">SessionFactory sf &#x3D; cfg.buildSessionFactory(sr);</span><br><span class="line">Session session &#x3D; sf.openSession();</span><br><span class="line"></span><br><span class="line">LobHelper lobHelper &#x3D; session.getLobHelper();</span><br><span class="line">Blob blob &#x3D; lobHelper.createBlob(inputStream, inputStream.available());</span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">return blob;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-再加一个hibernate配置文件"><a href="#2-再加一个hibernate配置文件" class="headerlink" title="2.再加一个hibernate配置文件"></a>2.再加一个hibernate配置文件</h3><p>hibernate.cfg.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">    &quot;-&#x2F;&#x2F;Hibernate&#x2F;Hibernate Configuration DTD 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.hibernate.org&#x2F;dtd&#x2F;hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line">    &lt;session-factory&gt;</span><br><span class="line">        &lt;!-- property 元素用于配置Hibernate中的属性</span><br><span class="line">            键:值 </span><br><span class="line">          --&gt;</span><br><span class="line">          &lt;!-- hibernate.connection.driver_class : 连接数据库的驱动  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;!-- hibernate.connection.username : 连接数据库的用户名 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.connection.username&quot;&gt;root&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;!-- hibernate.connection.password : 连接数据库的密码 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.connection.password&quot;&gt;123456&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          &lt;!-- hibernate.connection.url : 连接数据库的地址,路径 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;demo&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- show_sql: 操作数据库时,会 向控制台打印sql语句 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;show_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- format_sql: 打印sql语句前,会将sql语句先格式化  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;format_sql&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &lt;!-- hbm2ddl.auto: 生成表结构的策略配置</span><br><span class="line">             update(最常用的取值): 如果当前数据库中不存在表结构,那么自动创建表结构. </span><br><span class="line">                     如果存在表结构,并且表结构与实体一致,那么不做修改</span><br><span class="line">                     如果存在表结构,并且表结构与实体不一致,那么会修改表结构.会保留原有列.</span><br><span class="line">             create(很少):无论是否存在表结构.每次启动Hibernate都会重新创建表结构.(数据会丢失)</span><br><span class="line">             create-drop(极少): 无论是否存在表结构.每次启动Hibernate都会重新创建表结构.每次Hibernate运行结束时,删除表结构.</span><br><span class="line">             validate(很少):不会自动创建表结构.也不会自动维护表结构.Hibernate只校验表结构. 如果表结构不一致将会抛出异常.</span><br><span class="line">          --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hbm2ddl.auto&quot;&gt;update&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 数据库方言配置 </span><br><span class="line">         org.hibernate.dialect.MySQLDialect (选择最短的)</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        &lt;!-- hibernate.connection.autocommit: 事务自动提交  --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.connection.autocommit&quot;&gt;true&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        &lt;!-- 将Session与线程绑定&#x3D;&gt; 只有配置了该配置,才能使用getCurrentSession --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 引入ORM 映射文件 </span><br><span class="line">            填写src之后的路径</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;!-- &lt;mapping resource&#x3D;&quot;com&#x2F;itheima&#x2F;a_hello&#x2F;User.hbm.xml&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;&#x2F;session-factory&gt;</span><br><span class="line">&lt;&#x2F;hibernate-configuration&gt;</span><br></pre></td></tr></table></figure><br><h3 id="3-调用该方法将hibernate4中的fileStream转换为Blob"><a href="#3-调用该方法将hibernate4中的fileStream转换为Blob" class="headerlink" title="3.调用该方法将hibernate4中的fileStream转换为Blob"></a>3.调用该方法将hibernate4中的fileStream转换为Blob</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(newsPageByte);</span><br><span class="line"></span><br><span class="line">Blob blob &#x3D; streamToBlob.toBlob(file.getInputStream());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库存储图片 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Demo</title>
      <link href="/blog/about/index.html"/>
      <url>/blog/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/huoji555/Mind-Map" target="_blank" rel="noopener">基于思维导图的可视化学习系统 </a> </li><li><a href="https://github.com/huoji555/Ticket-Manger" target="_blank" rel="noopener">票据管理系统</a></li><li><a href="https://github.com/huoji555/Universe" target="_blank" rel="noopener">全文搜索引擎</a></li><li><a href="https://github.com/huoji555/Shadow" target="_blank" rel="noopener">计算机基础知识</a></li><li><a href="https://github.com/huoji555/Shadow/tree/master/pic" target="_blank" rel="noopener">OCR识别文字工具</a></li></ul><p>以上项目均托管在GitHub上，欢迎Star.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/blog/archives/index.html"/>
      <url>/blog/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/blog/categories/index.html"/>
      <url>/blog/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tagcloud</title>
      <link href="/blog/tags/index.html"/>
      <url>/blog/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
